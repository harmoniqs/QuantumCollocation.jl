<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Unitary Problem Templates · QuantumCollocation.jl</title><meta name="title" content="Unitary Problem Templates · QuantumCollocation.jl"/><meta property="og:title" content="Unitary Problem Templates · QuantumCollocation.jl"/><meta property="twitter:title" content="Unitary Problem Templates · QuantumCollocation.jl"/><meta name="description" content="Documentation for QuantumCollocation.jl."/><meta property="og:description" content="Documentation for QuantumCollocation.jl."/><meta property="twitter:description" content="Documentation for QuantumCollocation.jl."/><meta property="og:url" content="https://docs.harmoniqs.co/QuantumCollocation.jl/generated/man/unitary_problem_templates/"/><meta property="twitter:url" content="https://docs.harmoniqs.co/QuantumCollocation.jl/generated/man/unitary_problem_templates/"/><link rel="canonical" href="https://docs.harmoniqs.co/QuantumCollocation.jl/generated/man/unitary_problem_templates/"/><script data-outdated-warner src="../../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../../assets/documenter.js"></script><script src="../../../search_index.js"></script><script src="../../../siteinfo.js"></script><script src="../../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../../">QuantumCollocation.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../../">Home</a></li><li><span class="tocitem">Library</span><ul><li><a class="tocitem" href="../ket_problem_templates/">Ket Problem Templates</a></li><li class="is-active"><a class="tocitem" href>Unitary Problem Templates</a><ul class="internal"><li><a class="tocitem" href="#Unitary-Smooth-Pulse-Problem"><span>Unitary Smooth Pulse Problem</span></a></li><li><a class="tocitem" href="#Unitary-Minimum-Time-Problem"><span>Unitary Minimum Time Problem</span></a></li><li><a class="tocitem" href="#Unitary-Sampling-Problem"><span>Unitary Sampling Problem</span></a></li><li><a class="tocitem" href="#Unitary-Variational-Problem"><span>Unitary Variational Problem</span></a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Library</a></li><li class="is-active"><a href>Unitary Problem Templates</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Unitary Problem Templates</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/harmoniqs/QuantumCollocation.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/harmoniqs/QuantumCollocation.jl/blob/main/docs/literate/man/unitary_problem_templates.jl" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><pre><code class="language-julia hljs">using NamedTrajectories
using PiccoloQuantumObjects
using QuantumCollocation</code></pre><hr/><h2 id="Unitary-Smooth-Pulse-Problem"><a class="docs-heading-anchor" href="#Unitary-Smooth-Pulse-Problem">Unitary Smooth Pulse Problem</a><a id="Unitary-Smooth-Pulse-Problem-1"></a><a class="docs-heading-anchor-permalink" href="#Unitary-Smooth-Pulse-Problem" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumCollocation.ProblemTemplates.UnitarySmoothPulseProblem-generated-man-unitary_problem_templates" href="#QuantumCollocation.ProblemTemplates.UnitarySmoothPulseProblem-generated-man-unitary_problem_templates"><code>QuantumCollocation.ProblemTemplates.UnitarySmoothPulseProblem</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">UnitarySmoothPulseProblem(system::AbstractQuantumSystem, operator::AbstractPiccoloOperator, T::Int, Δt::Float64; kwargs...)
UnitarySmoothPulseProblem(H_drift, H_drives, operator, T, Δt; kwargs...)</code></pre><p>Construct a <code>DirectTrajOptProblem</code> for a free-time unitary gate problem with smooth control pulses enforced by constraining the second derivative of the pulse trajectory, i.e.,</p><p class="math-container">\[\begin{aligned}
\underset{\vec{\tilde{U}}, a, \dot{a}, \ddot{a}, \Delta t}{\text{minimize}} &amp; \quad
Q \cdot \ell\qty(\vec{\tilde{U}}_T, \vec{\tilde{U}}_{\text{goal}}) + \frac{1}{2} \sum_t \qty(R_a a_t^2 + R_{\dot{a}} \dot{a}_t^2 + R_{\ddot{a}} \ddot{a}_t^2) \\
\text{ subject to } &amp; \quad \vb{P}^{(n)}\qty(\vec{\tilde{U}}_{t+1}, \vec{\tilde{U}}_t, a_t, \Delta t_t) = 0 \\
&amp; \quad a_{t+1} - a_t - \dot{a}_t \Delta t_t = 0 \\
&amp; \quad \dot{a}_{t+1} - \dot{a}_t - \ddot{a}_t \Delta t_t = 0 \\
&amp; \quad |a_t| \leq a_{\text{bound}} \\
&amp; \quad |\ddot{a}_t| \leq \ddot{a}_{\text{bound}} \\
&amp; \quad \Delta t_{\text{min}} \leq \Delta t_t \leq \Delta t_{\text{max}} \\
\end{aligned}\]</p><p>where, for <span>$U \in SU(N)$</span>,</p><p class="math-container">\[\ell\qty(\vec{\tilde{U}}_T, \vec{\tilde{U}}_{\text{goal}}) =
\abs{1 - \frac{1}{N} \abs{ \tr \qty(U_{\text{goal}}, U_T)} }\]</p><p>is the <em>infidelity</em> objective function, <span>$Q$</span> is a weight, <span>$R_a$</span>, <span>$R_{\dot{a}}$</span>, and <span>$R_{\ddot{a}}$</span> are weights on the regularization terms, and <span>$\vb{P}^{(n)}$</span> is the <span>$n$</span>th-order Pade integrator.</p><p><strong>Arguments</strong></p><ul><li><code>system::AbstractQuantumSystem</code>: the system to be controlled</li></ul><p>or</p><ul><li><code>H_drift::AbstractMatrix{&lt;:Number}</code>: the drift hamiltonian</li><li><code>H_drives::Vector{&lt;:AbstractMatrix{&lt;:Number}}</code>: the control hamiltonians</li></ul><p>with</p><ul><li><code>goal::AbstractPiccoloOperator</code>: the target unitary, either in the form of an <code>EmbeddedOperator</code> or a `Matrix{ComplexF64}</li><li><code>T::Int</code>: the number of timesteps</li><li><code>Δt::Float64</code>: the (initial) time step size</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>piccolo_options::PiccoloOptions=PiccoloOptions()</code>: the options for the Piccolo solver</li><li><code>state_name::Symbol = :Ũ⃗</code>: the name of the state</li><li><code>control_name::Symbol = :a</code>: the name of the control</li><li><code>timestep_name::Symbol = :Δt</code>: the name of the timestep</li><li><code>init_trajectory::Union{NamedTrajectory, Nothing}=nothing</code>: an initial trajectory to use</li><li><code>a_guess::Union{Matrix{Float64}, Nothing}=nothing</code>: an initial guess for the control pulses</li><li><code>a_bound::Float64=1.0</code>: the bound on the control pulse</li><li><code>a_bounds=fill(a_bound, length(system.G_drives))</code>: the bounds on the control pulses, one for each drive</li><li><code>da_bound::Float64=Inf</code>: the bound on the control pulse derivative</li><li><code>da_bounds=fill(da_bound, length(system.G_drives))</code>: the bounds on the control pulse derivatives, one for each drive</li><li><code>dda_bound::Float64=1.0</code>: the bound on the control pulse second derivative</li><li><code>dda_bounds=fill(dda_bound, length(system.G_drives))</code>: the bounds on the control pulse second derivatives, one for each drive</li><li><code>Δt_min::Float64=Δt isa Float64 ? 0.5 * Δt : 0.5 * mean(Δt)</code>: the minimum time step size</li><li><code>Δt_max::Float64=Δt isa Float64 ? 1.5 * Δt : 1.5 * mean(Δt)</code>: the maximum time step size</li><li><code>Q::Float64=100.0</code>: the weight on the infidelity objective</li><li><code>R=1e-2</code>: the weight on the regularization terms</li><li><code>R_a::Union{Float64, Vector{Float64}}=R</code>: the weight on the regularization term for the control pulses</li><li><code>R_da::Union{Float64, Vector{Float64}}=R</code>: the weight on the regularization term for the control pulse derivatives</li><li><code>R_dda::Union{Float64, Vector{Float64}}=R</code>: the weight on the regularization term for the control pulse second derivatives</li><li><code>constraints::Vector{&lt;:AbstractConstraint}=AbstractConstraint[]</code>: the constraints to enforce</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/QuantumCollocation.jl/blob/05cca8103b29a38cf6bef6bac564d797cd53ab22/src/problem_templates/unitary_smooth_pulse_problem.jl#L4-L65">source</a></section></article><p>The <code>UnitarySmoothPulseProblem</code> is similar to the <code>QuantumStateSmoothPulseProblem</code>, but instead of driving the system to a target state, the goal is to drive the system to a target unitary operator, <code>U_goal</code>.</p><pre><code class="language-julia hljs">system = QuantumSystem(0.1 * PAULIS.Z, [PAULIS.X, PAULIS.Y])
U_goal = GATES.H
T = 51
Δt = 0.2

prob = UnitarySmoothPulseProblem(system, U_goal, T, Δt);</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">    constructing UnitarySmoothPulseProblem...
	using integrator: typeof(UnitaryIntegrator)
	control derivative names: [:da, :dda]
	applying timesteps_all_equal constraint: Δt</code></pre><p><em>check the fidelity before solving</em></p><pre><code class="language-julia hljs">println(&quot;Before: &quot;, unitary_rollout_fidelity(prob.trajectory, system))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Before: 0.08790771597592803</code></pre><p><em>finding an optimal control is as simple as calling <code>solve!</code></em></p><pre><code class="language-julia hljs">solve!(prob, max_iter=100, verbose=true, print_level=1);</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">    initializing optimizer...
        applying constraint: timesteps all equal constraint
        applying constraint: initial value of Ũ⃗
        applying constraint: initial value of a
        applying constraint: final value of a
        applying constraint: bounds on a
        applying constraint: bounds on da
        applying constraint: bounds on dda
        applying constraint: bounds on Δt</code></pre><p><em>check the fidelity after solving</em></p><pre><code class="language-julia hljs">println(&quot;After: &quot;, unitary_rollout_fidelity(prob.trajectory, system))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">After: 0.9999999969055313</code></pre><p>The <code>NamedTrajectory</code> object stores the control pulse, state variables, and the time grid.</p><p><em>extract the control pulses</em></p><pre><code class="language-julia hljs">prob.trajectory.a |&gt; size</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(2, 51)</code></pre><hr/><h2 id="Unitary-Minimum-Time-Problem"><a class="docs-heading-anchor" href="#Unitary-Minimum-Time-Problem">Unitary Minimum Time Problem</a><a id="Unitary-Minimum-Time-Problem-1"></a><a class="docs-heading-anchor-permalink" href="#Unitary-Minimum-Time-Problem" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumCollocation.ProblemTemplates.UnitaryMinimumTimeProblem-generated-man-unitary_problem_templates" href="#QuantumCollocation.ProblemTemplates.UnitaryMinimumTimeProblem-generated-man-unitary_problem_templates"><code>QuantumCollocation.ProblemTemplates.UnitaryMinimumTimeProblem</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">UnitaryMinimumTimeProblem(
    goal::AbstractPiccoloOperator,
    trajectory::NamedTrajectory,
    objective::Objective,
    dynamics::TrajectoryDynamics,
    constraints::AbstractVector{&lt;:AbstractConstraint};
    kwargs...
)

UnitaryMinimumTimeProblem(
    goal::AbstractPiccoloOperator,
    prob::DirectTrajOptProblem;
    kwargs...
)</code></pre><p>Create a minimum-time problem for unitary control.</p><p class="math-container">\[\begin{aligned}
\underset{\vec{\tilde{U}}, a, \dot{a}, \ddot{a}, \Delta t}{\text{minimize}} &amp; \quad
J(\vec{\tilde{U}}, a, \dot{a}, \ddot{a}) + D \sum_t \Delta t_t \\
\text{ subject to } &amp; \quad \vb{P}^{(n)}\qty(\vec{\tilde{U}}_{t+1}, \vec{\tilde{U}}_t, a_t, \Delta t_t) = 0 \\
&amp; c(\vec{\tilde{U}}, a, \dot{a}, \ddot{a}) = 0 \\
&amp; \quad \Delta t_{\text{min}} \leq \Delta t_t \leq \Delta t_{\text{max}} \\
\end{aligned}\]</p><p><strong>Keyword Arguments</strong></p><ul><li><code>piccolo_options::PiccoloOptions=PiccoloOptions()</code>: The Piccolo options.</li><li><code>unitary_name::Symbol=:Ũ⃗</code>: The name of the unitary for the goal.</li><li><code>final_fidelity::Float64=1.0</code>: The final fidelity constraint.</li><li><code>D::Float64=1.0</code>: The scaling factor for the minimum-time objective.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/QuantumCollocation.jl/blob/05cca8103b29a38cf6bef6bac564d797cd53ab22/src/problem_templates/unitary_minimum_time_problem.jl#L4-L37">source</a></section></article><p>The goal of this problem is to find the shortest time it takes to drive the system to a target unitary operator, <code>U_goal</code>. The problem is solved by minimizing the sum of all of the time steps. It is constructed from <code>prob</code> in the previous example.</p><pre><code class="language-julia hljs">min_prob = UnitaryMinimumTimeProblem(prob, U_goal);</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">    constructing UnitaryMinimumTimeProblem...
	final fidelity: 1.0</code></pre><p><em>check the previous duration</em></p><pre><code class="language-julia hljs">println(&quot;Duration before: &quot;, get_duration(prob.trajectory))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Duration before: 15.672435868393107</code></pre><p><em>solve the minimum time problem</em></p><pre><code class="language-julia hljs">solve!(min_prob, max_iter=100, verbose=true, print_level=1);</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">    initializing optimizer...
        applying constraint: timesteps all equal constraint
        applying constraint: initial value of Ũ⃗
        applying constraint: initial value of a
        applying constraint: final value of a
        applying constraint: bounds on a
        applying constraint: bounds on da
        applying constraint: bounds on dda
        applying constraint: bounds on Δt</code></pre><p><em>check the new duration</em></p><pre><code class="language-julia hljs">println(&quot;Duration after: &quot;, get_duration(min_prob.trajectory))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Duration after: 5.0000437655952155</code></pre><p><em>the fidelity is preserved by a constraint</em></p><pre><code class="language-julia hljs">println(&quot;Fidelity after: &quot;, unitary_rollout_fidelity(min_prob.trajectory, system))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Fidelity after: 0.9999999980932661</code></pre><hr/><h2 id="Unitary-Sampling-Problem"><a class="docs-heading-anchor" href="#Unitary-Sampling-Problem">Unitary Sampling Problem</a><a id="Unitary-Sampling-Problem-1"></a><a class="docs-heading-anchor-permalink" href="#Unitary-Sampling-Problem" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumCollocation.ProblemTemplates.UnitarySamplingProblem-generated-man-unitary_problem_templates" href="#QuantumCollocation.ProblemTemplates.UnitarySamplingProblem-generated-man-unitary_problem_templates"><code>QuantumCollocation.ProblemTemplates.UnitarySamplingProblem</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">UnitarySamplingProblem(systemns, operator, T, Δt; kwargs...)</code></pre><p>A <code>UnitarySamplingProblem</code> is a quantum control problem where the goal is to find a control pulse that generates a target unitary operator for a set of quantum systems. The controls are shared among all systems, and the optimization seeks to find the control  pulse that achieves the operator for each system. The idea is to enforce a robust solution by including multiple systems reflecting the problem uncertainty.</p><p><strong>Arguments</strong></p><ul><li><code>systems::AbstractVector{&lt;:AbstractQuantumSystem}</code>: A vector of quantum systems.</li><li><code>operators::AbstractVector{&lt;:AbstractPiccoloOperator}</code>: A vector of target operators.</li><li><code>T::Int</code>: The number of time steps.</li><li><code>Δt::Union{Float64, Vector{Float64}}</code>: The time step value or vector of time steps.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>system_labels::Vector{String} = string.(1:length(systems))</code>: The labels for each system.</li><li><code>system_weights::Vector{Float64} = fill(1.0, length(systems))</code>: The weights for each system.</li><li><code>init_trajectory::Union{NamedTrajectory, Nothing} = nothing</code>: The initial trajectory.</li><li><code>state_name::Symbol = :Ũ⃗</code>: The name of the state variable.</li><li><code>control_name::Symbol = :a</code>: The name of the control variable.</li><li><code>timestep_name::Symbol = :Δt</code>: The name of the timestep variable.</li><li><code>constraints::Vector{&lt;:AbstractConstraint} = AbstractConstraint[]</code>: The constraints.</li><li><code>a_bound::Float64 = 1.0</code>: The bound for the control amplitudes.</li><li><code>a_bounds = fill(a_bound, length(systems[1].G_drives))</code>: The bounds for the control amplitudes.</li><li><code>a_guess::Union{Matrix{Float64}, Nothing} = nothing</code>: The initial guess for the control amplitudes.</li><li><code>da_bound::Float64 = Inf</code>: The bound for the control first derivatives.</li><li><code>da_bounds = fill(da_bound, length(systems[1].G_drives))</code>: The bounds for the control first derivatives.</li><li><code>dda_bound::Float64 = 1.0</code>: The bound for the control second derivatives.</li><li><code>dda_bounds = fill(dda_bound, length(systems[1].G_drives))</code>: The bounds for the control second derivatives.</li><li><code>Δt_min::Float64 = 0.5 * Δt</code>: The minimum time step size.</li><li><code>Δt_max::Float64 = 1.5 * Δt</code>: The maximum time step size.</li><li><code>Q::Float64 = 100.0</code>: The fidelity weight.</li><li><code>R::Float64 = 1e-2</code>: The regularization weight.</li><li><code>R_a::Union{Float64, Vector{Float64}} = R</code>: The regularization weight for the control amplitudes.</li><li><code>R_da::Union{Float64, Vector{Float64}} = R</code>: The regularization weight for the control first derivatives.</li><li><code>R_dda::Union{Float64, Vector{Float64}} = R</code>: The regularization weight for the control second derivatives.</li><li><code>piccolo_options::PiccoloOptions = PiccoloOptions()</code>: The Piccolo options.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/QuantumCollocation.jl/blob/05cca8103b29a38cf6bef6bac564d797cd53ab22/src/problem_templates/unitary_sampling_problem.jl#L4-L43">source</a></section></article><p>A sampling problem is used to solve over multiple quantum systems with the same control. This can be useful for exploring robustness, for example.</p><p><em>create a sampling problem</em></p><pre><code class="language-julia hljs">driftless_system = QuantumSystem([PAULIS.X, PAULIS.Y])
sampling_prob = UnitarySamplingProblem([system, driftless_system], U_goal, T, Δt);</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">    constructing UnitarySamplingProblem...
	using integrator: typeof(UnitaryIntegrator)
	using 2 systems
	applying timesteps_all_equal constraint: Δt</code></pre><p><em>new keys are addded to the trajectory for the new states</em></p><pre><code class="language-julia hljs">println(sampling_prob.trajectory.state_names)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(:Ũ⃗_system_1, :a, :da, :Ũ⃗_system_2)</code></pre><p><em>the <code>solve!</code> proceeds as in the <a href="#Quantum-State-Sampling-Problem">Quantum State Sampling Problem</a>]</em></p><hr/><h2 id="Unitary-Variational-Problem"><a class="docs-heading-anchor" href="#Unitary-Variational-Problem">Unitary Variational Problem</a><a id="Unitary-Variational-Problem-1"></a><a class="docs-heading-anchor-permalink" href="#Unitary-Variational-Problem" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumCollocation.ProblemTemplates.UnitaryVariationalProblem-generated-man-unitary_problem_templates" href="#QuantumCollocation.ProblemTemplates.UnitaryVariationalProblem-generated-man-unitary_problem_templates"><code>QuantumCollocation.ProblemTemplates.UnitaryVariationalProblem</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">UnitaryVariationalProblem(
    system::VariationalQuantumSystem,
    goal::AbstractPiccoloOperator,
    T::Int,
    Δt::Union{Float64, &lt;:AbstractVector{Float64}};
    robust_times::AbstractVector{&lt;:Union{AbstractVector{Int}, Nothing}}=[nothing for s ∈ system.G_vars],
    sensitive_times::AbstractVector{&lt;:Union{AbstractVector{Int}, Nothing}}=[nothing for s ∈ system.G_vars],
    kwargs...
)</code></pre><p>Constructs a unitary variational problem for optimizing quantum control trajectories.</p><p><strong>Arguments</strong></p><ul><li><code>system::VariationalQuantumSystem</code>: The quantum system to be controlled, containing variational parameters.</li><li><code>goal::AbstractPiccoloOperator</code>: The target operator or state to achieve at the end of the trajectory.</li><li><code>T::Int</code>: The total number of timesteps in the trajectory.</li><li><code>Δt::Union{Float64, &lt;:AbstractVector{Float64}}</code>: The timestep duration or a vector of timestep durations.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>robust_times::AbstractVector</code>: Times at which robustness to variations in the trajectory is enforced.</li><li><code>sensitive_times::AbstractVector</code>: Times at which sensitivity to variations in the trajectory is enhanced.</li><li><code>unitary_integrator</code>: The integrator used for unitary evolution (default: <code>VariationalUnitaryIntegrator</code>).</li><li><code>state_name::Symbol</code>: The name of the state variable in the trajectory (default: <code>:Ũ⃗</code>).</li><li><code>variational_state_name::Symbol</code>: The name of the variational state variable (default: <code>:Ũ⃗ₐ</code>).</li><li><code>variational_scales::AbstractVector</code>: Scaling factors for the variational state variables (default: <code>1.0</code>).</li><li><code>control_name::Symbol</code>: The name of the control variable (default: <code>:a</code>).</li><li><code>timestep_name::Symbol</code>: The name of the timestep variable (default: <code>:Δt</code>).</li><li><code>init_trajectory::Union{NamedTrajectory, Nothing}</code>: An optional initial trajectory to start optimization.</li><li><code>a_bound::Float64</code>: The bound for the control variable <code>a</code> (default: <code>1.0</code>).</li><li><code>a_bounds</code>: Bounds for each control variable (default: filled with <code>a_bound</code>).</li><li><code>da_bound::Float64</code>: The bound for the derivative of the control variable (default: <code>Inf</code>).</li><li><code>da_bounds</code>: Bounds for each derivative of the control variable.</li><li><code>dda_bound::Float64</code>: The bound for the second derivative of the control variable (default: <code>1.0</code>).</li><li><code>dda_bounds</code>: Bounds for each second derivative of the control variable.</li><li><code>Δt_min::Float64</code>: Minimum allowed timestep duration.</li><li><code>Δt_max::Float64</code>: Maximum allowed timestep duration.</li><li><code>Q::Float64</code>: Weight for the unitary infidelity objective (default: <code>100.0</code>).</li><li><code>Q_v::Float64</code>: Weight for sensitivity objectives (default: <code>1.0</code>).</li><li><code>R</code>: Regularization weight for control variables (default: <code>1e-2</code>).</li><li><code>R_a</code>, <code>R_da</code>, <code>R_dda</code>: Regularization weights for control, its derivative, and second derivative.</li><li><code>constraints::Vector</code>: Additional constraints for the optimization problem.</li><li><code>piccolo_options::PiccoloOptions</code>: Options for configuring the Piccolo optimization framework.</li></ul><p><strong>Returns</strong></p><p>A <code>DirectTrajOptProblem</code> object representing the optimization problem, including the  trajectory, objective, integrators, and constraints.</p><p><strong>Notes</strong></p><p>This function constructs a trajectory optimization problem for quantum control using  variational principles. It supports robust and sensitive trajectory design, regularization,  and optional constraints. The problem is solved using the Piccolo optimization framework.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/QuantumCollocation.jl/blob/05cca8103b29a38cf6bef6bac564d797cd53ab22/src/problem_templates/unitary_variational_problem.jl#L4-L61">source</a></section></article><p>The <code>UnitaryVariationalProblem</code> uses a <code>VariationalQuantumSystem</code> to find a control that is sensitive or robust to terms in the Hamiltonian. See the documentation for the <code>VariationalQuantumSystem</code> in <a href="https://github.com/harmoniqs/PiccoloQuantumObjects.jl"><code>PiccoloQuantumObjects.jl</code></a> for more details.</p><p><em>create a variational system, with a variational Hamiltonian, <code>PAULIS.X</code></em></p><pre><code class="language-julia hljs">H_var = PAULIS.X
varsys = VariationalQuantumSystem([PAULIS.X, PAULIS.Y], [H_var]);</code></pre><p><em>create a variational problem that is robust to <code>PAULIS.X</code> at the end</em></p><pre><code class="language-julia hljs">robprob = UnitaryVariationalProblem(varsys, U_goal, T, Δt, robust_times=[[T]]);</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">    constructing UnitaryVariationalProblem...
	using integrator: typeof(VariationalUnitaryIntegrator)
	total variational parameters: 1
	robust knot points: [[51]]
	sensitive knot points: [Int64[]]
	control derivative names: [:da, :dda]
	applying timesteps_all_equal constraint: Δt</code></pre><hr/><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../ket_problem_templates/">« Ket Problem Templates</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.13.0 on <span class="colophon-date" title="Sunday 6 July 2025 23:41">Sunday 6 July 2025</span>. Using Julia version 1.10.10.</p></section><footer class="modal-card-foot"></footer></div></div></div></body><div data-docstringscollapsed="true"></div></html>
