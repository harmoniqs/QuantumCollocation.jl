<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Problem Templates · QuantumCollocation.jl</title><meta name="title" content="Problem Templates · QuantumCollocation.jl"/><meta property="og:title" content="Problem Templates · QuantumCollocation.jl"/><meta property="twitter:title" content="Problem Templates · QuantumCollocation.jl"/><meta name="description" content="Documentation for QuantumCollocation.jl."/><meta property="og:description" content="Documentation for QuantumCollocation.jl."/><meta property="twitter:description" content="Documentation for QuantumCollocation.jl."/><meta property="og:url" content="https://docs.harmoniqs.co/QuantumCollocation.jl/generated/man/problem_templates/"/><meta property="twitter:url" content="https://docs.harmoniqs.co/QuantumCollocation.jl/generated/man/problem_templates/"/><link rel="canonical" href="https://docs.harmoniqs.co/QuantumCollocation.jl/generated/man/problem_templates/"/><script data-outdated-warner src="../../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../../assets/documenter.js"></script><script src="../../../search_index.js"></script><script src="../../../siteinfo.js"></script><script src="../../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../../"><img src="../../../assets/logo.svg" alt="QuantumCollocation.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../../">QuantumCollocation.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../../">Home</a></li><li><span class="tocitem">Manual</span><ul><li class="is-active"><a class="tocitem" href>Problem Templates</a><ul class="internal"><li><a class="tocitem" href="#Ket-Problem-Templates"><span>Ket Problem Templates</span></a></li><li><a class="tocitem" href="#Unitary-Problem-Templates"><span>Unitary Problem Templates</span></a></li></ul></li></ul></li><li><a class="tocitem" href="../../../lib/">Library</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>Problem Templates</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Problem Templates</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/harmoniqs/QuantumCollocation.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/harmoniqs/QuantumCollocation.jl/blob/main/docs/literate/man/problem_templates.jl" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><pre><code class="language-julia hljs">using NamedTrajectories
using PiccoloQuantumObjects
using QuantumCollocation</code></pre><h1 id="Problem-Templates"><a class="docs-heading-anchor" href="#Problem-Templates">Problem Templates</a><a id="Problem-Templates-1"></a><a class="docs-heading-anchor-permalink" href="#Problem-Templates" title="Permalink"></a></h1><p>We provide a number of problem templates for making it simple and easy to set up and solve certain types of quantum optimal control problems. These templates all construct a <code>DirectTrajOptProblem</code> object, which stores all the parts of the optimal control problem.</p><p>This page provides a brief overview of each problem template, broken down by the state of the problem being solved.</p><p>Ket Problem Templates:</p><ul><li><a href="#Quantum-State-Smooth-Pulse-Problem">Quantum State Smooth Pulse Problem</a></li><li><a href="#Quantum-State-Minimum-Time-Problem">Quantum State Minimum Time Problem</a></li><li><a href="#Quantum-State-Sampling-Problem">Quantum State Sampling Problem</a></li></ul><p>Unitary Problem Templates:</p><ul><li><a href="#Unitary-Smooth-Pulse-Problem">Unitary Smooth Pulse Problem</a></li><li><a href="#Unitary-Minimum-Time-Problem">Unitary Minimum Time Problem</a></li><li><a href="#Unitary-Sampling-Problem">Unitary Sampling Problem</a></li></ul><hr/><h2 id="Ket-Problem-Templates"><a class="docs-heading-anchor" href="#Ket-Problem-Templates">Ket Problem Templates</a><a id="Ket-Problem-Templates-1"></a><a class="docs-heading-anchor-permalink" href="#Ket-Problem-Templates" title="Permalink"></a></h2><h4 id="Quantum-State-Smooth-Pulse-Problem"><a class="docs-heading-anchor" href="#Quantum-State-Smooth-Pulse-Problem">Quantum State Smooth Pulse Problem</a><a id="Quantum-State-Smooth-Pulse-Problem-1"></a><a class="docs-heading-anchor-permalink" href="#Quantum-State-Smooth-Pulse-Problem" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumCollocation.ProblemTemplates.QuantumStateSmoothPulseProblem-generated-man-problem_templates" href="#QuantumCollocation.ProblemTemplates.QuantumStateSmoothPulseProblem-generated-man-problem_templates"><code>QuantumCollocation.ProblemTemplates.QuantumStateSmoothPulseProblem</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">QuantumStateSmoothPulseProblem(system, ψ_inits, ψ_goals, T, Δt; kwargs...)
QuantumStateSmoothPulseProblem(system, ψ_init, ψ_goal, T, Δt; kwargs...)
QuantumStateSmoothPulseProblem(H_drift, H_drives, args...; kwargs...)</code></pre><p>Create a quantum state smooth pulse problem. The goal is to find a control pulse <code>a(t)</code>  that drives all of the initial states <code>ψ_inits</code> to the corresponding target states  <code>ψ_goals</code> using <code>T</code> timesteps of size <code>Δt</code>. This problem also controls the  first and  second derivatives of the control pulse, <code>da(t)</code> and <code>dda(t)</code>, to ensure smoothness.</p><p><strong>Arguments</strong></p><ul><li><code>system::AbstractQuantumSystem</code>: The quantum system.</li></ul><p>or</p><ul><li><code>H_drift::AbstractMatrix{&lt;:Number}</code>: The drift Hamiltonian.</li><li><code>H_drives::Vector{&lt;:AbstractMatrix{&lt;:Number}}</code>: The control Hamiltonians.</li></ul><p>with</p><ul><li><code>ψ_inits::Vector{&lt;:AbstractVector{&lt;:ComplexF64}}</code>: The initial states.</li><li><code>ψ_goals::Vector{&lt;:AbstractVector{&lt;:ComplexF64}}</code>: The target states.</li></ul><p>or</p><ul><li><code>ψ_init::AbstractVector{&lt;:ComplexF64}</code>: The initial state.</li><li><code>ψ_goal::AbstractVector{&lt;:ComplexF64}</code>: The target state.</li></ul><p>with</p><ul><li><code>T::Int</code>: The number of timesteps.</li><li><code>Δt::Float64</code>: The timestep size.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>state_name::Symbol=:ψ̃</code>: The name of the state variable.</li><li><code>control_name::Symbol=:a</code>: The name of the control variable.</li><li><code>timestep_name::Symbol=:Δt</code>: The name of the timestep variable.</li><li><code>init_trajectory::Union{NamedTrajectory, Nothing}=nothing</code>: The initial trajectory.</li><li><code>a_bound::Float64=1.0</code>: The bound on the control pulse.</li><li><code>a_bounds::Vector{Float64}=fill(a_bound, length(system.G_drives))</code>: The bounds on the control pulse.</li><li><code>a_guess::Union{Matrix{Float64}, Nothing}=nothing</code>: The initial guess for the control pulse.</li><li><code>da_bound::Float64=Inf</code>: The bound on the first derivative of the control pulse.</li><li><code>da_bounds::Vector{Float64}=fill(da_bound, length(system.G_drives))</code>: The bounds on the first derivative of the control pulse.</li><li><code>dda_bound::Float64=1.0</code>: The bound on the second derivative of the control pulse.</li><li><code>dda_bounds::Vector{Float64}=fill(dda_bound, length(system.G_drives))</code>: The bounds on the second derivative of the control pulse.</li><li><code>Δt_min::Float64=0.5 * Δt</code>: The minimum timestep size.</li><li><code>Δt_max::Float64=1.5 * Δt</code>: The maximum timestep size.</li><li><code>drive_derivative_σ::Float64=0.01</code>: The standard deviation of the drive derivative random initialization.</li><li><code>Q::Float64=100.0</code>: The weight on the state objective.</li><li><code>R=1e-2</code>: The weight on the control pulse and its derivatives.</li><li><code>R_a::Union{Float64, Vector{Float64}}=R</code>: The weight on the control pulse.</li><li><code>R_da::Union{Float64, Vector{Float64}}=R</code>: The weight on the first derivative of the control pulse.</li><li><code>R_dda::Union{Float64, Vector{Float64}}=R</code>: The weight on the second derivative of the control pulse.</li><li><code>constraints::Vector{&lt;:AbstractConstraint}=AbstractConstraint[]</code>: The constraints.</li><li><code>piccolo_options::PiccoloOptions=PiccoloOptions()</code>: The Piccolo options.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/QuantumCollocation.jl/blob/2210265cbf104504d2b1452d1d967d267d37ae9b/src/problem_templates/quantum_state_smooth_pulse_problem.jl#L4-L52">source</a></section></article><p>Each problem starts with a <code>QuantumSystem</code> object, which is used to define the system&#39;s Hamiltonian and control operators. The goal is to find a control pulse that drives the intial state, <code>ψ_init</code>, to a target state, <code>ψ_goal</code>.</p><p><em>define the quantum system</em></p><pre><code class="language-julia hljs">system = QuantumSystem(0.1 * PAULIS.Z, [PAULIS.X, PAULIS.Y])
ψ_init = Vector{ComplexF64}([1.0, 0.0])
ψ_goal = Vector{ComplexF64}([0.0, 1.0])
T = 51
Δt = 0.2</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.2</code></pre><p><em>create the smooth pulse problem</em></p><pre><code class="language-julia hljs">state_prob = QuantumStateSmoothPulseProblem(system, ψ_init, ψ_goal, T, Δt);</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">    constructing QuantumStateSmoothPulseProblem...
	using integrator: typeof(KetIntegrator)
	using 1 initial state(s)
	applying timesteps_all_equal constraint: Δt</code></pre><p><em>check the fidelity before solving</em></p><pre><code class="language-julia hljs">println(&quot;Before: &quot;, rollout_fidelity(state_prob.trajectory, system))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Before: 0.2702650322149119</code></pre><p><em>solve the problem</em></p><pre><code class="language-julia hljs">solve!(state_prob, max_iter=100, verbose=true, print_level=1);</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">    initializing optimizer...
        applying constraint: timesteps all equal constraint
        applying constraint: initial value of ψ̃
        applying constraint: initial value of a
        applying constraint: initial value of da
        applying constraint: final value of a
        applying constraint: final value of da
        applying constraint: bounds on a
        applying constraint: bounds on da
        applying constraint: bounds on dda
        applying constraint: bounds on Δt

******************************************************************************
This program contains Ipopt, a library for large-scale nonlinear optimization.
 Ipopt is released as open source code under the Eclipse Public License (EPL).
         For more information visit https://github.com/coin-or/Ipopt
******************************************************************************</code></pre><p><em>check the fidelity after solving</em></p><pre><code class="language-julia hljs">println(&quot;After: &quot;, rollout_fidelity(state_prob.trajectory, system))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">After: 0.9999999999792313</code></pre><p><em>extract the control pulses</em></p><pre><code class="language-julia hljs">state_prob.trajectory.a |&gt; size</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(2, 51)</code></pre><h4 id="Quantum-State-Minimum-Time-Problem"><a class="docs-heading-anchor" href="#Quantum-State-Minimum-Time-Problem">Quantum State Minimum Time Problem</a><a id="Quantum-State-Minimum-Time-Problem-1"></a><a class="docs-heading-anchor-permalink" href="#Quantum-State-Minimum-Time-Problem" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumCollocation.ProblemTemplates.QuantumStateMinimumTimeProblem-generated-man-problem_templates" href="#QuantumCollocation.ProblemTemplates.QuantumStateMinimumTimeProblem-generated-man-problem_templates"><code>QuantumCollocation.ProblemTemplates.QuantumStateMinimumTimeProblem</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">QuantumStateMinimumTimeProblem(traj, sys, obj, integrators, constraints; kwargs...)
QuantumStateMinimumTimeProblem(prob; kwargs...)</code></pre><p>Construct a <code>DirectTrajOptProblem</code> for the minimum time problem of reaching a target state.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>state_name::Symbol=:ψ̃</code>: The symbol for the state variables.</li><li><code>final_fidelity::Union{Real, Nothing}=nothing</code>: The final fidelity.</li><li><code>D=1.0</code>: The cost weight on the time.</li><li><code>piccolo_options::PiccoloOptions=PiccoloOptions()</code>: The Piccolo options.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/QuantumCollocation.jl/blob/2210265cbf104504d2b1452d1d967d267d37ae9b/src/problem_templates/quantum_state_minimum_time_problem.jl#L4-L15">source</a></section></article><p><em>create the minimum time problem</em></p><pre><code class="language-julia hljs">min_state_prob = QuantumStateMinimumTimeProblem(state_prob, ψ_goal);</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">    constructing QuantumStateMinimumTimeProblem...
	final fidelity: 1.0</code></pre><p><em>check the previous duration</em></p><pre><code class="language-julia hljs">println(&quot;Duration before: &quot;, get_duration(state_prob.trajectory))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Duration before: 10.46338258283023</code></pre><p><em>solve the minimum time problem</em></p><pre><code class="language-julia hljs">solve!(min_state_prob, max_iter=100, verbose=true, print_level=1);</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">    initializing optimizer...
        applying constraint: timesteps all equal constraint
        applying constraint: initial value of ψ̃
        applying constraint: initial value of a
        applying constraint: initial value of da
        applying constraint: final value of a
        applying constraint: final value of da
        applying constraint: bounds on a
        applying constraint: bounds on da
        applying constraint: bounds on dda
        applying constraint: bounds on Δt</code></pre><p><em>check the new duration</em></p><pre><code class="language-julia hljs">println(&quot;Duration after: &quot;, get_duration(min_state_prob.trajectory))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Duration after: 3.681381318546689</code></pre><p><em>the fidelity is preserved by a constraint</em></p><pre><code class="language-julia hljs">println(&quot;Fidelity after: &quot;, rollout_fidelity(min_state_prob.trajectory, system))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Fidelity after: 0.999985409162291</code></pre><h4 id="Quantum-State-Sampling-Problem"><a class="docs-heading-anchor" href="#Quantum-State-Sampling-Problem">Quantum State Sampling Problem</a><a id="Quantum-State-Sampling-Problem-1"></a><a class="docs-heading-anchor-permalink" href="#Quantum-State-Sampling-Problem" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumCollocation.ProblemTemplates.QuantumStateSamplingProblem-generated-man-problem_templates" href="#QuantumCollocation.ProblemTemplates.QuantumStateSamplingProblem-generated-man-problem_templates"><code>QuantumCollocation.ProblemTemplates.QuantumStateSamplingProblem</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/QuantumCollocation.jl/blob/2210265cbf104504d2b1452d1d967d267d37ae9b/src/problem_templates/quantum_state_sampling_problem.jl#L3-L5">source</a></section></article><p><em>create a sampling problem</em></p><pre><code class="language-julia hljs">driftless_system = QuantumSystem([PAULIS.X, PAULIS.Y])
sampling_state_prob = QuantumStateSamplingProblem([system, driftless_system], ψ_init, ψ_goal, T, Δt);</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">    constructing QuantumStateSamplingProblem...
	using integrator: typeof(KetIntegrator)
	using 2 initial state(s)
	applying timesteps_all_equal constraint: Δt</code></pre><p><em>new keys are added to the trajectory for the new states</em></p><pre><code class="language-julia hljs">println(sampling_state_prob.trajectory.state_names)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(:ψ̃1_system_1, :a, :da, :ψ̃1_system_2)</code></pre><p><em>solve the sampling problem for a few iterations</em></p><pre><code class="language-julia hljs">solve!(sampling_state_prob, max_iter=25, verbose=true, print_level=1);</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">    initializing optimizer...
        applying constraint: timesteps all equal constraint
        applying constraint: initial value of ψ̃1_system_1
        applying constraint: initial value of a
        applying constraint: initial value of da
        applying constraint: initial value of ψ̃1_system_2
        applying constraint: final value of a
        applying constraint: final value of da
        applying constraint: bounds on a
        applying constraint: bounds on da
        applying constraint: bounds on dda
        applying constraint: bounds on Δt</code></pre><p><em>check the fidelity of the sampling problem (use the updated key to get the initial and goal)</em></p><pre><code class="language-julia hljs">println(&quot;After (original system): &quot;, rollout_fidelity(sampling_state_prob.trajectory, system, state_name=:ψ̃1_system_1))
println(&quot;After (new system): &quot;, rollout_fidelity(sampling_state_prob.trajectory, driftless_system, state_name=:ψ̃1_system_1))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">After (original system): 0.9877387017241955
After (new system): 0.9885756196665351</code></pre><p><em>compare this to using the original problem on the new system</em></p><pre><code class="language-julia hljs">println(&quot;After (new system, original `prob`): &quot;, rollout_fidelity(state_prob.trajectory, driftless_system))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">After (new system, original `prob`): 0.7760663640031801</code></pre><hr/><h2 id="Unitary-Problem-Templates"><a class="docs-heading-anchor" href="#Unitary-Problem-Templates">Unitary Problem Templates</a><a id="Unitary-Problem-Templates-1"></a><a class="docs-heading-anchor-permalink" href="#Unitary-Problem-Templates" title="Permalink"></a></h2><h4 id="Unitary-Smooth-Pulse-Problem"><a class="docs-heading-anchor" href="#Unitary-Smooth-Pulse-Problem">Unitary Smooth Pulse Problem</a><a id="Unitary-Smooth-Pulse-Problem-1"></a><a class="docs-heading-anchor-permalink" href="#Unitary-Smooth-Pulse-Problem" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumCollocation.ProblemTemplates.UnitarySmoothPulseProblem-generated-man-problem_templates" href="#QuantumCollocation.ProblemTemplates.UnitarySmoothPulseProblem-generated-man-problem_templates"><code>QuantumCollocation.ProblemTemplates.UnitarySmoothPulseProblem</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">UnitarySmoothPulseProblem(system::AbstractQuantumSystem, operator, T, Δt; kwargs...)
UnitarySmoothPulseProblem(H_drift, H_drives, operator, T, Δt; kwargs...)</code></pre><p>Construct a <code>DirectTrajOptProblem</code> for a free-time unitary gate problem with smooth control pulses enforced by constraining the second derivative of the pulse trajectory, i.e.,</p><p class="math-container">\[\begin{aligned}
\underset{\vec{\tilde{U}}, a, \dot{a}, \ddot{a}, \Delta t}{\text{minimize}} &amp; \quad
Q \cdot \ell\qty(\vec{\tilde{U}}_T, \vec{\tilde{U}}_{\text{goal}}) + \frac{1}{2} \sum_t \qty(R_a a_t^2 + R_{\dot{a}} \dot{a}_t^2 + R_{\ddot{a}} \ddot{a}_t^2) \\
\text{ subject to } &amp; \quad \vb{P}^{(n)}\qty(\vec{\tilde{U}}_{t+1}, \vec{\tilde{U}}_t, a_t, \Delta t_t) = 0 \\
&amp; \quad a_{t+1} - a_t - \dot{a}_t \Delta t_t = 0 \\
&amp; \quad \dot{a}_{t+1} - \dot{a}_t - \ddot{a}_t \Delta t_t = 0 \\
&amp; \quad |a_t| \leq a_{\text{bound}} \\
&amp; \quad |\ddot{a}_t| \leq \ddot{a}_{\text{bound}} \\
&amp; \quad \Delta t_{\text{min}} \leq \Delta t_t \leq \Delta t_{\text{max}} \\
\end{aligned}\]</p><p>where, for <span>$U \in SU(N)$</span>,</p><p class="math-container">\[\ell\qty(\vec{\tilde{U}}_T, \vec{\tilde{U}}_{\text{goal}}) =
\abs{1 - \frac{1}{N} \abs{ \tr \qty(U_{\text{goal}}, U_T)} }\]</p><p>is the <em>infidelity</em> objective function, <span>$Q$</span> is a weight, <span>$R_a$</span>, <span>$R_{\dot{a}}$</span>, and <span>$R_{\ddot{a}}$</span> are weights on the regularization terms, and <span>$\vb{P}^{(n)}$</span> is the <span>$n$</span>th-order Pade integrator.</p><p><strong>Arguments</strong></p><ul><li><code>system::AbstractQuantumSystem</code>: the system to be controlled</li></ul><p>or</p><ul><li><code>H_drift::AbstractMatrix{&lt;:Number}</code>: the drift hamiltonian</li><li><code>H_drives::Vector{&lt;:AbstractMatrix{&lt;:Number}}</code>: the control hamiltonians</li></ul><p>with</p><ul><li><code>goal::AbstractPiccoloOperator</code>: the target unitary, either in the form of an <code>EmbeddedOperator</code> or a `Matrix{ComplexF64}</li><li><code>T::Int</code>: the number of timesteps</li><li><code>Δt::Float64</code>: the (initial) time step size</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>piccolo_options::PiccoloOptions=PiccoloOptions()</code>: the options for the Piccolo solver</li><li><code>state_name::Symbol = :Ũ⃗</code>: the name of the state</li><li><code>control_name::Symbol = :a</code>: the name of the control</li><li><code>timestep_name::Symbol = :Δt</code>: the name of the timestep</li><li><code>init_trajectory::Union{NamedTrajectory, Nothing}=nothing</code>: an initial trajectory to use</li><li><code>a_guess::Union{Matrix{Float64}, Nothing}=nothing</code>: an initial guess for the control pulses</li><li><code>a_bound::Float64=1.0</code>: the bound on the control pulse</li><li><code>a_bounds::Vector{Float64}=fill(a_bound, length(system.G_drives))</code>: the bounds on the control pulses, one for each drive</li><li><code>da_bound::Float64=Inf</code>: the bound on the control pulse derivative</li><li><code>da_bounds::Vector{Float64}=fill(da_bound, length(system.G_drives))</code>: the bounds on the control pulse derivatives, one for each drive</li><li><code>dda_bound::Float64=1.0</code>: the bound on the control pulse second derivative</li><li><code>dda_bounds::Vector{Float64}=fill(dda_bound, length(system.G_drives))</code>: the bounds on the control pulse second derivatives, one for each drive</li><li><code>Δt_min::Float64=Δt isa Float64 ? 0.5 * Δt : 0.5 * mean(Δt)</code>: the minimum time step size</li><li><code>Δt_max::Float64=Δt isa Float64 ? 1.5 * Δt : 1.5 * mean(Δt)</code>: the maximum time step size</li><li><code>Q::Float64=100.0</code>: the weight on the infidelity objective</li><li><code>R=1e-2</code>: the weight on the regularization terms</li><li><code>R_a::Union{Float64, Vector{Float64}}=R</code>: the weight on the regularization term for the control pulses</li><li><code>R_da::Union{Float64, Vector{Float64}}=R</code>: the weight on the regularization term for the control pulse derivatives</li><li><code>R_dda::Union{Float64, Vector{Float64}}=R</code>: the weight on the regularization term for the control pulse second derivatives</li><li><code>constraints::Vector{&lt;:AbstractConstraint}=AbstractConstraint[]</code>: the constraints to enforce</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/QuantumCollocation.jl/blob/2210265cbf104504d2b1452d1d967d267d37ae9b/src/problem_templates/unitary_smooth_pulse_problem.jl#L4-L65">source</a></section></article><p>The <code>UnitarySmoothPulseProblem</code> is similar to the <code>QuantumStateSmoothPulseProblem</code>, but instead of driving the system to a target state, the goal is to drive the system to a target unitary operator, <code>U_goal</code>.</p><pre><code class="language-julia hljs">system = QuantumSystem(0.1 * PAULIS.Z, [PAULIS.X, PAULIS.Y])
U_goal = GATES.H
T = 51
Δt = 0.2

prob = UnitarySmoothPulseProblem(system, U_goal, T, Δt);</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">    constructing UnitarySmoothPulseProblem...
	using integrator: typeof(UnitaryIntegrator)
	control derivative names: [:da, :dda]
	applying timesteps_all_equal constraint: Δt</code></pre><p><em>check the fidelity before solving</em></p><pre><code class="language-julia hljs">println(&quot;Before: &quot;, unitary_rollout_fidelity(prob.trajectory, system))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Before: 0.22043303242736734</code></pre><p><em>finding an optimal control is as simple as calling <code>solve!</code></em></p><pre><code class="language-julia hljs">solve!(prob, max_iter=100, verbose=true, print_level=1);</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">    initializing optimizer...
        applying constraint: timesteps all equal constraint
        applying constraint: initial value of Ũ⃗
        applying constraint: initial value of a
        applying constraint: initial value of da
        applying constraint: final value of a
        applying constraint: final value of da
        applying constraint: bounds on a
        applying constraint: bounds on da
        applying constraint: bounds on dda
        applying constraint: bounds on Δt</code></pre><p><em>check the fidelity after solving</em></p><pre><code class="language-julia hljs">println(&quot;After: &quot;, unitary_rollout_fidelity(prob.trajectory, system))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">After: 0.9996060497974855</code></pre><p>The <code>NamedTrajectory</code> object stores the control pulse, state variables, and the time grid.</p><p><em>extract the control pulses</em></p><pre><code class="language-julia hljs">prob.trajectory.a |&gt; size</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(2, 51)</code></pre><h4 id="Unitary-Minimum-Time-Problem"><a class="docs-heading-anchor" href="#Unitary-Minimum-Time-Problem">Unitary Minimum Time Problem</a><a id="Unitary-Minimum-Time-Problem-1"></a><a class="docs-heading-anchor-permalink" href="#Unitary-Minimum-Time-Problem" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumCollocation.ProblemTemplates.UnitaryMinimumTimeProblem-generated-man-problem_templates" href="#QuantumCollocation.ProblemTemplates.UnitaryMinimumTimeProblem-generated-man-problem_templates"><code>QuantumCollocation.ProblemTemplates.UnitaryMinimumTimeProblem</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">UnitaryMinimumTimeProblem(
    goal::AbstractPiccoloOperator,
    trajectory::NamedTrajectory,
    objective::Objective,
    dynamics::TrajectoryDynamics,
    constraints::AbstractVector{&lt;:AbstractConstraint};
    kwargs...
)

UnitaryMinimumTimeProblem(
    goal::AbstractPiccoloOperator,
    prob::DirectTrajOptProblem;
    kwargs...
)</code></pre><p>Create a minimum-time problem for unitary control.</p><p class="math-container">\[\begin{aligned}
\underset{\vec{\tilde{U}}, a, \dot{a}, \ddot{a}, \Delta t}{\text{minimize}} &amp; \quad
J(\vec{\tilde{U}}, a, \dot{a}, \ddot{a}) + D \sum_t \Delta t_t \\
\text{ subject to } &amp; \quad \vb{P}^{(n)}\qty(\vec{\tilde{U}}_{t+1}, \vec{\tilde{U}}_t, a_t, \Delta t_t) = 0 \\
&amp; c(\vec{\tilde{U}}, a, \dot{a}, \ddot{a}) = 0 \\
&amp; \quad \Delta t_{\text{min}} \leq \Delta t_t \leq \Delta t_{\text{max}} \\
\end{aligned}\]</p><p><strong>Keyword Arguments</strong></p><ul><li><code>piccolo_options::PiccoloOptions=PiccoloOptions()</code>: The Piccolo options.</li><li><code>unitary_name::Symbol=:Ũ⃗</code>: The name of the unitary for the goal.</li><li><code>final_fidelity::Float64=1.0</code>: The final fidelity constraint.</li><li><code>D::Float64=1.0</code>: The scaling factor for the minimum-time objective.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/QuantumCollocation.jl/blob/2210265cbf104504d2b1452d1d967d267d37ae9b/src/problem_templates/unitary_minimum_time_problem.jl#L4-L37">source</a></section></article><p>The goal of this problem is to find the shortest time it takes to drive the system to a target unitary operator, <code>U_goal</code>. The problem is solved by minimizing the sum of all of the time steps. It is constructed from <code>prob</code> in the previous example.</p><pre><code class="language-julia hljs">min_prob = UnitaryMinimumTimeProblem(prob, U_goal);</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">    constructing UnitaryMinimumTimeProblem...
	final fidelity: 1.0</code></pre><p><em>check the previous duration</em></p><pre><code class="language-julia hljs">println(&quot;Duration before: &quot;, get_duration(prob.trajectory))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Duration before: 8.369711303490133</code></pre><p><em>solve the minimum time problem</em></p><pre><code class="language-julia hljs">solve!(min_prob, max_iter=100, verbose=true, print_level=1);</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">    initializing optimizer...
        applying constraint: timesteps all equal constraint
        applying constraint: initial value of Ũ⃗
        applying constraint: initial value of a
        applying constraint: initial value of da
        applying constraint: final value of a
        applying constraint: final value of da
        applying constraint: bounds on a
        applying constraint: bounds on da
        applying constraint: bounds on dda
        applying constraint: bounds on Δt</code></pre><p><em>check the new duration</em></p><pre><code class="language-julia hljs">println(&quot;Duration after: &quot;, get_duration(min_prob.trajectory))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Duration after: 5.775410534511182</code></pre><p><em>the fidelity is preserved by a constraint</em></p><pre><code class="language-julia hljs">println(&quot;Fidelity after: &quot;, unitary_rollout_fidelity(min_prob.trajectory, system))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Fidelity after: 0.999999996816126</code></pre><h4 id="Unitary-Sampling-Problem"><a class="docs-heading-anchor" href="#Unitary-Sampling-Problem">Unitary Sampling Problem</a><a id="Unitary-Sampling-Problem-1"></a><a class="docs-heading-anchor-permalink" href="#Unitary-Sampling-Problem" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumCollocation.ProblemTemplates.UnitarySamplingProblem-generated-man-problem_templates" href="#QuantumCollocation.ProblemTemplates.UnitarySamplingProblem-generated-man-problem_templates"><code>QuantumCollocation.ProblemTemplates.UnitarySamplingProblem</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">UnitarySamplingProblem(systemns, operator, T, Δt; kwargs...)</code></pre><p>A <code>UnitarySamplingProblem</code> is a quantum control problem where the goal is to find a control pulse that generates a target unitary operator for a set of quantum systems. The controls are shared among all systems, and the optimization seeks to find the control  pulse that achieves the operator for each system. The idea is to enforce a robust solution by including multiple systems reflecting the problem uncertainty.</p><p><strong>Arguments</strong></p><ul><li><code>systems::AbstractVector{&lt;:AbstractQuantumSystem}</code>: A vector of quantum systems.</li><li><code>operators::AbstractVector{&lt;:AbstractPiccoloOperator}</code>: A vector of target operators.</li><li><code>T::Int</code>: The number of time steps.</li><li><code>Δt::Union{Float64, Vector{Float64}}</code>: The time step value or vector of time steps.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>system_labels::Vector{String} = string.(1:length(systems))</code>: The labels for each system.</li><li><code>system_weights::Vector{Float64} = fill(1.0, length(systems))</code>: The weights for each system.</li><li><code>init_trajectory::Union{NamedTrajectory, Nothing} = nothing</code>: The initial trajectory.</li><li><code>state_name::Symbol = :Ũ⃗</code>: The name of the state variable.</li><li><code>control_name::Symbol = :a</code>: The name of the control variable.</li><li><code>timestep_name::Symbol = :Δt</code>: The name of the timestep variable.</li><li><code>constraints::Vector{&lt;:AbstractConstraint} = AbstractConstraint[]</code>: The constraints.</li><li><code>a_bound::Float64 = 1.0</code>: The bound for the control amplitudes.</li><li><code>a_bounds::Vector{Float64} = fill(a_bound, length(systems[1].G_drives))</code>: The bounds for the control amplitudes.</li><li><code>a_guess::Union{Matrix{Float64}, Nothing} = nothing</code>: The initial guess for the control amplitudes.</li><li><code>da_bound::Float64 = Inf</code>: The bound for the control first derivatives.</li><li><code>da_bounds::Vector{Float64} = fill(da_bound, length(systems[1].G_drives))</code>: The bounds for the control first derivatives.</li><li><code>dda_bound::Float64 = 1.0</code>: The bound for the control second derivatives.</li><li><code>dda_bounds::Vector{Float64} = fill(dda_bound, length(systems[1].G_drives))</code>: The bounds for the control second derivatives.</li><li><code>Δt_min::Float64 = 0.5 * Δt</code>: The minimum time step size.</li><li><code>Δt_max::Float64 = 1.5 * Δt</code>: The maximum time step size.</li><li><code>Q::Float64 = 100.0</code>: The fidelity weight.</li><li><code>R::Float64 = 1e-2</code>: The regularization weight.</li><li><code>R_a::Union{Float64, Vector{Float64}} = R</code>: The regularization weight for the control amplitudes.</li><li><code>R_da::Union{Float64, Vector{Float64}} = R</code>: The regularization weight for the control first derivatives.</li><li><code>R_dda::Union{Float64, Vector{Float64}} = R</code>: The regularization weight for the control second derivatives.</li><li><code>piccolo_options::PiccoloOptions = PiccoloOptions()</code>: The Piccolo options.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/QuantumCollocation.jl/blob/2210265cbf104504d2b1452d1d967d267d37ae9b/src/problem_templates/unitary_sampling_problem.jl#L4-L43">source</a></section></article><p>A sampling problem is used to solve over multiple quantum systems with the same control. This can be useful for exploring robustness, for example.</p><p><em>create a sampling problem</em></p><pre><code class="language-julia hljs">driftless_system = QuantumSystem([PAULIS.X, PAULIS.Y])
sampling_prob = UnitarySamplingProblem([system, driftless_system], U_goal, T, Δt);</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">    constructing UnitarySamplingProblem...
	using integrator: typeof(UnitaryIntegrator)
	using 2 systems
	applying timesteps_all_equal constraint: Δt</code></pre><p><em>new keys are addded to the trajectory for the new states</em></p><pre><code class="language-julia hljs">println(sampling_prob.trajectory.state_names)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(:Ũ⃗_system_1, :a, :da, :Ũ⃗_system_2)</code></pre><p><em>the <code>solve!</code> proceeds as in the <a href="#Quantum-State-Sampling-Problem">Quantum State Sampling Problem</a>]</em></p><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../../">« Home</a><a class="docs-footer-nextpage" href="../../../lib/">Library »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.1 on <span class="colophon-date" title="Sunday 16 March 2025 05:48">Sunday 16 March 2025</span>. Using Julia version 1.11.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body><div data-docstringscollapsed="true"></div></html>
