<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Library · QuantumCollocation.jl</title><meta name="title" content="Library · QuantumCollocation.jl"/><meta property="og:title" content="Library · QuantumCollocation.jl"/><meta property="twitter:title" content="Library · QuantumCollocation.jl"/><meta name="description" content="Documentation for QuantumCollocation.jl."/><meta property="og:description" content="Documentation for QuantumCollocation.jl."/><meta property="twitter:description" content="Documentation for QuantumCollocation.jl."/><meta property="og:url" content="https://docs.harmoniqs.co/QuantumCollocation.jl/lib/"/><meta property="twitter:url" content="https://docs.harmoniqs.co/QuantumCollocation.jl/lib/"/><link rel="canonical" href="https://docs.harmoniqs.co/QuantumCollocation.jl/lib/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">QuantumCollocation.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Usage Guide</span><ul><li><a class="tocitem" href="../generated/man/problem_templates_overview/">Problem Templates Overview</a></li><li><a class="tocitem" href="../generated/man/working_with_solutions/">Working with Solutions</a></li><li><a class="tocitem" href="../generated/man/piccolo_options/">PiccoloOptions Reference</a></li></ul></li><li class="is-active"><a class="tocitem" href>Library</a><ul class="internal"><li><a class="tocitem" href="#Problem-Templates"><span>Problem Templates</span></a></li><li><a class="tocitem" href="#Quantum-Objectives"><span>Quantum Objectives</span></a></li><li><a class="tocitem" href="#Quantum-Constraints"><span>Quantum Constraints</span></a></li><li><a class="tocitem" href="#Quantum-Integrators"><span>Quantum Integrators</span></a></li><li><a class="tocitem" href="#Options"><span>Options</span></a></li><li><a class="tocitem" href="#Control-Problems"><span>Control Problems</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Library</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Library</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/harmoniqs/QuantumCollocation.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/harmoniqs/QuantumCollocation.jl/blob/main/docs/src/lib.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Library"><a class="docs-heading-anchor" href="#Library">Library</a><a id="Library-1"></a><a class="docs-heading-anchor-permalink" href="#Library" title="Permalink"></a></h1><h2 id="Problem-Templates"><a class="docs-heading-anchor" href="#Problem-Templates">Problem Templates</a><a id="Problem-Templates-1"></a><a class="docs-heading-anchor-permalink" href="#Problem-Templates" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="QuantumCollocation.ProblemTemplates.MinimumTimeProblem-Union{Tuple{QuantumControlProblem{QT}}, Tuple{QT}} where QT&lt;:PiccoloQuantumObjects.QuantumTrajectories.AbstractQuantumTrajectory"><a class="docstring-binding" href="#QuantumCollocation.ProblemTemplates.MinimumTimeProblem-Union{Tuple{QuantumControlProblem{QT}}, Tuple{QT}} where QT&lt;:PiccoloQuantumObjects.QuantumTrajectories.AbstractQuantumTrajectory"><code>QuantumCollocation.ProblemTemplates.MinimumTimeProblem</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MinimumTimeProblem(qcp::QuantumControlProblem; kwargs...)</code></pre><p>Convert an existing quantum control problem to minimum-time optimization.</p><p><strong>IMPORTANT</strong>: This function requires an existing <code>QuantumControlProblem</code> (e.g., from <code>SmoothPulseProblem</code>). It cannot be created directly from a quantum trajectory. The workflow is:</p><ol><li>Create base problem with <code>SmoothPulseProblem</code> (or similar)</li><li>Solve base problem to get feasible solution</li><li>Convert to minimum-time with <code>MinimumTimeProblem</code></li></ol><p>This ensures the problem starts from a good initialization and maintains solution quality through the final fidelity constraint.</p><p><strong>Type Dispatch</strong></p><p>Automatically handles different quantum trajectory types through the type parameter:</p><ul><li><code>QuantumControlProblem{UnitaryTrajectory}</code> → Uses <code>FinalUnitaryFidelityConstraint</code></li><li><code>QuantumControlProblem{KetTrajectory}</code> → Uses <code>FinalKetFidelityConstraint</code></li><li><code>QuantumControlProblem{DensityTrajectory}</code> → Not yet implemented</li></ul><p>The optimization problem is:</p><p class="math-container">\[\begin{aligned}
\underset{\vec{\tilde{q}}, u, \Delta t}{\text{minimize}} &amp; \quad
J_{\text{original}}(\vec{\tilde{q}}, u) + D \sum_t \Delta t_t \\
\text{ subject to } &amp; \quad \text{original dynamics \&amp; constraints} \\
&amp; F_{\text{final}} \geq F_{\text{threshold}} \\
&amp; \quad \Delta t_{\text{min}} \leq \Delta t_t \leq \Delta t_{\text{max}} \\
\end{aligned}\]</p><p>where q represents the quantum state (unitary, ket, or density matrix).</p><p><strong>Arguments</strong></p><ul><li><code>qcp::QuantumControlProblem</code>: Existing quantum control problem to convert</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>final_fidelity::Float64=0.99</code>: Minimum fidelity constraint at final time</li><li><code>D::Float64=100.0</code>: Weight on minimum-time objective ∑Δt</li><li><code>piccolo_options::PiccoloOptions=PiccoloOptions()</code>: Piccolo solver options</li></ul><p><strong>Returns</strong></p><ul><li><code>QuantumControlProblem</code>: New problem with minimum-time objective and fidelity constraint</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Standard workflow
sys = QuantumSystem(H_drift, H_drives, drive_bounds)
pulse = ZeroOrderPulse(0.1 * randn(n_drives, N), collect(range(0.0, T, length=N)))
qtraj = UnitaryTrajectory(sys, pulse, U_goal)

# Step 1: Create and solve base smooth pulse problem (with Δt_bounds for free time)
qcp_smooth = SmoothPulseProblem(qtraj, N; Q=100.0, R=1e-2, Δt_bounds=(0.01, 0.5))
solve!(qcp_smooth; max_iter=100)

# Step 2: Convert to minimum-time
qcp_mintime = MinimumTimeProblem(qcp_smooth; final_fidelity=0.99, D=100.0)
solve!(qcp_mintime; max_iter=100)

# Compare durations
duration_before = sum(get_timesteps(get_trajectory(qcp_smooth)))
duration_after = sum(get_timesteps(get_trajectory(qcp_mintime)))
@assert duration_after &lt;= duration_before

# Nested transformations also work
qcp_final = MinimumTimeProblem(
    RobustnessProblem(qcp_smooth);  # Future feature
    final_fidelity=0.95
)</code></pre><p><strong>Convenience Constructors</strong></p><p>You can also update the goal when creating minimum-time problem:</p><pre><code class="language-julia hljs"># Different goal for minimum-time optimization
qcp_mintime = MinimumTimeProblem(qcp_smooth; goal=U_goal_new, final_fidelity=0.98)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/QuantumCollocation.jl/blob/6cd0784fe27926af7e8f3e87a2dfc4731a923b83/src/problem_templates/minimum_time_problem.jl#L3-L83">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantumCollocation.ProblemTemplates.SamplingProblem-Tuple{QuantumControlProblem, Vector{&lt;:PiccoloQuantumObjects.QuantumSystems.AbstractQuantumSystem}}"><a class="docstring-binding" href="#QuantumCollocation.ProblemTemplates.SamplingProblem-Tuple{QuantumControlProblem, Vector{&lt;:PiccoloQuantumObjects.QuantumSystems.AbstractQuantumSystem}}"><code>QuantumCollocation.ProblemTemplates.SamplingProblem</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">SamplingProblem(qcp::QuantumControlProblem, systems::Vector{&lt;:AbstractQuantumSystem}; kwargs...)</code></pre><p>Construct a <code>SamplingProblem</code> from an existing <code>QuantumControlProblem</code> and a list of systems.</p><p>This creates a robust optimization problem where the controls are shared across all systems, but each system evolves according to its own dynamics. The objective is the weighted sum of fidelity objectives for each system.</p><p><strong>Arguments</strong></p><ul><li><code>qcp::QuantumControlProblem</code>: The base problem (defines nominal trajectory, objective, etc.)</li><li><code>systems::Vector{&lt;:AbstractQuantumSystem}</code>: List of systems to optimize over</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>weights::Vector{Float64}=fill(1.0, length(systems))</code>: Weights for each system</li><li><code>Q::Float64=100.0</code>: Weight on infidelity objective (explicit, not extracted from base problem)</li><li><code>piccolo_options::PiccoloOptions=PiccoloOptions()</code>: Options for the solver</li></ul><p><strong>Returns</strong></p><ul><li><code>QuantumControlProblem{SamplingTrajectory}</code>: A new problem with the sampling trajectory</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/QuantumCollocation.jl/blob/6cd0784fe27926af7e8f3e87a2dfc4731a923b83/src/problem_templates/sampling_problem.jl#L87-L107">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantumCollocation.ProblemTemplates.SmoothPulseProblem-Tuple{PiccoloQuantumObjects.QuantumTrajectories.AbstractQuantumTrajectory{&lt;:PiccoloQuantumObjects.Pulses.ZeroOrderPulse}, Int64}"><a class="docstring-binding" href="#QuantumCollocation.ProblemTemplates.SmoothPulseProblem-Tuple{PiccoloQuantumObjects.QuantumTrajectories.AbstractQuantumTrajectory{&lt;:PiccoloQuantumObjects.Pulses.ZeroOrderPulse}, Int64}"><code>QuantumCollocation.ProblemTemplates.SmoothPulseProblem</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">SmoothPulseProblem(qtraj::AbstractQuantumTrajectory{&lt;:ZeroOrderPulse}, N::Int; kwargs...)</code></pre><p>Construct a <code>QuantumControlProblem</code> for smooth pulse optimization with piecewise constant controls.</p><p><strong>Note</strong>: This problem template is for <code>ZeroOrderPulse</code> only. For spline-based pulses (<code>LinearSplinePulse</code>, <code>CubicSplinePulse</code>), use <code>SplinePulseProblem</code> instead.</p><p>The problem adds discrete derivative variables (du, ddu) that:</p><ul><li>Regularize control changes between timesteps</li><li>Enforce smoothness via <code>DerivativeIntegrator</code> constraints</li></ul><p><strong>Arguments</strong></p><ul><li><code>qtraj::AbstractQuantumTrajectory{&lt;:ZeroOrderPulse}</code>: Quantum trajectory with piecewise constant pulse</li><li><code>N::Int</code>: Number of timesteps for discretization</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>integrator::Union{Nothing, AbstractIntegrator, Vector{&lt;:AbstractIntegrator}}=nothing</code>: Optional custom integrator(s). If not provided, uses BilinearIntegrator (which does not support global variables). A custom integrator is required when <code>global_names</code> is specified.</li><li><code>global_names::Union{Nothing, Vector{Symbol}}=nothing</code>: Names of global variables to optimize. Requires a custom integrator (e.g., HermitianExponentialIntegrator from Piccolissimo) that supports global variables.</li><li><code>global_bounds::Union{Nothing, Dict{Symbol, Union{Float64, Tuple{Float64, Float64}}}}=nothing</code>: Bounds for global variables. Keys are variable names, values are either a scalar (symmetric bounds ±value) or a tuple (lower, upper).</li><li><code>du_bound::Float64=Inf</code>: Bound on discrete first derivative (controls jump rate)</li><li><code>ddu_bound::Float64=1.0</code>: Bound on discrete second derivative (controls acceleration)</li><li><code>Q::Float64=100.0</code>: Weight on infidelity/objective</li><li><code>R::Float64=1e-2</code>: Weight on regularization terms (u, u̇, ü)</li><li><code>R_u::Union{Float64, Vector{Float64}}=R</code>: Weight on control regularization</li><li><code>R_du::Union{Float64, Vector{Float64}}=R</code>: Weight on first derivative regularization</li><li><code>R_ddu::Union{Float64, Vector{Float64}}=R</code>: Weight on second derivative regularization</li><li><code>constraints::Vector{&lt;:AbstractConstraint}=AbstractConstraint[]</code>: Additional constraints</li><li><code>piccolo_options::PiccoloOptions=PiccoloOptions()</code>: Piccolo solver options</li></ul><p><strong>Returns</strong></p><ul><li><code>QuantumControlProblem</code>: Wrapper containing quantum trajectory and optimization problem</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Unitary gate synthesis with piecewise constant pulse
sys = QuantumSystem(H_drift, H_drives, drive_bounds)
pulse = ZeroOrderPulse(0.1 * randn(n_drives, N), collect(range(0.0, T, length=N)))
qtraj = UnitaryTrajectory(sys, pulse, U_goal)
qcp = SmoothPulseProblem(qtraj, N; Q=100.0, R=1e-2)
solve!(qcp; max_iter=100)

# Quantum state transfer
pulse = ZeroOrderPulse(0.1 * randn(n_drives, N), collect(range(0.0, T, length=N)))
qtraj = KetTrajectory(sys, pulse, ψ_init, ψ_goal)
qcp = SmoothPulseProblem(qtraj, N; Q=50.0, R=1e-3)
solve!(qcp)</code></pre><p>See also: <a href="#QuantumCollocation.ProblemTemplates.SplinePulseProblem-Tuple{PiccoloQuantumObjects.QuantumTrajectories.AbstractQuantumTrajectory{&lt;:PiccoloQuantumObjects.Pulses.AbstractSplinePulse}, Int64}"><code>SplinePulseProblem</code></a> for spline-based pulses.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/QuantumCollocation.jl/blob/6cd0784fe27926af7e8f3e87a2dfc4731a923b83/src/problem_templates/smooth_pulse_problem.jl#L3-L53">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantumCollocation.ProblemTemplates.SmoothPulseProblem-Tuple{PiccoloQuantumObjects.QuantumTrajectories.MultiKetTrajectory{&lt;:PiccoloQuantumObjects.Pulses.ZeroOrderPulse}, Int64}"><a class="docstring-binding" href="#QuantumCollocation.ProblemTemplates.SmoothPulseProblem-Tuple{PiccoloQuantumObjects.QuantumTrajectories.MultiKetTrajectory{&lt;:PiccoloQuantumObjects.Pulses.ZeroOrderPulse}, Int64}"><code>QuantumCollocation.ProblemTemplates.SmoothPulseProblem</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">SmoothPulseProblem(qtraj::MultiKetTrajectory{&lt;:ZeroOrderPulse}, N::Int; kwargs...)</code></pre><p>Construct a <code>QuantumControlProblem</code> for smooth pulse optimization over an ensemble of ket state transfers with piecewise constant controls.</p><p>This handles the case where you want to optimize a single pulse that achieves multiple  state transfers simultaneously (e.g., |0⟩→|1⟩ and |1⟩→|0⟩ for an X gate via state transfer).</p><p><strong>Note</strong>: This problem template is for <code>ZeroOrderPulse</code> only. For spline-based pulses, use <code>SplinePulseProblem</code> instead.</p><p><strong>Arguments</strong></p><ul><li><code>qtraj::MultiKetTrajectory{&lt;:ZeroOrderPulse}</code>: Ensemble of ket state transfers with piecewise constant pulse</li><li><code>N::Int</code>: Number of timesteps for the discretization</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>integrator::Union{Nothing, AbstractIntegrator, Vector{&lt;:AbstractIntegrator}}=nothing</code>: Optional custom integrator(s). If not provided, the default <code>BilinearIntegrator</code> is used. When <code>global_names</code> is specified, you must supply a custom integrator here (i.e., do not rely on the default <code>BilinearIntegrator</code>) that supports global variables.</li><li><code>global_names::Union{Nothing, Vector{Symbol}}=nothing</code>: Names of global variables to optimize. Requires a custom integrator provided via <code>integrator</code> (e.g., <code>HermitianExponentialIntegrator</code> from Piccolissimo) that supports global variables.</li><li><code>global_bounds::Union{Nothing, Dict{Symbol, Union{Float64, Tuple{Float64, Float64}}}}=nothing</code>: Bounds for global variables. Keys are variable names, values are either a scalar (symmetric bounds ±value) or a tuple (lower, upper).</li><li><code>du_bound::Float64=Inf</code>: Bound on discrete first derivative</li><li><code>ddu_bound::Float64=1.0</code>: Bound on discrete second derivative</li><li><code>Q::Float64=100.0</code>: Weight on infidelity/objective</li><li><code>R::Float64=1e-2</code>: Weight on regularization terms (u, u̇, ü)</li><li><code>R_u::Union{Float64, Vector{Float64}}=R</code>: Weight on control regularization</li><li><code>R_du::Union{Float64, Vector{Float64}}=R</code>: Weight on first derivative regularization</li><li><code>R_ddu::Union{Float64, Vector{Float64}}=R</code>: Weight on second derivative regularization</li><li><code>constraints::Vector{&lt;:AbstractConstraint}=AbstractConstraint[]</code>: Additional constraints</li><li><code>piccolo_options::PiccoloOptions=PiccoloOptions()</code>: Piccolo solver options</li></ul><p><strong>Returns</strong></p><ul><li><code>QuantumControlProblem{MultiKetTrajectory}</code>: Wrapper containing ensemble trajectory and optimization problem</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Create ensemble for X gate via state transfer
sys = QuantumSystem(H_drift, H_drives, drive_bounds)
pulse = ZeroOrderPulse(0.1 * randn(n_drives, N), collect(range(0.0, T, length=N)))

ψ0 = ComplexF64[1.0, 0.0]
ψ1 = ComplexF64[0.0, 1.0]

ensemble_qtraj = MultiKetTrajectory(sys, pulse, [ψ0, ψ1], [ψ1, ψ0])
qcp = SmoothPulseProblem(ensemble_qtraj, N; Q=100.0, R=1e-2)
solve!(qcp; max_iter=100)</code></pre><p>See also: <a href="#QuantumCollocation.ProblemTemplates.SplinePulseProblem-Tuple{PiccoloQuantumObjects.QuantumTrajectories.AbstractQuantumTrajectory{&lt;:PiccoloQuantumObjects.Pulses.AbstractSplinePulse}, Int64}"><code>SplinePulseProblem</code></a> for spline-based pulses.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/QuantumCollocation.jl/blob/6cd0784fe27926af7e8f3e87a2dfc4731a923b83/src/problem_templates/smooth_pulse_problem.jl#L174-L222">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantumCollocation.ProblemTemplates.SmoothPulseProblem-Union{Tuple{P}, Tuple{PiccoloQuantumObjects.QuantumTrajectories.AbstractQuantumTrajectory{P}, Int64}} where P&lt;:PiccoloQuantumObjects.Pulses.AbstractPulse"><a class="docstring-binding" href="#QuantumCollocation.ProblemTemplates.SmoothPulseProblem-Union{Tuple{P}, Tuple{PiccoloQuantumObjects.QuantumTrajectories.AbstractQuantumTrajectory{P}, Int64}} where P&lt;:PiccoloQuantumObjects.Pulses.AbstractPulse"><code>QuantumCollocation.ProblemTemplates.SmoothPulseProblem</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">SmoothPulseProblem(qtraj::AbstractQuantumTrajectory, N::Int; kwargs...)</code></pre><p>Fallback method that provides helpful error for non-ZeroOrderPulse types.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/QuantumCollocation.jl/blob/6cd0784fe27926af7e8f3e87a2dfc4731a923b83/src/problem_templates/smooth_pulse_problem.jl#L449-L453">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantumCollocation.ProblemTemplates.SplinePulseProblem-Tuple{PiccoloQuantumObjects.QuantumTrajectories.AbstractQuantumTrajectory{&lt;:PiccoloQuantumObjects.Pulses.AbstractSplinePulse}, Int64}"><a class="docstring-binding" href="#QuantumCollocation.ProblemTemplates.SplinePulseProblem-Tuple{PiccoloQuantumObjects.QuantumTrajectories.AbstractQuantumTrajectory{&lt;:PiccoloQuantumObjects.Pulses.AbstractSplinePulse}, Int64}"><code>QuantumCollocation.ProblemTemplates.SplinePulseProblem</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">SplinePulseProblem(qtraj::AbstractQuantumTrajectory{&lt;:AbstractSplinePulse}, N::Int; kwargs...)</code></pre><p>Construct a <code>QuantumControlProblem</code> for spline-based pulse optimization.</p><p>Unlike <code>SmoothPulseProblem</code> (which uses piecewise constant controls with discrete smoothing  variables), this problem template is designed for spline-based pulses where the derivative  variables (<code>du</code>) are the actual spline coefficients or slopes.</p><p><strong>Pulse Type Semantics</strong></p><p><strong>LinearSplinePulse</strong>: The <code>du</code> variable represents the slope between knots. A <code>DerivativeIntegrator</code> constraint enforces <code>du[k] = (u[k+1] - u[k]) / Δt</code>, making the slopes consistent with the linear interpolation. This constraint ensures mathematical rigor while allowing slope regularization/bounds.</p><p><strong>CubicSplinePulse</strong> (Hermite spline): The <code>du</code> variable is the tangent/derivative at each  knot point, which is a true independent degree of freedom in Hermite interpolation. No  <code>DerivativeIntegrator</code> is added - the optimizer can adjust both <code>:u</code> and <code>:du</code> independently.</p><p><strong>Mathematical Notes</strong></p><ul><li><strong>LinearSplinePulse</strong>: Always adds <code>:du</code> and <code>DerivativeIntegrator</code> to enforce slope consistency</li><li><strong>CubicSplinePulse</strong>: <code>:du</code> values are Hermite tangents (unconstrained, only regularized)</li></ul><p>Both pulse types always have <code>:du</code> components in the trajectory, simplifying integrator implementations.</p><p><strong>Arguments</strong></p><ul><li><code>qtraj::AbstractQuantumTrajectory{&lt;:AbstractSplinePulse}</code>: Quantum trajectory with spline pulse</li><li><code>N::Int</code>: Number of timesteps for the discretization</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>integrator::Union{Nothing, AbstractIntegrator, Vector{&lt;:AbstractIntegrator}}=nothing</code>: Optional custom integrator(s). If not provided, uses <code>BilinearIntegrator</code> (which does not support global variables). A custom integrator is required when <code>global_names</code> is specified.</li><li><code>global_names::Union{Nothing, Vector{Symbol}}=nothing</code>: Names of global variables to optimize. Requires a custom integrator (e.g., <code>SplineIntegrator</code> from Piccolissimo) that supports global variables.</li><li><code>global_bounds::Union{Nothing, Dict{Symbol, Union{Float64, Tuple{Float64, Float64}}}}=nothing</code>: Bounds for global variables. Keys are variable names, values are either a scalar (symmetric bounds ±value) or a tuple (lower, upper).</li><li><code>du_bound::Float64=Inf</code>: Bound on derivative (slope) magnitude</li><li><code>Q::Float64=100.0</code>: Weight on infidelity/objective</li><li><code>R::Float64=1e-2</code>: Weight on regularization terms</li><li><code>R_u::Union{Float64, Vector{Float64}}=R</code>: Weight on control regularization</li><li><code>R_du::Union{Float64, Vector{Float64}}=R</code>: Weight on derivative regularization  </li><li><code>constraints::Vector{&lt;:AbstractConstraint}=AbstractConstraint[]</code>: Additional constraints</li><li><code>piccolo_options::PiccoloOptions=PiccoloOptions()</code>: Piccolo solver options</li></ul><p><strong>Returns</strong></p><ul><li><code>QuantumControlProblem{&lt;:AbstractQuantumTrajectory}</code>: Wrapper containing trajectory and optimization problem</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Linear spline pulse
sys = QuantumSystem(H_drift, H_drives, drive_bounds)
pulse = LinearSplinePulse(0.1 * randn(n_drives, N), collect(range(0.0, T, length=N)))
qtraj = UnitaryTrajectory(sys, pulse, U_goal)

qcp = SplinePulseProblem(qtraj, N; Q=100.0, R=1e-2, du_bound=10.0)
solve!(qcp; max_iter=100)</code></pre><p>See also: <a href="#QuantumCollocation.ProblemTemplates.SmoothPulseProblem-Tuple{PiccoloQuantumObjects.QuantumTrajectories.AbstractQuantumTrajectory{&lt;:PiccoloQuantumObjects.Pulses.ZeroOrderPulse}, Int64}"><code>SmoothPulseProblem</code></a> for piecewise constant pulses with discrete smoothing.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/QuantumCollocation.jl/blob/6cd0784fe27926af7e8f3e87a2dfc4731a923b83/src/problem_templates/spline_pulse_problem.jl#L7-L64">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantumCollocation.ProblemTemplates.SplinePulseProblem-Tuple{PiccoloQuantumObjects.QuantumTrajectories.MultiKetTrajectory{&lt;:PiccoloQuantumObjects.Pulses.AbstractSplinePulse}, Int64}"><a class="docstring-binding" href="#QuantumCollocation.ProblemTemplates.SplinePulseProblem-Tuple{PiccoloQuantumObjects.QuantumTrajectories.MultiKetTrajectory{&lt;:PiccoloQuantumObjects.Pulses.AbstractSplinePulse}, Int64}"><code>QuantumCollocation.ProblemTemplates.SplinePulseProblem</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">SplinePulseProblem(qtraj::MultiKetTrajectory{&lt;:AbstractSplinePulse}, N; kwargs...)</code></pre><p>Create a spline-based trajectory optimization problem for ensemble ket state transfers.</p><p>Uses coherent fidelity objective (phases must align) for gate implementation.</p><p><strong>Arguments</strong></p><ul><li><code>qtraj::MultiKetTrajectory{&lt;:AbstractSplinePulse}</code>: Ensemble trajectory with spline pulse</li><li><code>N::Int</code>: Number of timesteps</li></ul><p><strong>Keyword Arguments</strong></p><p>Same as the base <code>SplinePulseProblem</code> method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/QuantumCollocation.jl/blob/6cd0784fe27926af7e8f3e87a2dfc4731a923b83/src/problem_templates/spline_pulse_problem.jl#L203-L216">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantumCollocation.ProblemTemplates.SplinePulseProblem-Union{Tuple{P}, Tuple{PiccoloQuantumObjects.QuantumTrajectories.AbstractQuantumTrajectory{P}, Int64}} where P&lt;:PiccoloQuantumObjects.Pulses.AbstractPulse"><a class="docstring-binding" href="#QuantumCollocation.ProblemTemplates.SplinePulseProblem-Union{Tuple{P}, Tuple{PiccoloQuantumObjects.QuantumTrajectories.AbstractQuantumTrajectory{P}, Int64}} where P&lt;:PiccoloQuantumObjects.Pulses.AbstractPulse"><code>QuantumCollocation.ProblemTemplates.SplinePulseProblem</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">SplinePulseProblem(qtraj::AbstractQuantumTrajectory, N::Int; kwargs...)</code></pre><p>Fallback method that provides helpful error for non-spline pulse types.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/QuantumCollocation.jl/blob/6cd0784fe27926af7e8f3e87a2dfc4731a923b83/src/problem_templates/spline_pulse_problem.jl#L369-L373">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantumCollocation.ProblemTemplates._ensemble_ket_objective-Tuple{PiccoloQuantumObjects.QuantumTrajectories.MultiKetTrajectory, NamedTrajectories.StructNamedTrajectory.NamedTrajectory, Vector{Symbol}, Vector{Float64}, Vector, Float64}"><a class="docstring-binding" href="#QuantumCollocation.ProblemTemplates._ensemble_ket_objective-Tuple{PiccoloQuantumObjects.QuantumTrajectories.MultiKetTrajectory, NamedTrajectories.StructNamedTrajectory.NamedTrajectory, Vector{Symbol}, Vector{Float64}, Vector, Float64}"><code>QuantumCollocation.ProblemTemplates._ensemble_ket_objective</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_ensemble_ket_objective(qtraj::MultiKetTrajectory, traj, state_names, weights, goals, Q)</code></pre><p>Create a coherent fidelity objective for ensemble state transfers.</p><p>For ensemble trajectories (implementing a gate via multiple state transfers), we use coherent fidelity:     F<em>coherent = |1/n ∑ᵢ ⟨ψᵢ</em>goal|ψᵢ⟩|²</p><p>This requires all state overlaps to have aligned phases, which is essential for gate implementation (the gate should have a single global phase).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/QuantumCollocation.jl/blob/6cd0784fe27926af7e8f3e87a2dfc4731a923b83/src/problem_templates/smooth_pulse_problem.jl#L403-L414">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantumCollocation.ProblemTemplates._final_fidelity_constraint-Tuple{PiccoloQuantumObjects.QuantumTrajectories.MultiKetTrajectory, Float64, NamedTrajectories.StructNamedTrajectory.NamedTrajectory}"><a class="docstring-binding" href="#QuantumCollocation.ProblemTemplates._final_fidelity_constraint-Tuple{PiccoloQuantumObjects.QuantumTrajectories.MultiKetTrajectory, Float64, NamedTrajectories.StructNamedTrajectory.NamedTrajectory}"><code>QuantumCollocation.ProblemTemplates._final_fidelity_constraint</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_final_fidelity_constraint(qtraj::MultiKetTrajectory, final_fidelity, traj)</code></pre><p>Create a coherent fidelity constraint for an MultiKetTrajectory.</p><p>Uses coherent fidelity: F = |1/n ∑ᵢ ⟨ψᵢ_goal|ψᵢ⟩|²</p><p>This enforces that all state transfers have aligned global phases, which is  essential when implementing a gate via state transfer (e.g., X gate via  |0⟩→|1⟩ and |1⟩→|0⟩).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/QuantumCollocation.jl/blob/6cd0784fe27926af7e8f3e87a2dfc4731a923b83/src/problem_templates/minimum_time_problem.jl#L207-L217">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantumCollocation.ProblemTemplates.add_global_bounds_constraints!-Tuple{AbstractVector{&lt;:DirectTrajOpt.Constraints.AbstractConstraint}, Any, NamedTrajectories.StructNamedTrajectory.NamedTrajectory}"><a class="docstring-binding" href="#QuantumCollocation.ProblemTemplates.add_global_bounds_constraints!-Tuple{AbstractVector{&lt;:DirectTrajOpt.Constraints.AbstractConstraint}, Any, NamedTrajectories.StructNamedTrajectory.NamedTrajectory}"><code>QuantumCollocation.ProblemTemplates.add_global_bounds_constraints!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">add_global_bounds_constraints!(constraints, global_bounds, traj; verbose=false)</code></pre><p>Add GlobalBoundsConstraint entries for each global variable specified in <code>global_bounds</code>.</p><p>Converts bounds from user-friendly formats to the format expected by GlobalBoundsConstraint:</p><ul><li><code>Float64</code>: Symmetric scalar bounds (applied symmetrically to all dimensions)</li><li><code>Tuple{Float64, Float64}</code>: Asymmetric scalar bounds (expanded to vectors)</li><li><code>Vector</code> or <code>Tuple{Vector, Vector}</code>: Already in correct format (passed through)</li></ul><p>Modifies <code>constraints</code> in place.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/QuantumCollocation.jl/blob/6cd0784fe27926af7e8f3e87a2dfc4731a923b83/src/problem_templates/_problem_templates.jl#L85-L96">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantumCollocation.ProblemTemplates.extract_regularization-Tuple{Any, Symbol, NamedTrajectories.StructNamedTrajectory.NamedTrajectory}"><a class="docstring-binding" href="#QuantumCollocation.ProblemTemplates.extract_regularization-Tuple{Any, Symbol, NamedTrajectories.StructNamedTrajectory.NamedTrajectory}"><code>QuantumCollocation.ProblemTemplates.extract_regularization</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">extract_regularization(objective, state_sym::Symbol, new_traj::NamedTrajectory) -&gt; AbstractObjective</code></pre><p>Extract regularization terms (non-state-dependent objectives) from a composite objective, filtering to only include terms for variables that exist in the new trajectory.</p><p>Used by <code>SamplingProblem</code> to extract shared regularizers (e.g., control penalty) from the base problem while excluding regularizers for variables that don&#39;t exist in the sampling trajectory (e.g., <code>:du</code>, <code>:ddu</code> which are added by <code>SmoothPulseProblem</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/QuantumCollocation.jl/blob/6cd0784fe27926af7e8f3e87a2dfc4731a923b83/src/problem_templates/sampling_problem.jl#L9-L18">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantumCollocation.ProblemTemplates.sampling_state_objective-Tuple{PiccoloQuantumObjects.QuantumTrajectories.UnitaryTrajectory, NamedTrajectories.StructNamedTrajectory.NamedTrajectory, Symbol, Float64}"><a class="docstring-binding" href="#QuantumCollocation.ProblemTemplates.sampling_state_objective-Tuple{PiccoloQuantumObjects.QuantumTrajectories.UnitaryTrajectory, NamedTrajectories.StructNamedTrajectory.NamedTrajectory, Symbol, Float64}"><code>QuantumCollocation.ProblemTemplates.sampling_state_objective</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">sampling_state_objective(qtraj, traj, state_sym, Q)</code></pre><p>Create the state-dependent objective for a sampling member. Dispatches on quantum trajectory type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/QuantumCollocation.jl/blob/6cd0784fe27926af7e8f3e87a2dfc4731a923b83/src/problem_templates/sampling_problem.jl#L47-L52">source</a></section></details></article><h2 id="Quantum-Objectives"><a class="docs-heading-anchor" href="#Quantum-Objectives">Quantum Objectives</a><a id="Quantum-Objectives-1"></a><a class="docs-heading-anchor-permalink" href="#Quantum-Objectives" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="QuantumCollocation.QuantumObjectives.CoherentKetInfidelityObjective-Tuple{Vector{&lt;:AbstractVector{&lt;:Complex}}, Vector{Symbol}, NamedTrajectories.StructNamedTrajectory.NamedTrajectory}"><a class="docstring-binding" href="#QuantumCollocation.QuantumObjectives.CoherentKetInfidelityObjective-Tuple{Vector{&lt;:AbstractVector{&lt;:Complex}}, Vector{Symbol}, NamedTrajectories.StructNamedTrajectory.NamedTrajectory}"><code>QuantumCollocation.QuantumObjectives.CoherentKetInfidelityObjective</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">CoherentKetInfidelityObjective(ψ_goals, ψ̃_names, traj; Q=100.0)</code></pre><p>Create a terminal objective for coherent ket state infidelity across multiple states.</p><p>Coherent fidelity is defined as:     F<em>coherent = |1/n ∑ᵢ ⟨ψᵢ</em>goal|ψᵢ⟩|²</p><p>Unlike incoherent fidelity (average of individual |⟨ψᵢ_goal|ψᵢ⟩|²), coherent fidelity  requires all state overlaps to have aligned phases. This is essential when implementing a gate via multiple state transfers - the gate should have a single global phase, not independent phases per state.</p><p><strong>Arguments</strong></p><ul><li><code>ψ_goals::Vector{&lt;:AbstractVector{&lt;:Complex}}</code>: Target ket states</li><li><code>ψ̃_names::Vector{Symbol}</code>: Names of isomorphic state variables in trajectory</li><li><code>traj::NamedTrajectory</code>: The trajectory</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>Q::Float64=100.0</code>: Weight on the infidelity objective</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs"># For implementing X gate via |0⟩→|1⟩ and |1⟩→|0⟩
goals = [ComplexF64[0, 1], ComplexF64[1, 0]]
names = [:ψ̃1, :ψ̃2]
obj = CoherentKetInfidelityObjective(goals, names, traj; Q=100.0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/QuantumCollocation.jl/blob/6cd0784fe27926af7e8f3e87a2dfc4731a923b83/src/quantum_objectives.jl#L105-L133">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantumCollocation.QuantumObjectives.KetInfidelityObjective-Tuple{AbstractVector{&lt;:Complex}, Symbol, NamedTrajectories.StructNamedTrajectory.NamedTrajectory}"><a class="docstring-binding" href="#QuantumCollocation.QuantumObjectives.KetInfidelityObjective-Tuple{AbstractVector{&lt;:Complex}, Symbol, NamedTrajectories.StructNamedTrajectory.NamedTrajectory}"><code>QuantumCollocation.QuantumObjectives.KetInfidelityObjective</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">KetInfidelityObjective(ψ_goal, ψ̃_name, traj; Q=100.0)</code></pre><p>Create a terminal objective for ket state infidelity with an explicit goal state.</p><p>This variant is useful for SamplingProblem and EnsembleTrajectory where the goal is shared across multiple state variables that don&#39;t have individual goals in <code>traj.goal</code>.</p><p><strong>Arguments</strong></p><ul><li><code>ψ_goal::AbstractVector{&lt;:Complex}</code>: The target ket state (complex vector)</li><li><code>ψ̃_name::Symbol</code>: Name of the isomorphic state variable in the trajectory</li><li><code>traj::NamedTrajectory</code>: The trajectory</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>Q::Float64=100.0</code>: Weight on the infidelity objective</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/QuantumCollocation.jl/blob/6cd0784fe27926af7e8f3e87a2dfc4731a923b83/src/quantum_objectives.jl#L44-L59">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantumCollocation.QuantumObjectives.KetInfidelityObjective-Tuple{Symbol, NamedTrajectories.StructNamedTrajectory.NamedTrajectory}"><a class="docstring-binding" href="#QuantumCollocation.QuantumObjectives.KetInfidelityObjective-Tuple{Symbol, NamedTrajectories.StructNamedTrajectory.NamedTrajectory}"><code>QuantumCollocation.QuantumObjectives.KetInfidelityObjective</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">KetInfidelityObjective(ψ̃_name, traj; Q=100.0)</code></pre><p>Create a terminal objective for ket state infidelity, using the goal from <code>traj.goal[ψ̃_name]</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/QuantumCollocation.jl/blob/6cd0784fe27926af7e8f3e87a2dfc4731a923b83/src/quantum_objectives.jl#L29-L33">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantumCollocation.QuantumObjectives.LeakageObjective-Tuple{AbstractVector{Int64}, Symbol, NamedTrajectories.StructNamedTrajectory.NamedTrajectory}"><a class="docstring-binding" href="#QuantumCollocation.QuantumObjectives.LeakageObjective-Tuple{AbstractVector{Int64}, Symbol, NamedTrajectories.StructNamedTrajectory.NamedTrajectory}"><code>QuantumCollocation.QuantumObjectives.LeakageObjective</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">LeakageObjective(indices, name, traj::NamedTrajectory)</code></pre><p>Construct a <code>KnotPointObjective</code> that penalizes leakage of <code>name</code> at the knot points specified by <code>times</code> at any <code>indices</code> that are outside the computational subspace.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/QuantumCollocation.jl/blob/6cd0784fe27926af7e8f3e87a2dfc4731a923b83/src/quantum_objectives.jl#L285-L290">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantumCollocation.QuantumObjectives.coherent_ket_fidelity-Tuple{Any, Vector{&lt;:AbstractVector{&lt;:ComplexF64}}}"><a class="docstring-binding" href="#QuantumCollocation.QuantumObjectives.coherent_ket_fidelity-Tuple{Any, Vector{&lt;:AbstractVector{&lt;:ComplexF64}}}"><code>QuantumCollocation.QuantumObjectives.coherent_ket_fidelity</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">coherent_ket_fidelity(ψ̃s, ψ_goals)</code></pre><p>Compute coherent fidelity across multiple ket states:</p><pre><code class="language-julia hljs">F_coherent = |1/n ∑ᵢ ⟨ψᵢ_goal|ψᵢ⟩|²</code></pre><p>This requires all overlaps to have consistent phases (global phase alignment), which is necessary for implementing gates via state transfer.</p><p><strong>Arguments</strong></p><ul><li><code>ψ̃s::Vector{&lt;:AbstractVector}</code>: List of isomorphic state vectors</li><li><code>ψ_goals::Vector{&lt;:AbstractVector{&lt;:Complex}}</code>: List of goal states</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/QuantumCollocation.jl/blob/6cd0784fe27926af7e8f3e87a2dfc4731a923b83/src/quantum_objectives.jl#L74-L87">source</a></section></details></article><h2 id="Quantum-Constraints"><a class="docs-heading-anchor" href="#Quantum-Constraints">Quantum Constraints</a><a id="Quantum-Constraints-1"></a><a class="docs-heading-anchor-permalink" href="#Quantum-Constraints" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="QuantumCollocation.QuantumConstraints.FinalCoherentKetFidelityConstraint-Tuple{Vector{&lt;:AbstractVector{&lt;:Complex}}, Vector{Symbol}, Float64, NamedTrajectories.StructNamedTrajectory.NamedTrajectory}"><a class="docstring-binding" href="#QuantumCollocation.QuantumConstraints.FinalCoherentKetFidelityConstraint-Tuple{Vector{&lt;:AbstractVector{&lt;:Complex}}, Vector{Symbol}, Float64, NamedTrajectories.StructNamedTrajectory.NamedTrajectory}"><code>QuantumCollocation.QuantumConstraints.FinalCoherentKetFidelityConstraint</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">FinalCoherentKetFidelityConstraint(ψ_goals, ψ̃_names, final_fidelity, traj)</code></pre><p>Create a final fidelity constraint using coherent ket fidelity across multiple states.</p><p>Coherent fidelity: F = |1/n ∑ᵢ ⟨ψᵢ_goal|ψᵢ⟩|²</p><p>This constraint enforces that all state overlaps have aligned phases, which is  essential when implementing a gate via multiple state transfers (e.g., MultiKetTrajectory).</p><p><strong>Arguments</strong></p><ul><li><code>ψ_goals::Vector{&lt;:AbstractVector{&lt;:Complex}}</code>: Target ket states</li><li><code>ψ̃_names::Vector{Symbol}</code>: Names of isomorphic state variables in trajectory</li><li><code>final_fidelity::Float64</code>: Minimum fidelity threshold (constraint: F ≥ final_fidelity)</li><li><code>traj::NamedTrajectory</code>: The trajectory</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs"># For implementing X gate via |0⟩→|1⟩ and |1⟩→|0⟩
goals = [ComplexF64[0, 1], ComplexF64[1, 0]]
names = [:ψ̃1, :ψ̃2]
constraint = FinalCoherentKetFidelityConstraint(goals, names, 0.99, traj)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/QuantumCollocation.jl/blob/6cd0784fe27926af7e8f3e87a2dfc4731a923b83/src/quantum_constraints.jl#L41-L64">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantumCollocation.QuantumConstraints.LeakageConstraint-Tuple{Float64, AbstractVector{Int64}, Symbol, NamedTrajectories.StructNamedTrajectory.NamedTrajectory}"><a class="docstring-binding" href="#QuantumCollocation.QuantumConstraints.LeakageConstraint-Tuple{Float64, AbstractVector{Int64}, Symbol, NamedTrajectories.StructNamedTrajectory.NamedTrajectory}"><code>QuantumCollocation.QuantumConstraints.LeakageConstraint</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">LeakageConstraint(value, indices, name, traj::NamedTrajectory)</code></pre><p>Construct a <code>KnotPointConstraint</code> that bounds leakage of <code>name</code> at the knot points specified by <code>times</code> at any <code>indices</code> that are outside the computational subspace.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/QuantumCollocation.jl/blob/6cd0784fe27926af7e8f3e87a2dfc4731a923b83/src/quantum_constraints.jl#L150-L155">source</a></section></details></article><h2 id="Quantum-Integrators"><a class="docs-heading-anchor" href="#Quantum-Integrators">Quantum Integrators</a><a id="Quantum-Integrators-1"></a><a class="docs-heading-anchor-permalink" href="#Quantum-Integrators" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="DirectTrajOpt.Integrators.BilinearIntegrator-Tuple{PiccoloQuantumObjects.QuantumTrajectories.DensityTrajectory, Int64}"><a class="docstring-binding" href="#DirectTrajOpt.Integrators.BilinearIntegrator-Tuple{PiccoloQuantumObjects.QuantumTrajectories.DensityTrajectory, Int64}"><code>DirectTrajOpt.Integrators.BilinearIntegrator</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">BilinearIntegrator(qtraj::DensityTrajectory, N::Int)</code></pre><p>Create a BilinearIntegrator for density matrix evolution.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/QuantumCollocation.jl/blob/6cd0784fe27926af7e8f3e87a2dfc4731a923b83/src/quantum_integrators.jl#L47-L51">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DirectTrajOpt.Integrators.BilinearIntegrator-Tuple{PiccoloQuantumObjects.QuantumTrajectories.KetTrajectory, Int64}"><a class="docstring-binding" href="#DirectTrajOpt.Integrators.BilinearIntegrator-Tuple{PiccoloQuantumObjects.QuantumTrajectories.KetTrajectory, Int64}"><code>DirectTrajOpt.Integrators.BilinearIntegrator</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">BilinearIntegrator(qtraj::KetTrajectory, N::Int)</code></pre><p>Create a BilinearIntegrator for ket evolution.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/QuantumCollocation.jl/blob/6cd0784fe27926af7e8f3e87a2dfc4731a923b83/src/quantum_integrators.jl#L35-L39">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DirectTrajOpt.Integrators.BilinearIntegrator-Tuple{PiccoloQuantumObjects.QuantumTrajectories.MultiKetTrajectory, Int64}"><a class="docstring-binding" href="#DirectTrajOpt.Integrators.BilinearIntegrator-Tuple{PiccoloQuantumObjects.QuantumTrajectories.MultiKetTrajectory, Int64}"><code>DirectTrajOpt.Integrators.BilinearIntegrator</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">BilinearIntegrator(qtraj::MultiKetTrajectory, N::Int)</code></pre><p>Create a vector of BilinearIntegrators for each ket in an MultiKetTrajectory.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/QuantumCollocation.jl/blob/6cd0784fe27926af7e8f3e87a2dfc4731a923b83/src/quantum_integrators.jl#L58-L62">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DirectTrajOpt.Integrators.BilinearIntegrator-Tuple{PiccoloQuantumObjects.QuantumTrajectories.SamplingTrajectory, Int64}"><a class="docstring-binding" href="#DirectTrajOpt.Integrators.BilinearIntegrator-Tuple{PiccoloQuantumObjects.QuantumTrajectories.SamplingTrajectory, Int64}"><code>DirectTrajOpt.Integrators.BilinearIntegrator</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">BilinearIntegrator(qtraj::SamplingTrajectory, N::Int)</code></pre><p>Create a vector of BilinearIntegrators for each system in a SamplingTrajectory.</p><p>Each system in the sampling ensemble gets its own dynamics integrator, but they all share the same control variables.</p><p><strong>Returns</strong></p><ul><li><code>Vector{BilinearIntegrator}</code>: One integrator per system in the ensemble</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/QuantumCollocation.jl/blob/6cd0784fe27926af7e8f3e87a2dfc4731a923b83/src/quantum_integrators.jl#L80-L90">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DirectTrajOpt.Integrators.BilinearIntegrator-Tuple{PiccoloQuantumObjects.QuantumTrajectories.UnitaryTrajectory, Int64}"><a class="docstring-binding" href="#DirectTrajOpt.Integrators.BilinearIntegrator-Tuple{PiccoloQuantumObjects.QuantumTrajectories.UnitaryTrajectory, Int64}"><code>DirectTrajOpt.Integrators.BilinearIntegrator</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">BilinearIntegrator(qtraj::UnitaryTrajectory, N::Int)</code></pre><p>Create a BilinearIntegrator for unitary evolution.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/QuantumCollocation.jl/blob/6cd0784fe27926af7e8f3e87a2dfc4731a923b83/src/quantum_integrators.jl#L23-L27">source</a></section></details></article><h2 id="Options"><a class="docs-heading-anchor" href="#Options">Options</a><a id="Options-1"></a><a class="docs-heading-anchor-permalink" href="#Options" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="QuantumCollocation.Options.PiccoloOptions"><a class="docstring-binding" href="#QuantumCollocation.Options.PiccoloOptions"><code>QuantumCollocation.Options.PiccoloOptions</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">PiccoloOptions</code></pre><p>Options for the Piccolo quantum optimal control library.</p><p><strong>Fields</strong></p><ul><li><code>verbose::Bool = true</code>: Print verbose output</li><li><code>timesteps_all_equal::Bool = true</code>: Use equal timesteps</li><li><code>rollout_integrator::Function = expv</code>: Integrator to use for rollout</li><li><code>geodesic = true</code>: Use the geodesic to initialize the optimization.</li><li><code>zero_initial_and_final_derivative::Bool=false</code>: Zero the initial and final control pulse derivatives.</li><li><code>complex_control_norm_constraint_name::Union{Nothing, Symbol} = nothing</code>: Name of the complex control norm constraint.</li><li><code>complex_control_norm_constraint_radius::Float64 = 1.0</code>: Radius of the complex control norm constraint.</li><li><code>bound_state::Bool = false</code>: Bound the state variables &lt;= 1.0.</li><li><code>leakage_constraint::Bool = false</code>: Suppress leakage with constraint and cost.</li><li><code>leakage_constraint_value::Float64 = 1e-2</code>: Value for the leakage constraint.</li><li><code>leakage_cost::Float64 = 1e-2</code>: Leakage suppression parameter.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/QuantumCollocation.jl/blob/6cd0784fe27926af7e8f3e87a2dfc4731a923b83/src/piccolo_options.jl#L10-L27">source</a></section></details></article><h2 id="Control-Problems"><a class="docs-heading-anchor" href="#Control-Problems">Control Problems</a><a id="Control-Problems-1"></a><a class="docs-heading-anchor-permalink" href="#Control-Problems" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="QuantumCollocation.QuantumControlProblems.QuantumControlProblem"><a class="docstring-binding" href="#QuantumCollocation.QuantumControlProblems.QuantumControlProblem"><code>QuantumCollocation.QuantumControlProblems.QuantumControlProblem</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">QuantumControlProblem{QT&lt;:AbstractQuantumTrajectory}</code></pre><p>Wrapper combining quantum trajectory information with trajectory optimization problem.</p><p>This type enables:</p><ul><li>Type-stable dispatch on quantum trajectory type (Unitary, Ket, Density)</li><li>Clean separation of quantum information (system, goal) from optimization details</li><li>Composable problem transformations (e.g., SmoothPulseProblem → MinimumTimeProblem)</li></ul><p><strong>Fields</strong></p><ul><li><code>qtraj::QT</code>: Quantum trajectory containing system, goal, and quantum state information</li><li><code>prob::DirectTrajOptProblem</code>: Direct trajectory optimization problem with objective, dynamics, constraints</li></ul><p><strong>Construction</strong></p><p>Typically created via problem templates:</p><pre><code class="language-julia hljs">qtraj = UnitaryTrajectory(sys, U_goal, N)
qcp = SmoothPulseProblem(qtraj; Q=100.0, R=1e-2)</code></pre><p><strong>Accessors</strong></p><ul><li><code>get_trajectory(qcp)</code>: Get the NamedTrajectory</li><li><code>get_system(qcp)</code>: Get the QuantumSystem</li><li><code>get_goal(qcp)</code>: Get the goal state/unitary</li><li><code>state_name(qcp)</code>: Get the state variable name</li><li><code>drive_name(qcp)</code>: Get the control variable name</li></ul><p><strong>Solving</strong></p><pre><code class="language-julia hljs">solve!(qcp; max_iter=100, verbose=true)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/QuantumCollocation.jl/blob/6cd0784fe27926af7e8f3e87a2dfc4731a923b83/src/quantum_control_problem.jl#L17-L49">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DirectTrajOpt.Solvers.solve!-Tuple{QuantumControlProblem}"><a class="docstring-binding" href="#DirectTrajOpt.Solvers.solve!-Tuple{QuantumControlProblem}"><code>DirectTrajOpt.Solvers.solve!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">solve!(qcp::QuantumControlProblem; sync::Bool=true, kwargs...)</code></pre><p>Solve the quantum control problem by forwarding to the inner DirectTrajOptProblem.</p><p><strong>Arguments</strong></p><ul><li><code>sync::Bool=true</code>: If true, call <code>sync_trajectory!</code> after solving to update <code>qtraj.trajectory</code> with physical control values. Set to false to skip synchronization (e.g., for debugging).</li></ul><p>All other keyword arguments are passed to the DirectTrajOpt solver.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/QuantumCollocation.jl/blob/6cd0784fe27926af7e8f3e87a2dfc4731a923b83/src/quantum_control_problem.jl#L152-L162">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PiccoloQuantumObjects.Pulses.drive_name-Tuple{QuantumControlProblem}"><a class="docstring-binding" href="#PiccoloQuantumObjects.Pulses.drive_name-Tuple{QuantumControlProblem}"><code>PiccoloQuantumObjects.Pulses.drive_name</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">drive_name(qcp::QuantumControlProblem)</code></pre><p>Get the control variable name from the quantum trajectory.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/QuantumCollocation.jl/blob/6cd0784fe27926af7e8f3e87a2dfc4731a923b83/src/quantum_control_problem.jl#L87-L91">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PiccoloQuantumObjects.QuantumTrajectories.get_goal-Tuple{QuantumControlProblem}"><a class="docstring-binding" href="#PiccoloQuantumObjects.QuantumTrajectories.get_goal-Tuple{QuantumControlProblem}"><code>PiccoloQuantumObjects.QuantumTrajectories.get_goal</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_goal(qcp::QuantumControlProblem)</code></pre><p>Get the goal state/operator from the quantum trajectory.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/QuantumCollocation.jl/blob/6cd0784fe27926af7e8f3e87a2dfc4731a923b83/src/quantum_control_problem.jl#L73-L77">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PiccoloQuantumObjects.QuantumTrajectories.get_system-Tuple{QuantumControlProblem}"><a class="docstring-binding" href="#PiccoloQuantumObjects.QuantumTrajectories.get_system-Tuple{QuantumControlProblem}"><code>PiccoloQuantumObjects.QuantumTrajectories.get_system</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_system(qcp::QuantumControlProblem)</code></pre><p>Get the QuantumSystem from the quantum trajectory.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/QuantumCollocation.jl/blob/6cd0784fe27926af7e8f3e87a2dfc4731a923b83/src/quantum_control_problem.jl#L66-L70">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PiccoloQuantumObjects.QuantumTrajectories.state_name-Tuple{QuantumControlProblem}"><a class="docstring-binding" href="#PiccoloQuantumObjects.QuantumTrajectories.state_name-Tuple{QuantumControlProblem}"><code>PiccoloQuantumObjects.QuantumTrajectories.state_name</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">state_name(qcp::QuantumControlProblem)</code></pre><p>Get the state variable name from the quantum trajectory.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/QuantumCollocation.jl/blob/6cd0784fe27926af7e8f3e87a2dfc4731a923b83/src/quantum_control_problem.jl#L80-L84">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PiccoloQuantumObjects.Rollouts.fidelity-Tuple{QuantumControlProblem}"><a class="docstring-binding" href="#PiccoloQuantumObjects.Rollouts.fidelity-Tuple{QuantumControlProblem}"><code>PiccoloQuantumObjects.Rollouts.fidelity</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">fidelity(qcp::QuantumControlProblem; kwargs...)</code></pre><p>Compute the fidelity of the quantum trajectory.</p><p>This is a convenience wrapper that forwards to <code>fidelity(qcp.qtraj; kwargs...)</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">solve!(qcp)
fid = fidelity(qcp)  # Equivalent to fidelity(qcp.qtraj)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/QuantumCollocation.jl/blob/6cd0784fe27926af7e8f3e87a2dfc4731a923b83/src/quantum_control_problem.jl#L94-L106">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantumCollocation.QuantumControlProblems.get_trajectory-Tuple{QuantumControlProblem}"><a class="docstring-binding" href="#QuantumCollocation.QuantumControlProblems.get_trajectory-Tuple{QuantumControlProblem}"><code>QuantumCollocation.QuantumControlProblems.get_trajectory</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_trajectory(qcp::QuantumControlProblem)</code></pre><p>Get the NamedTrajectory from the optimization problem.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/QuantumCollocation.jl/blob/6cd0784fe27926af7e8f3e87a2dfc4731a923b83/src/quantum_control_problem.jl#L59-L63">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantumCollocation.QuantumControlProblems.sync_trajectory!-Tuple{QuantumControlProblem}"><a class="docstring-binding" href="#QuantumCollocation.QuantumControlProblems.sync_trajectory!-Tuple{QuantumControlProblem}"><code>QuantumCollocation.QuantumControlProblems.sync_trajectory!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">sync_trajectory!(qcp::QuantumControlProblem)</code></pre><p>Update the quantum trajectory in-place from the optimized control values.</p><p>After optimization, this function:</p><ol><li>Extracts the optimized controls from <code>prob.trajectory</code> (unadapting if needed)</li><li>Creates a new pulse with those controls via <code>extract_pulse</code></li><li>Re-solves the ODE to get the updated quantum evolution</li><li>Replaces <code>qtraj</code> with the new quantum trajectory</li></ol><p>This gives you access to the continuous-time ODE solution with the optimized controls, allowing you to:</p><ul><li>Evaluate the fidelity via <code>fidelity(qcp.qtraj)</code></li><li>Sample the quantum state at any time via <code>qcp.qtraj(t)</code></li><li>Get the optimized pulse via <code>get_pulse(qcp.qtraj)</code></li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">solve!(qcp; max_iter=100)  # Automatically calls sync_trajectory!
fid = fidelity(qcp.qtraj)  # Evaluate fidelity with continuous-time solution
pulse = get_pulse(qcp.qtraj)  # Get the optimized pulse</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/QuantumCollocation.jl/blob/6cd0784fe27926af7e8f3e87a2dfc4731a923b83/src/quantum_control_problem.jl#L113-L136">source</a></section></details></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../generated/man/piccolo_options/">« PiccoloOptions Reference</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Friday 13 February 2026 00:40">Friday 13 February 2026</span>. Using Julia version 1.12.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
