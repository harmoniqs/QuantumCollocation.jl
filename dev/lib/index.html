<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Library · QuantumCollocation.jl</title><meta name="title" content="Library · QuantumCollocation.jl"/><meta property="og:title" content="Library · QuantumCollocation.jl"/><meta property="twitter:title" content="Library · QuantumCollocation.jl"/><meta name="description" content="Documentation for QuantumCollocation.jl."/><meta property="og:description" content="Documentation for QuantumCollocation.jl."/><meta property="twitter:description" content="Documentation for QuantumCollocation.jl."/><meta property="og:url" content="https://kestrelquantum.github.io/QuantumCollocation.jl/lib/"/><meta property="twitter:url" content="https://kestrelquantum.github.io/QuantumCollocation.jl/lib/"/><link rel="canonical" href="https://kestrelquantum.github.io/QuantumCollocation.jl/lib/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.svg" alt="QuantumCollocation.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">QuantumCollocation.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../generated/quickstart/">Quickstart Guide</a></li><li><a class="tocitem" href="../contribution_guide/">Contribution Guide</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../generated/man/problem_templates/">Problem Templates</a></li><li><a class="tocitem" href="../generated/man/embedded_operators/">Embedded Operators</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../generated/examples/two_qubit_gates/">Two Qubit Gates</a></li><li><a class="tocitem" href="../generated/examples/multilevel_transmon/">Multilevel Transmon</a></li></ul></li><li class="is-active"><a class="tocitem" href>Library</a><ul class="internal"><li><a class="tocitem" href="#Problem-Templates"><span>Problem Templates</span></a></li><li><a class="tocitem" href="#Direct-Sums"><span>Direct Sums</span></a></li><li><a class="tocitem" href="#Quantum-Object-Utils"><span>Quantum Object Utils</span></a></li><li><a class="tocitem" href="#Quantum-Systems"><span>Quantum Systems</span></a></li><li><a class="tocitem" href="#Integrators"><span>Integrators</span></a></li><li><a class="tocitem" href="#Objectives"><span>Objectives</span></a></li><li><a class="tocitem" href="#Losses"><span>Losses</span></a></li><li><a class="tocitem" href="#Embedded-Operators"><span>Embedded Operators</span></a></li><li><a class="tocitem" href="#Isomorphisms"><span>Isomorphisms</span></a></li><li><a class="tocitem" href="#Options"><span>Options</span></a></li><li><a class="tocitem" href="#Plotting"><span>Plotting</span></a></li><li><a class="tocitem" href="#Problem-Solvers"><span>Problem Solvers</span></a></li><li><a class="tocitem" href="#Rollouts"><span>Rollouts</span></a></li><li><a class="tocitem" href="#Saving-and-Loading"><span>Saving and Loading</span></a></li><li><a class="tocitem" href="#Structure-Utils"><span>Structure Utils</span></a></li><li><a class="tocitem" href="#Trajectory-Initialization"><span>Trajectory Initialization</span></a></li><li><a class="tocitem" href="#Trajectory-Interpolations"><span>Trajectory Interpolations</span></a></li></ul></li><li><a class="tocitem" href="../release_notes/">Release Notes</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Library</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Library</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/kestrelquantum/QuantumCollocation.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/kestrelquantum/QuantumCollocation.jl/blob/main/docs/src/lib.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Library"><a class="docs-heading-anchor" href="#Library">Library</a><a id="Library-1"></a><a class="docs-heading-anchor-permalink" href="#Library" title="Permalink"></a></h1><h2 id="Problem-Templates"><a class="docs-heading-anchor" href="#Problem-Templates">Problem Templates</a><a id="Problem-Templates-1"></a><a class="docs-heading-anchor-permalink" href="#Problem-Templates" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumCollocation.ProblemTemplates.QuantumStateMinimumTimeProblem" href="#QuantumCollocation.ProblemTemplates.QuantumStateMinimumTimeProblem"><code>QuantumCollocation.ProblemTemplates.QuantumStateMinimumTimeProblem</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">QuantumStateMinimumTimeProblem(traj, sys, obj, integrators, constraints; kwargs...)
QuantumStateMinimumTimeProblem(prob; kwargs...)</code></pre><p>Construct a <code>QuantumControlProblem</code> for the minimum time problem of reaching a target state.</p><p><strong>Arguments</strong></p><ul><li><code>traj::NamedTrajectory</code>: The initial trajectory.</li><li><code>sys::QuantumSystem</code>: The quantum system.</li><li><code>obj::Objective</code>: The objective function.</li><li><code>integrators::Vector{&lt;:AbstractIntegrator}</code>: The integrators.</li><li><code>constraints::Vector{&lt;:AbstractConstraint}</code>: The constraints.</li></ul><p>or</p><ul><li><code>prob::QuantumControlProblem</code>: The quantum control problem.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>state_name::Symbol=:ψ̃</code>: The symbol for the state variables.</li><li><code>final_fidelity::Union{Real, Nothing}=nothing</code>: The final fidelity.</li><li><code>D=1.0</code>: The cost weight on the time.</li><li><code>ipopt_options::IpoptOptions=IpoptOptions()</code>: The Ipopt options.</li><li><code>piccolo_options::PiccoloOptions=PiccoloOptions()</code>: The Piccolo options.</li><li><code>kwargs...</code>: Additional keyword arguments, passed to <a href="@ref"><code>QuantumControlProblem</code></a>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kestrelquantum/QuantumCollocation.jl/blob/46a6f190494a3bc0567a257783e5891db6970f13/src/problem_templates/quantum_state_minimum_time_problem.jl#L4-L27">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumCollocation.ProblemTemplates.QuantumStateSmoothPulseProblem" href="#QuantumCollocation.ProblemTemplates.QuantumStateSmoothPulseProblem"><code>QuantumCollocation.ProblemTemplates.QuantumStateSmoothPulseProblem</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">QuantumStateSmoothPulseProblem(system, ψ_inits, ψ_goals, T, Δt; kwargs...)
QuantumStateSmoothPulseProblem(system, ψ_init, ψ_goal, T, Δt; kwargs...)
QuantumStateSmoothPulseProblem(H_drift, H_drives, args...; kwargs...)</code></pre><p>Create a quantum state smooth pulse problem. The goal is to find a control pulse <code>a(t)</code> that drives all of the initial states <code>ψ_inits</code> to the corresponding target states <code>ψ_goals</code> using <code>T</code> timesteps of size <code>Δt</code>. This problem also controls the first and second derivatives of the control pulse, <code>da(t)</code> and <code>dda(t)</code>, to ensure smoothness.</p><p><strong>Arguments</strong></p><ul><li><code>system::AbstractQuantumSystem</code>: The quantum system.</li></ul><p>or</p><ul><li><code>H_drift::AbstractMatrix{&lt;:Number}</code>: The drift Hamiltonian.</li><li><code>H_drives::Vector{&lt;:AbstractMatrix{&lt;:Number}}</code>: The control Hamiltonians.</li></ul><p>with</p><ul><li><code>ψ_inits::Vector{&lt;:AbstractVector{&lt;:ComplexF64}}</code>: The initial states.</li><li><code>ψ_goals::Vector{&lt;:AbstractVector{&lt;:ComplexF64}}</code>: The target states.</li></ul><p>or</p><ul><li><code>ψ_init::AbstractVector{&lt;:ComplexF64}</code>: The initial state.</li><li><code>ψ_goal::AbstractVector{&lt;:ComplexF64}</code>: The target state.</li></ul><p>with</p><ul><li><code>T::Int</code>: The number of timesteps.</li><li><code>Δt::Float64</code>: The timestep size.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>ipopt_options::IpoptOptions=IpoptOptions()</code>: The IPOPT options.</li><li><code>piccolo_options::PiccoloOptions=PiccoloOptions()</code>: The Piccolo options.</li><li><code>state_name::Symbol=:ψ̃</code>: The name of the state variable.</li><li><code>control_name::Symbol=:a</code>: The name of the control variable.</li><li><code>timestep_name::Symbol=:Δt</code>: The name of the timestep variable.</li><li><code>init_trajectory::Union{NamedTrajectory, Nothing}=nothing</code>: The initial trajectory.</li><li><code>a_bound::Float64=1.0</code>: The bound on the control pulse.</li><li><code>a_bounds::Vector{Float64}=fill(a_bound, length(system.G_drives))</code>: The bounds on the control pulse.</li><li><code>a_guess::Union{Matrix{Float64}, Nothing}=nothing</code>: The initial guess for the control pulse.</li><li><code>da_bound::Float64=Inf</code>: The bound on the first derivative of the control pulse.</li><li><code>da_bounds::Vector{Float64}=fill(da_bound, length(system.G_drives))</code>: The bounds on the first derivative of the control pulse.</li><li><code>dda_bound::Float64=1.0</code>: The bound on the second derivative of the control pulse.</li><li><code>dda_bounds::Vector{Float64}=fill(dda_bound, length(system.G_drives))</code>: The bounds on the second derivative of the control pulse.</li><li><code>Δt_min::Float64=0.5 * Δt</code>: The minimum timestep size.</li><li><code>Δt_max::Float64=1.5 * Δt</code>: The maximum timestep size.</li><li><code>drive_derivative_σ::Float64=0.01</code>: The standard deviation of the drive derivative random initialization.</li><li><code>Q::Float64=100.0</code>: The weight on the state objective.</li><li><code>R=1e-2</code>: The weight on the control pulse and its derivatives.</li><li><code>R_a::Union{Float64, Vector{Float64}}=R</code>: The weight on the control pulse.</li><li><code>R_da::Union{Float64, Vector{Float64}}=R</code>: The weight on the first derivative of the control pulse.</li><li><code>R_dda::Union{Float64, Vector{Float64}}=R</code>: The weight on the second derivative of the control pulse.</li><li><code>leakage_operator::Union{Nothing, EmbeddedOperator}=nothing</code>: The leakage operator, if leakage suppression is desired.</li><li><code>constraints::Vector{&lt;:AbstractConstraint}=AbstractConstraint[]</code>: The constraints.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kestrelquantum/QuantumCollocation.jl/blob/46a6f190494a3bc0567a257783e5891db6970f13/src/problem_templates/quantum_state_smooth_pulse_problem.jl#L4-L53">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumCollocation.ProblemTemplates.UnitaryBangBangProblem" href="#QuantumCollocation.ProblemTemplates.UnitaryBangBangProblem"><code>QuantumCollocation.ProblemTemplates.UnitaryBangBangProblem</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">UnitaryBangBangProblem(system::QuantumSystem, operator, T, Δt; kwargs...)
UnitaryBangBangProblem(H_drift, H_drives, operator, T, Δt; kwargs...)</code></pre><p>Construct a <code>QuantumControlProblem</code> for a free-time unitary gate problem with bang-bang control pulses.</p><p class="math-container">\[\begin{aligned}
\underset{\vec{\tilde{U}}, a, \dot{a}, \Delta t}{\text{minimize}} &amp; \quad
Q \cdot \ell\qty(\vec{\tilde{U}}_T, \vec{\tilde{U}}_{\text{goal}}) + R_{\text{bang-bang}} \cdot \sum_t |\dot{a}_t| \\
\text{ subject to } &amp; \quad \vb{P}^{(n)}\qty(\vec{\tilde{U}}_{t+1}, \vec{\tilde{U}}_t, a_t, \Delta t_t) = 0 \\
&amp; \quad a_{t+1} - a_t - \dot{a}_t \Delta t_t = 0 \\
&amp; \quad |a_t| \leq a_{\text{bound}} \\
&amp; \quad |\dot{a}_t| \leq da_{\text{bound}} \\
&amp; \quad \Delta t_{\text{min}} \leq \Delta t_t \leq \Delta t_{\text{max}} \\
\end{aligned}\]</p><p>where, for <span>$U \in SU(N)$</span>,</p><p class="math-container">\[\ell\qty(\vec{\tilde{U}}_T, \vec{\tilde{U}}_{\text{goal}}) =
\abs{1 - \frac{1}{N} \abs{ \tr \qty(U_{\text{goal}}, U_T)} }\]</p><p>is the <em>infidelity</em> objective function, <span>$Q$</span> is a weight, <span>$R_a$</span>, and <span>$R_{\dot{a}}$</span> are weights on the regularization terms, and <span>$\vb{P}^{(n)}$</span> is the <span>$n$</span>th-order Pade integrator.</p><p>TODO: Document bang-bang modification.</p><p><strong>Arguments</strong></p><ul><li><code>H_drift::AbstractMatrix{&lt;:Number}</code>: the drift hamiltonian</li><li><code>H_drives::Vector{&lt;:AbstractMatrix{&lt;:Number}}</code>: the control hamiltonians</li></ul><p>or</p><ul><li><code>system::QuantumSystem</code>: the system to be controlled</li></ul><p>with</p><ul><li><code>operator::OperatorType</code>: the target unitary, either in the form of an <code>EmbeddedOperator</code> or a `Matrix{ComplexF64}</li><li><code>T::Int</code>: the number of timesteps</li><li><code>Δt::Float64</code>: the (initial) time step size</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>ipopt_options::IpoptOptions=IpoptOptions()</code>: the options for the Ipopt solver</li><li><code>piccolo_options::PiccoloOptions=PiccoloOptions()</code>: the options for the Piccolo solver</li><li><code>state_name::Symbol = :Ũ⃗</code>: the name of the state variable</li><li><code>control_name::Symbol = :a</code>: the name of the control variable</li><li><code>timestep_name::Symbol = :Δt</code>: the name of the timestep variable</li><li><code>init_trajectory::Union{NamedTrajectory, Nothing}=nothing</code>: an initial trajectory to use</li><li><code>a_bound::Float64=1.0</code>: the bound on the control pulse</li><li><code>a_bounds=fill(a_bound, length(system.G_drives))</code>: the bounds on the control pulses, one for each drive</li><li><code>a_guess::Union{Matrix{Float64}, Nothing}=nothing</code>: an initial guess for the control pulses</li><li><code>da_bound::Float64=1.0</code>: the bound on the control pulse derivative</li><li><code>da_bounds=fill(da_bound, length(system.G_drives))</code>: the bounds on the control pulse derivatives, one for each drive</li><li><code>Δt_min::Float64=Δt isa Float64 ? 0.5 * Δt : 0.5 * mean(Δt)</code>: the minimum time step size</li><li><code>Δt_max::Float64=Δt isa Float64 ? 1.5 * Δt : 1.5 * mean(Δt)</code>: the maximum time step size</li><li><code>drive_derivative_σ::Float64=0.01</code>: the standard deviation of the initial guess for the control pulse derivatives</li><li><code>Q::Float64=100.0</code>: the weight on the infidelity objective</li><li><code>R=1e-2</code>: the weight on the regularization terms</li><li><code>quadratic_control_regularization=false</code>: whether or not to use quadratic regularization for the control pulses</li><li><code>R_a::Union{Float64, Vector{Float64}}=R</code>: the weight on the regularization term for the control pulses</li><li><code>R_da::Union{Float64, Vector{Float64}}=R</code>: the weight on the regularization term for the control pulse derivatives</li><li><code>R_bang_bang::Union{Float64, Vector{Float64}}=1e-1</code>: the weight on the bang-bang regularization term</li><li><code>phase_operators::Union{AbstractVector{&lt;:AbstractMatrix}, Nothing}=nothing</code>: the phase operators for free phase corrections</li><li><code>constraints::Vector{&lt;:AbstractConstraint}=AbstractConstraint[]</code>: the constraints to enforce</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kestrelquantum/QuantumCollocation.jl/blob/46a6f190494a3bc0567a257783e5891db6970f13/src/problem_templates/unitary_bang_bang_problem.jl#L4-L67">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumCollocation.ProblemTemplates.UnitaryDirectSumProblem-Tuple{AbstractVector{&lt;:QuantumControlProblem}, Real}" href="#QuantumCollocation.ProblemTemplates.UnitaryDirectSumProblem-Tuple{AbstractVector{&lt;:QuantumControlProblem}, Real}"><code>QuantumCollocation.ProblemTemplates.UnitaryDirectSumProblem</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">UnitaryDirectSumProblem(probs, final_fidelity; kwargs...)</code></pre><p>Construct a <code>QuantumControlProblem</code> as a direct sum of unitary gate problems. The purpose is to find solutions that are as close as possible with respect to one of their components. In particular, this is useful for finding interpolatable control solutions.</p><p>A graph of edges (specified by problem labels) will enforce a <code>PairwiseQuadraticRegularizer</code> between the component trajectories of the problem in <code>probs</code> corresponding to the names of the edge in <code>edges</code> with corresponding edge weight <code>Q</code>.</p><p>Boundary values can be included to enforce a <code>QuadraticRegularizer</code> on edges where one of the nodes is not optimized. The boundary values are specified as a dictionary with keys corresponding to the edge labels and values corresponding to the boundary values.</p><p>The default behavior is to use a 1D chain for the graph, i.e., enforce a <code>PairwiseQuadraticRegularizer</code> between each neighbor of the provided <code>probs</code>.</p><p><strong>Arguments</strong></p><ul><li><code>probs::AbstractVector{&lt;:QuantumControlProblem}</code>: the problems to combine</li><li><code>final_fidelity::Real</code>: the fidelity to enforce between the component final unitaries and the component goal unitaries</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>prob_labels::AbstractVector{&lt;:String}}</code>: the labels for the problems</li><li>graph::Union{Nothing, AbstractVector{&lt;:Tuple{String, String}}, AbstractVector{&lt;:Tuple{Symbol, Symbol}}}`: the graph of edges to enforce</li><li><code>boundary_values::Union{Nothing, AbstractDict{&lt;:String, &lt;:AbstractArray}, AbstractDict{&lt;:Symbol, &lt;:AbstractVector}}=nothing</code>: the boundary values for the problems</li><li><code>Q::Union{Float64, Vector{Float64}}=100.0</code>: the weights on the pairwise regularizers</li><li><code>Q_symb::Symbol=:Ũ⃗</code>: the symbol to use for the regularizer</li><li><code>R::Float64=1e-2</code>: the shared weight on all control terms (:a, :da, :dda is assumed)</li><li><code>R_a::Union{Float64, Vector{Float64}}=R</code>: the weight on the regularization term for the control pulses</li><li><code>R_da::Union{Float64, Vector{Float64}}=R</code>: the weight on the regularization term for the control pulse derivatives</li><li><code>R_dda::Union{Float64, Vector{Float64}}=R</code>: the weight on the regularization term for the control pulse second derivatives</li><li><code>R_b::Union{Float64, Vector{Float64}}=R</code>: the weight on the regularization term for the boundary values</li><li><code>drive_derivative_σ::Float64=0.01</code>: the standard deviation of the initial guess for the control pulse derivatives</li><li><code>drive_reset_ratio::Float64=0.1</code>: amount of random noise to add to the control data (can help avoid hitting restoration if provided problems are converged)</li><li><code>fidelity_cost::Bool=false</code>: whether or not to include a fidelity cost in the objective</li><li><code>subspace::Union{AbstractVector{&lt;:Integer}, Nothing}=nothing</code>: the subspace to use for the fidelity of each problem</li><li><code>ipopt_options::IpoptOptions=IpoptOptions()</code>: the options for the Ipopt solver</li><li><code>piccolo_options::PiccoloOptions=PiccoloOptions()</code>: the options for the Piccolo solver</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kestrelquantum/QuantumCollocation.jl/blob/46a6f190494a3bc0567a257783e5891db6970f13/src/problem_templates/unitary_direct_sum_problem.jl#L4-L44">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumCollocation.ProblemTemplates.UnitaryRobustnessProblem" href="#QuantumCollocation.ProblemTemplates.UnitaryRobustnessProblem"><code>QuantumCollocation.ProblemTemplates.UnitaryRobustnessProblem</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">UnitaryRobustnessProblem(
    H_error,
    trajectory,
    system,
    objective,
    integrators,
    constraints;
    kwargs...
)

UnitaryRobustnessProblem(Hₑ, prob::QuantumControlProblem; kwargs...)</code></pre><p>Create a quantum control problem for robustness optimization of a unitary trajectory.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>unitary_name::Symbol=:Ũ⃗</code>: The symbol for the unitary trajectory in <code>trajectory</code>.</li><li><code>final_fidelity::Union{Real, Nothing}=nothing</code>: The target fidelity for the final unitary.</li><li><code>ipopt_options::IpoptOptions=IpoptOptions()</code>: Options for the Ipopt solver.</li><li><code>piccolo_options::PiccoloOptions=PiccoloOptions()</code>: Options for the Piccolo solver.</li><li><code>kwargs...</code>: Additional keyword arguments passed to <code>QuantumControlProblem</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kestrelquantum/QuantumCollocation.jl/blob/46a6f190494a3bc0567a257783e5891db6970f13/src/problem_templates/unitary_robustness_problem.jl#L4-L25">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumCollocation.ProblemTemplates.UnitarySamplingProblem-Tuple{AbstractVector{&lt;:AbstractQuantumSystem}, OperatorType, Int64, Union{Float64, Vector{Float64}}}" href="#QuantumCollocation.ProblemTemplates.UnitarySamplingProblem-Tuple{AbstractVector{&lt;:AbstractQuantumSystem}, OperatorType, Int64, Union{Float64, Vector{Float64}}}"><code>QuantumCollocation.ProblemTemplates.UnitarySamplingProblem</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">UnitarySamplingProblem(systemns, operator, T, Δt; kwargs...)</code></pre><p>A <code>UnitarySamplingProblem</code> is a quantum control problem where the goal is to find a control pulse that generates a target unitary operator for a set of quantum systems. The controls are shared among all systems, and the optimization seeks to find the control pulse that achieves the operator for each system. The idea is to enforce a robust solution by including multiple systems reflecting the problem uncertainty.</p><p><strong>Arguments</strong></p><ul><li><code>systems::AbstractVector{&lt;:AbstractQuantumSystem}</code>: A vector of quantum systems.</li><li><code>operator::OperatorType</code>: The target unitary operator.</li><li><code>T::Int</code>: The number of time steps.</li><li><code>Δt::Union{Float64, Vector{Float64}}</code>: The time step value or vector of time steps.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>system_labels::Vector{String} = string.(1:length(systems))</code>: The labels for each system.</li><li><code>system_weights::Vector{Float64} = fill(1.0, length(systems))</code>: The weights for each system.</li><li><code>init_trajectory::Union{NamedTrajectory, Nothing} = nothing</code>: The initial trajectory.</li><li><code>ipopt_options::IpoptOptions = IpoptOptions()</code>: The IPOPT options.</li><li><code>piccolo_options::PiccoloOptions = PiccoloOptions()</code>: The Piccolo options.</li><li><code>state_name::Symbol = :Ũ⃗</code>: The name of the state variable.</li><li><code>control_name::Symbol = :a</code>: The name of the control variable.</li><li><code>timestep_name::Symbol = :Δt</code>: The name of the timestep variable.</li><li><code>constraints::Vector{&lt;:AbstractConstraint} = AbstractConstraint[]</code>: The constraints.</li><li><code>a_bound::Float64 = 1.0</code>: The bound for the control amplitudes.</li><li><code>a_bounds::Vector{Float64} = fill(a_bound, length(systems[1].G_drives))</code>: The bounds for the control amplitudes.</li><li><code>a_guess::Union{Matrix{Float64}, Nothing} = nothing</code>: The initial guess for the control amplitudes.</li><li><code>da_bound::Float64 = Inf</code>: The bound for the control first derivatives.</li><li><code>da_bounds::Vector{Float64} = fill(da_bound, length(systems[1].G_drives))</code>: The bounds for the control first derivatives.</li><li><code>dda_bound::Float64 = 1.0</code>: The bound for the control second derivatives.</li><li><code>dda_bounds::Vector{Float64} = fill(dda_bound, length(systems[1].G_drives))</code>: The bounds for the control second derivatives.</li><li><code>Δt_min::Float64 = 0.5 * Δt</code>: The minimum time step size.</li><li><code>Δt_max::Float64 = 1.5 * Δt</code>: The maximum time step size.</li><li><code>Q::Float64 = 100.0</code>: The fidelity weight.</li><li><code>R::Float64 = 1e-2</code>: The regularization weight.</li><li><code>R_a::Union{Float64, Vector{Float64}} = R</code>: The regularization weight for the control amplitudes.</li><li><code>R_da::Union{Float64, Vector{Float64}} = R</code>: The regularization weight for the control first derivatives.</li><li><code>R_dda::Union{Float64, Vector{Float64}} = R</code>: The regularization weight for the control second derivatives.</li><li><code>kwargs...</code>: Additional keyword arguments.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kestrelquantum/QuantumCollocation.jl/blob/46a6f190494a3bc0567a257783e5891db6970f13/src/problem_templates/unitary_sampling_problem.jl#L4-L43">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumCollocation.ProblemTemplates.UnitarySmoothPulseProblem-Tuple{AbstractQuantumSystem, OperatorType, Int64, Union{Float64, Vector{Float64}}}" href="#QuantumCollocation.ProblemTemplates.UnitarySmoothPulseProblem-Tuple{AbstractQuantumSystem, OperatorType, Int64, Union{Float64, Vector{Float64}}}"><code>QuantumCollocation.ProblemTemplates.UnitarySmoothPulseProblem</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">UnitarySmoothPulseProblem(system::AbstractQuantumSystem, operator, T, Δt; kwargs...)
UnitarySmoothPulseProblem(H_drift, H_drives, operator, T, Δt; kwargs...)</code></pre><p>Construct a <code>QuantumControlProblem</code> for a free-time unitary gate problem with smooth control pulses enforced by constraining the second derivative of the pulse trajectory, i.e.,</p><p class="math-container">\[\begin{aligned}
\underset{\vec{\tilde{U}}, a, \dot{a}, \ddot{a}, \Delta t}{\text{minimize}} &amp; \quad
Q \cdot \ell\qty(\vec{\tilde{U}}_T, \vec{\tilde{U}}_{\text{goal}}) + \frac{1}{2} \sum_t \qty(R_a a_t^2 + R_{\dot{a}} \dot{a}_t^2 + R_{\ddot{a}} \ddot{a}_t^2) \\
\text{ subject to } &amp; \quad \vb{P}^{(n)}\qty(\vec{\tilde{U}}_{t+1}, \vec{\tilde{U}}_t, a_t, \Delta t_t) = 0 \\
&amp; \quad a_{t+1} - a_t - \dot{a}_t \Delta t_t = 0 \\
&amp; \quad \dot{a}_{t+1} - \dot{a}_t - \ddot{a}_t \Delta t_t = 0 \\
&amp; \quad |a_t| \leq a_{\text{bound}} \\
&amp; \quad |\ddot{a}_t| \leq \ddot{a}_{\text{bound}} \\
&amp; \quad \Delta t_{\text{min}} \leq \Delta t_t \leq \Delta t_{\text{max}} \\
\end{aligned}\]</p><p>where, for <span>$U \in SU(N)$</span>,</p><p class="math-container">\[\ell\qty(\vec{\tilde{U}}_T, \vec{\tilde{U}}_{\text{goal}}) =
\abs{1 - \frac{1}{N} \abs{ \tr \qty(U_{\text{goal}}, U_T)} }\]</p><p>is the <em>infidelity</em> objective function, <span>$Q$</span> is a weight, <span>$R_a$</span>, <span>$R_{\dot{a}}$</span>, and <span>$R_{\ddot{a}}$</span> are weights on the regularization terms, and <span>$\vb{P}^{(n)}$</span> is the <span>$n$</span>th-order Pade integrator.</p><p><strong>Arguments</strong></p><ul><li><code>system::AbstractQuantumSystem</code>: the system to be controlled</li></ul><p>or</p><ul><li><code>H_drift::AbstractMatrix{&lt;:Number}</code>: the drift hamiltonian</li><li><code>H_drives::Vector{&lt;:AbstractMatrix{&lt;:Number}}</code>: the control hamiltonians</li></ul><p>with</p><ul><li><code>operator::OperatorType</code>: the target unitary, either in the form of an <code>EmbeddedOperator</code> or a `Matrix{ComplexF64}</li><li><code>T::Int</code>: the number of timesteps</li><li><code>Δt::Float64</code>: the (initial) time step size</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>ipopt_options::IpoptOptions=IpoptOptions()</code>: the options for the Ipopt solver</li><li><code>piccolo_options::PiccoloOptions=PiccoloOptions()</code>: the options for the Piccolo solver</li><li><code>state_name::Symbol = :Ũ⃗</code>: the name of the state</li><li><code>control_name::Symbol = :a</code>: the name of the control</li><li><code>timestep_name::Symbol = :Δt</code>: the name of the timestep</li><li><code>init_trajectory::Union{NamedTrajectory, Nothing}=nothing</code>: an initial trajectory to use</li><li><code>a_bound::Float64=1.0</code>: the bound on the control pulse</li><li><code>a_bounds::Vector{Float64}=fill(a_bound, length(system.G_drives))</code>: the bounds on the control pulses, one for each drive</li><li><code>a_guess::Union{Matrix{Float64}, Nothing}=nothing</code>: an initial guess for the control pulses</li><li><code>da_bound::Float64=Inf</code>: the bound on the control pulse derivative</li><li><code>da_bounds::Vector{Float64}=fill(da_bound, length(system.G_drives))</code>: the bounds on the control pulse derivatives, one for each drive</li><li><code>dda_bound::Float64=1.0</code>: the bound on the control pulse second derivative</li><li><code>dda_bounds::Vector{Float64}=fill(dda_bound, length(system.G_drives))</code>: the bounds on the control pulse second derivatives, one for each drive</li><li><code>Δt_min::Float64=Δt isa Float64 ? 0.5 * Δt : 0.5 * mean(Δt)</code>: the minimum time step size</li><li><code>Δt_max::Float64=Δt isa Float64 ? 1.5 * Δt : 1.5 * mean(Δt)</code>: the maximum time step size</li><li><code>Q::Float64=100.0</code>: the weight on the infidelity objective</li><li><code>R=1e-2</code>: the weight on the regularization terms</li><li><code>R_a::Union{Float64, Vector{Float64}}=R</code>: the weight on the regularization term for the control pulses</li><li><code>R_da::Union{Float64, Vector{Float64}}=R</code>: the weight on the regularization term for the control pulse derivatives</li><li><code>R_dda::Union{Float64, Vector{Float64}}=R</code>: the weight on the regularization term for the control pulse second derivatives</li><li><code>phase_name::Symbol=:ϕ</code>: the name of the phase</li><li><code>phase_operators::Union{AbstractVector{&lt;:AbstractMatrix}, Nothing}=nothing</code>: the phase operators for free phase corrections</li><li><code>constraints::Vector{&lt;:AbstractConstraint}=AbstractConstraint[]</code>: the constraints to enforce</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kestrelquantum/QuantumCollocation.jl/blob/46a6f190494a3bc0567a257783e5891db6970f13/src/problem_templates/unitary_smooth_pulse_problem.jl#L4-L68">source</a></section></article><h2 id="Direct-Sums"><a class="docs-heading-anchor" href="#Direct-Sums">Direct Sums</a><a id="Direct-Sums-1"></a><a class="docs-heading-anchor-permalink" href="#Direct-Sums" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumCollocation.DirectSums.direct_sum-Tuple{AbstractMatrix, AbstractMatrix}" href="#QuantumCollocation.DirectSums.direct_sum-Tuple{AbstractMatrix, AbstractMatrix}"><code>QuantumCollocation.DirectSums.direct_sum</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">direct_sum(A::AbstractMatrix, B::AbstractMatrix)</code></pre><p>Returns the direct sum of two matrices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kestrelquantum/QuantumCollocation.jl/blob/46a6f190494a3bc0567a257783e5891db6970f13/src/direct_sums.jl#L21-L25">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumCollocation.DirectSums.direct_sum-Tuple{AbstractVector, AbstractVector}" href="#QuantumCollocation.DirectSums.direct_sum-Tuple{AbstractVector, AbstractVector}"><code>QuantumCollocation.DirectSums.direct_sum</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">direct_sum(Ã⃗::AbstractVector, B̃⃗::AbstractVector)</code></pre><p>Returns the direct sum of two iso_vec operators.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kestrelquantum/QuantumCollocation.jl/blob/46a6f190494a3bc0567a257783e5891db6970f13/src/direct_sums.jl#L39-L43">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumCollocation.DirectSums.direct_sum-Tuple{NamedTrajectories.StructNamedTrajectory.NamedTrajectory, NamedTrajectories.StructNamedTrajectory.NamedTrajectory}" href="#QuantumCollocation.DirectSums.direct_sum-Tuple{NamedTrajectories.StructNamedTrajectory.NamedTrajectory, NamedTrajectories.StructNamedTrajectory.NamedTrajectory}"><code>QuantumCollocation.DirectSums.direct_sum</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">direct_sum(traj1::NamedTrajectory, traj2::NamedTrajectory)</code></pre><p>Returns the direct sum of two <code>NamedTrajectory</code> objects.</p><p>The <code>NamedTrajectory</code> objects must have the same timestep. However, a direct sum can return a free time problem by passing the keyword argument  <code>free_time=true</code>. In this case, the timestep symbol must be provided. If a free time problem with more than two trajectories is desired, the <code>reduce</code> function has been written to handle calls to direct sums of <code>NamedTrajectory</code> objects; simply pass the keyword argument <code>free_time=true</code> to the <code>reduce</code> function.</p><p><strong>Arguments</strong></p><ul><li><code>traj1::NamedTrajectory</code>: The first <code>NamedTrajectory</code> object.</li><li><code>traj2::NamedTrajectory</code>: The second <code>NamedTrajectory</code> object.</li><li><code>free_time::Bool=false</code>: Whether to construct a free time problem.</li><li><code>timestep_name::Symbol=:Δt</code>: The timestep symbol to use for free time problems.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kestrelquantum/QuantumCollocation.jl/blob/46a6f190494a3bc0567a257783e5891db6970f13/src/direct_sums.jl#L70-L87">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumCollocation.DirectSums.direct_sum-Tuple{QuantumSystem, QuantumSystem}" href="#QuantumCollocation.DirectSums.direct_sum-Tuple{QuantumSystem, QuantumSystem}"><code>QuantumCollocation.DirectSums.direct_sum</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">direct_sum(sys1::QuantumSystem, sys2::QuantumSystem)</code></pre><p>Returns the direct sum of two <code>QuantumSystem</code> objects.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kestrelquantum/QuantumCollocation.jl/blob/46a6f190494a3bc0567a257783e5891db6970f13/src/direct_sums.jl#L48-L52">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumCollocation.DirectSums.direct_sum-Tuple{SparseArrays.SparseMatrixCSC, SparseArrays.SparseMatrixCSC}" href="#QuantumCollocation.DirectSums.direct_sum-Tuple{SparseArrays.SparseMatrixCSC, SparseArrays.SparseMatrixCSC}"><code>QuantumCollocation.DirectSums.direct_sum</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">direct_sum(A::SparseMatrixCSC, B::SparseMatrixCSC)</code></pre><p>Returns the direct sum of two sparse matrices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kestrelquantum/QuantumCollocation.jl/blob/46a6f190494a3bc0567a257783e5891db6970f13/src/direct_sums.jl#L30-L34">source</a></section></article><h2 id="Quantum-Object-Utils"><a class="docs-heading-anchor" href="#Quantum-Object-Utils">Quantum Object Utils</a><a id="Quantum-Object-Utils-1"></a><a class="docs-heading-anchor-permalink" href="#Quantum-Object-Utils" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumCollocation.QuantumObjectUtils.GATES" href="#QuantumCollocation.QuantumObjectUtils.GATES"><code>QuantumCollocation.QuantumObjectUtils.GATES</code></a> — <span class="docstring-category">Constant</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>A constant dictionary <code>GATES</code> containing common quantum gate matrices as complex-valued matrices. Each gate is represented by its unitary matrix.</p><ul><li><code>GATES[:I]</code> - Identity gate: Leaves the state unchanged.</li><li><code>GATES[:X]</code> - Pauli-X (NOT) gate: Flips the qubit state.</li><li><code>GATES[:Y]</code> - Pauli-Y gate: Rotates the qubit state around the Y-axis of the Bloch sphere.</li><li><code>GATES[:Z]</code> - Pauli-Z gate: Flips the phase of the qubit state.</li><li><code>GATES[:H]</code> - Hadamard gate: Creates superposition by transforming basis states.</li><li><code>GATES[:CX]</code> - Controlled-X (CNOT) gate: Flips the second qubit (target) if the first qubit (control) is |1⟩.</li><li><code>GATES[:CZ]</code> - Controlled-Z (CZ) gate: Flips the phase of the second qubit (target) if the first qubit (control) is |1⟩.</li><li><code>GATES[:XI]</code> - Complex gate: A specific gate used for complex operations.</li><li><code>GATES[:sqrtiSWAP]</code> - Square root of iSWAP gate: Partially swaps two qubits with a phase.</li></ul><pre><code class="language-julia hljs">julia&gt; GATES[:Z]
2×2 Matrix{ComplexF64}:
 1.0+0.0im   0.0+0.0im
 0.0+0.0im  -1.0+0.0im

julia&gt; get_gate(:CX)
4×4 Matrix{ComplexF64}:
 1.0+0.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im
 0.0+0.0im  1.0+0.0im  0.0+0.0im  0.0+0.0im
 0.0+0.0im  0.0+0.0im  0.0+0.0im  1.0+0.0im
 0.0+0.0im  0.0+0.0im  1.0+0.0im  0.0+0.0im</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kestrelquantum/QuantumCollocation.jl/blob/46a6f190494a3bc0567a257783e5891db6970f13/src/quantum_object_utils.jl#L25-L51">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumCollocation.QuantumObjectUtils.:⊗-Tuple{AbstractVecOrMat, AbstractVecOrMat}" href="#QuantumCollocation.QuantumObjectUtils.:⊗-Tuple{AbstractVecOrMat, AbstractVecOrMat}"><code>QuantumCollocation.QuantumObjectUtils.:⊗</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">⊗(A::AbstractVecOrMat, B::AbstractVecOrMat) = kron(A, B)</code></pre><p>The Kronecker product, denoted by <code>⊗</code>, results in a block matrix formed by multiplying each element of <code>A</code> by the entire matrix <code>B</code>.</p><pre><code class="language-julia hljs">julia&gt; GATES[:X] ⊗ GATES[:Y]
4×4 Matrix{ComplexF64}:
 0.0+0.0im  0.0+0.0im  0.0+0.0im  0.0-1.0im
 0.0+0.0im  0.0+0.0im  0.0+1.0im  0.0+0.0im
 0.0+0.0im  0.0-1.0im  0.0+0.0im  0.0+0.0im
 0.0+1.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kestrelquantum/QuantumCollocation.jl/blob/46a6f190494a3bc0567a257783e5891db6970f13/src/quantum_object_utils.jl#L100-L113">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumCollocation.QuantumObjectUtils.annihilate-Tuple{Int64}" href="#QuantumCollocation.QuantumObjectUtils.annihilate-Tuple{Int64}"><code>QuantumCollocation.QuantumObjectUtils.annihilate</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">annihilate(levels::Int)</code></pre><p>Get the annihilation operator for a system with <code>levels</code> levels.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kestrelquantum/QuantumCollocation.jl/blob/46a6f190494a3bc0567a257783e5891db6970f13/src/quantum_object_utils.jl#L253-L257">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumCollocation.QuantumObjectUtils.create-Tuple{Int64}" href="#QuantumCollocation.QuantumObjectUtils.create-Tuple{Int64}"><code>QuantumCollocation.QuantumObjectUtils.create</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">create(levels::Int)</code></pre><p>Get the creation operator for a system with <code>levels</code> levels.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kestrelquantum/QuantumCollocation.jl/blob/46a6f190494a3bc0567a257783e5891db6970f13/src/quantum_object_utils.jl#L262-L266">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumCollocation.QuantumObjectUtils.haar_identity-Tuple{Int64, Number}" href="#QuantumCollocation.QuantumObjectUtils.haar_identity-Tuple{Int64, Number}"><code>QuantumCollocation.QuantumObjectUtils.haar_identity</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">haar_identity(n::Int, radius::Number)</code></pre><p>Generate a random unitary matrix close to the identity matrix using the Haar measure for an <code>n</code>-dimensional system with a given <code>radius</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kestrelquantum/QuantumCollocation.jl/blob/46a6f190494a3bc0567a257783e5891db6970f13/src/quantum_object_utils.jl#L235-L239">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumCollocation.QuantumObjectUtils.haar_random-Tuple{Int64}" href="#QuantumCollocation.QuantumObjectUtils.haar_random-Tuple{Int64}"><code>QuantumCollocation.QuantumObjectUtils.haar_random</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">haar_random(n::Int)</code></pre><p>Generate a random unitary matrix using the Haar measure for an <code>n</code>-dimensional system.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kestrelquantum/QuantumCollocation.jl/blob/46a6f190494a3bc0567a257783e5891db6970f13/src/quantum_object_utils.jl#L221-L225">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumCollocation.QuantumObjectUtils.ket_from_bitstring-Tuple{String}" href="#QuantumCollocation.QuantumObjectUtils.ket_from_bitstring-Tuple{String}"><code>QuantumCollocation.QuantumObjectUtils.ket_from_bitstring</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ket_from_bitstring(ket::String)</code></pre><p>Get the state vector for a qubit system given a ket string <code>ket</code> of 0s and 1s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kestrelquantum/QuantumCollocation.jl/blob/46a6f190494a3bc0567a257783e5891db6970f13/src/quantum_object_utils.jl#L205-L209">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumCollocation.QuantumObjectUtils.ket_from_string-Tuple{String, Vector{Int64}}" href="#QuantumCollocation.QuantumObjectUtils.ket_from_string-Tuple{String, Vector{Int64}}"><code>QuantumCollocation.QuantumObjectUtils.ket_from_string</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ket_from_string(
    ket::String,
    levels::Vector{Int};
    level_dict=Dict(:g =&gt; 0, :e =&gt; 1, :f =&gt; 2, :h =&gt; 2),
    return_states=false
)</code></pre><p>Construct a quantum state from a string ket representation.</p><p><strong>Example</strong></p><p><strong>TODO: add example</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kestrelquantum/QuantumCollocation.jl/blob/46a6f190494a3bc0567a257783e5891db6970f13/src/quantum_object_utils.jl#L142-L155">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumCollocation.QuantumObjectUtils.operator_from_string-Tuple{String}" href="#QuantumCollocation.QuantumObjectUtils.operator_from_string-Tuple{String}"><code>QuantumCollocation.QuantumObjectUtils.operator_from_string</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>operator<em>from</em>string(operator::String; lookup::Dict{Symbol, AbstractMatrix}=PAULIS)</p><pre><code class="nohighlight hljs">Reduce the string (each character is one key) via operators from a dictionary.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kestrelquantum/QuantumCollocation.jl/blob/46a6f190494a3bc0567a257783e5891db6970f13/src/quantum_object_utils.jl#L116-L121">source</a></section></article><h2 id="Quantum-Systems"><a class="docs-heading-anchor" href="#Quantum-Systems">Quantum Systems</a><a id="Quantum-Systems-1"></a><a class="docs-heading-anchor-permalink" href="#Quantum-Systems" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumCollocation.QuantumSystems.AbstractQuantumSystem" href="#QuantumCollocation.QuantumSystems.AbstractQuantumSystem"><code>QuantumCollocation.QuantumSystems.AbstractQuantumSystem</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractQuantumSystem</code></pre><p>Abstract type for defining systems.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kestrelquantum/QuantumCollocation.jl/blob/46a6f190494a3bc0567a257783e5891db6970f13/src/quantum_systems.jl#L27-L31">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumCollocation.QuantumSystems.QuantumSystem" href="#QuantumCollocation.QuantumSystems.QuantumSystem"><code>QuantumCollocation.QuantumSystems.QuantumSystem</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">QuantumSystem &lt;: AbstractQuantumSystem</code></pre><p>A struct for storing the isomorphisms of the system&#39;s drift and drive Hamiltonians, as well as the system&#39;s parameters.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kestrelquantum/QuantumCollocation.jl/blob/46a6f190494a3bc0567a257783e5891db6970f13/src/quantum_systems.jl#L38-L43">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumCollocation.QuantumSystems.QuantumSystem-Tuple{AbstractMatrix{&lt;:Number}, Vector{&lt;:AbstractMatrix{&lt;:Number}}}" href="#QuantumCollocation.QuantumSystems.QuantumSystem-Tuple{AbstractMatrix{&lt;:Number}, Vector{&lt;:AbstractMatrix{&lt;:Number}}}"><code>QuantumCollocation.QuantumSystems.QuantumSystem</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">QuantumSystem(
    H_drift::Matrix{&lt;:Number},
    H_drives::Vector{Matrix{&lt;:Number}};
    params=Dict{Symbol, Any}(),
    kwargs...
)::QuantumSystem</code></pre><p>Constructs a <code>QuantumSystem</code> object from the drift and drive Hamiltonian terms.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kestrelquantum/QuantumCollocation.jl/blob/46a6f190494a3bc0567a257783e5891db6970f13/src/quantum_systems.jl#L55-L64">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumCollocation.QuantumSystems.QuantumSystemCoupling" href="#QuantumCollocation.QuantumSystems.QuantumSystemCoupling"><code>QuantumCollocation.QuantumSystems.QuantumSystemCoupling</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">QuantumSystemCoupling &lt;: AbstractQuantumSystem</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kestrelquantum/QuantumCollocation.jl/blob/46a6f190494a3bc0567a257783e5891db6970f13/src/quantum_systems.jl#L187-L190">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumCollocation.QuantumSystems.lift-Tuple{AbstractMatrix{&lt;:Number}, Int64, Int64}" href="#QuantumCollocation.QuantumSystems.lift-Tuple{AbstractMatrix{&lt;:Number}, Int64, Int64}"><code>QuantumCollocation.QuantumSystems.lift</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">lift(U::AbstractMatrix{&lt;:Number}, qubit_index::Int, n_qubits::Int; levels::Int=size(U, 1))</code></pre><p>Lift an operator <code>U</code> acting on a single qubit to an operator acting on the entire system of <code>n_qubits</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kestrelquantum/QuantumCollocation.jl/blob/46a6f190494a3bc0567a257783e5891db6970f13/src/quantum_systems.jl#L154-L158">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumCollocation.QuantumSystems.lift-Tuple{AbstractMatrix{&lt;:Number}, Int64, Vector{Int64}}" href="#QuantumCollocation.QuantumSystems.lift-Tuple{AbstractMatrix{&lt;:Number}, Int64, Vector{Int64}}"><code>QuantumCollocation.QuantumSystems.lift</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">lift(op::AbstractMatrix{&lt;:Number}, i::Int, subsystem_levels::Vector{Int})</code></pre><p>Lift an operator <code>op</code> acting on the i-th subsystem to an operator acting on the entire system with given subsystem levels.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kestrelquantum/QuantumCollocation.jl/blob/46a6f190494a3bc0567a257783e5891db6970f13/src/quantum_systems.jl#L170-L174">source</a></section></article><h2 id="Integrators"><a class="docs-heading-anchor" href="#Integrators">Integrators</a><a id="Integrators-1"></a><a class="docs-heading-anchor-permalink" href="#Integrators" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumCollocation.Integrators.UnitaryPadeIntegrator" href="#QuantumCollocation.Integrators.UnitaryPadeIntegrator"><code>QuantumCollocation.Integrators.UnitaryPadeIntegrator</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kestrelquantum/QuantumCollocation.jl/blob/46a6f190494a3bc0567a257783e5891db6970f13/src/integrators/pade_integrators.jl#L209">source</a></section></article><h2 id="Objectives"><a class="docs-heading-anchor" href="#Objectives">Objectives</a><a id="Objectives-1"></a><a class="docs-heading-anchor-permalink" href="#Objectives" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumCollocation.Objectives.Objective" href="#QuantumCollocation.Objectives.Objective"><code>QuantumCollocation.Objectives.Objective</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Objective</code></pre><p>A structure for defining objective functions.</p><p>The <code>terms</code> field contains all the arguments needed to construct the objective function.</p><p>Fields:     <code>L</code>: the objective function     <code>∇L</code>: the gradient of the objective function     <code>∂²L</code>: the Hessian of the objective function     <code>∂²L_structure</code>: the structure of the Hessian of the objective function     <code>terms</code>: a vector of dictionaries containing the terms of the objective function</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kestrelquantum/QuantumCollocation.jl/blob/46a6f190494a3bc0567a257783e5891db6970f13/src/objectives/_objectives.jl#L44-L57">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumCollocation.Objectives.L1Regularizer-Tuple{}" href="#QuantumCollocation.Objectives.L1Regularizer-Tuple{}"><code>QuantumCollocation.Objectives.L1Regularizer</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">L1Regularizer</code></pre><p>Create an L1 regularizer for the trajectory component. The regularizer is defined as</p><p class="math-container">\[J_{L1}(u) = \sum_t \abs{R \cdot u_t}\]</p><p>where (R) is the regularization matrix and (u_t) is the trajectory component at time (t).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kestrelquantum/QuantumCollocation.jl/blob/46a6f190494a3bc0567a257783e5891db6970f13/src/objectives/regularizer_objective.jl#L328-L340">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumCollocation.Objectives.MinimumTimeObjective-Tuple{}" href="#QuantumCollocation.Objectives.MinimumTimeObjective-Tuple{}"><code>QuantumCollocation.Objectives.MinimumTimeObjective</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">MinimumTimeObjective</code></pre><p>A type of objective that counts the time taken to complete a task.</p><p>Fields:     <code>D</code>: a scaling factor     <code>Δt_indices</code>: the indices of the time steps     <code>eval_hessian</code>: whether to evaluate the Hessian</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kestrelquantum/QuantumCollocation.jl/blob/46a6f190494a3bc0567a257783e5891db6970f13/src/objectives/minimum_time_objective.jl#L4-L14">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumCollocation.Objectives.PairwiseQuadraticRegularizer-Tuple{AbstractVector{&lt;:Real}, AbstractVector{Int64}, Symbol, Symbol}" href="#QuantumCollocation.Objectives.PairwiseQuadraticRegularizer-Tuple{AbstractVector{&lt;:Real}, AbstractVector{Int64}, Symbol, Symbol}"><code>QuantumCollocation.Objectives.PairwiseQuadraticRegularizer</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">PairwiseQuadraticRegularizer</code></pre><p>Create a pairwise quadratic regularizer for the trajectory component <code>name</code> with regularization strength <code>R</code>. The regularizer is defined as</p><p class="math-container">\[    J_{v⃗}(u) = \sum_t \frac{1}{2} \Delta t_t^2 (v⃗_{1,t} - v⃗_{2,t})^T R (v⃗_{1,t} - v⃗_{2,t})\]</p><p>where <span>$v⃗_{1}$</span> and <span>$v⃗_{2}$</span> are selected by <code>name1</code> and <code>name2</code>. The indices specify the appropriate block diagonal components of the direct sum vector <code>v⃗</code>.</p><p>TODO: Hessian not implemented</p><p>Fields:     <code>R</code>: the regularization strength     <code>times</code>: the time steps to apply the regularizer     <code>name1</code>: the first name     <code>name2</code>: the second name     <code>timestep_name</code>: the symbol for the timestep     <code>eval_hessian</code>: whether to evaluate the Hessian</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kestrelquantum/QuantumCollocation.jl/blob/46a6f190494a3bc0567a257783e5891db6970f13/src/objectives/regularizer_objective.jl#L426-L449">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumCollocation.Objectives.PairwiseQuadraticRegularizer-Tuple{NamedTrajectories.StructNamedTrajectory.NamedTrajectory, Union{Float64, AbstractVector{&lt;:Float64}}, AbstractVector{&lt;:Tuple{Symbol, Symbol}}}" href="#QuantumCollocation.Objectives.PairwiseQuadraticRegularizer-Tuple{NamedTrajectories.StructNamedTrajectory.NamedTrajectory, Union{Float64, AbstractVector{&lt;:Float64}}, AbstractVector{&lt;:Tuple{Symbol, Symbol}}}"><code>QuantumCollocation.Objectives.PairwiseQuadraticRegularizer</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">PairwiseQuadraticRegularizer</code></pre><p>A convenience constructor for creating a PairwiseQuadraticRegularizer for the trajectory component <code>name</code> with regularization strength <code>Rs</code> over the graph <code>graph</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kestrelquantum/QuantumCollocation.jl/blob/46a6f190494a3bc0567a257783e5891db6970f13/src/objectives/regularizer_objective.jl#L515-L520">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumCollocation.Objectives.PairwiseUnitaryRobustnessObjective-Tuple{}" href="#QuantumCollocation.Objectives.PairwiseUnitaryRobustnessObjective-Tuple{}"><code>QuantumCollocation.Objectives.PairwiseUnitaryRobustnessObjective</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">PairwiseUnitaryRobustnessObjective(;
    H1::Union{OperatorType, Nothing}=nothing,
    H2_error::Union{OperatorType, Nothing}=nothing,
    symb1::Symbol=:Ũ⃗1,
    symb2::Symbol=:Ũ⃗2,
    eval_hessian::Bool=false,
)</code></pre><p>Create a control objective which penalizes the sensitivity of the infidelity to the provided operators defined in the subspaces of the control dynamics, thereby realizing robust control.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kestrelquantum/QuantumCollocation.jl/blob/46a6f190494a3bc0567a257783e5891db6970f13/src/objectives/unitary_robustness_objective.jl#L128-L139">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumCollocation.Objectives.QuadraticRegularizer-Tuple{}" href="#QuantumCollocation.Objectives.QuadraticRegularizer-Tuple{}"><code>QuantumCollocation.Objectives.QuadraticRegularizer</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">QuadraticRegularizer</code></pre><p>A quadratic regularizer for a trajectory component.</p><p>Fields:     <code>name</code>: the name of the trajectory component to regularize     <code>times</code>: the times at which to evaluate the regularizer     <code>dim</code>: the dimension of the trajectory component     <code>R</code>: the regularization matrix     <code>baseline</code>: the baseline values for the trajectory component     <code>eval_hessian</code>: whether to evaluate the Hessian of the regularizer     <code>timestep_name</code>: the symbol for the timestep variable</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kestrelquantum/QuantumCollocation.jl/blob/46a6f190494a3bc0567a257783e5891db6970f13/src/objectives/regularizer_objective.jl#L12-L25">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumCollocation.Objectives.QuadraticSmoothnessRegularizer-Tuple{}" href="#QuantumCollocation.Objectives.QuadraticSmoothnessRegularizer-Tuple{}"><code>QuantumCollocation.Objectives.QuadraticSmoothnessRegularizer</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">QuadraticSmoothnessRegularizer</code></pre><p>A quadratic smoothness regularizer for a trajectory component.</p><p>Fields:     <code>name</code>: the name of the trajectory component to regularize     <code>times</code>: the times at which to evaluate the regularizer     <code>R</code>: the regularization matrix     <code>eval_hessian</code>: whether to evaluate the Hessian of the regularizer</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kestrelquantum/QuantumCollocation.jl/blob/46a6f190494a3bc0567a257783e5891db6970f13/src/objectives/regularizer_objective.jl#L184-L194">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumCollocation.Objectives.QuantumObjective-Tuple{}" href="#QuantumCollocation.Objectives.QuantumObjective-Tuple{}"><code>QuantumCollocation.Objectives.QuantumObjective</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">QuantumObjective

A generic objective function for quantum trajectories that use a loss.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kestrelquantum/QuantumCollocation.jl/blob/46a6f190494a3bc0567a257783e5891db6970f13/src/objectives/quantum_objective.jl#L9-L14">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumCollocation.Objectives.UnitaryFreePhaseInfidelityObjective-Union{Tuple{}, Tuple{R}} where R&lt;:Real" href="#QuantumCollocation.Objectives.UnitaryFreePhaseInfidelityObjective-Union{Tuple{}, Tuple{R}} where R&lt;:Real"><code>QuantumCollocation.Objectives.UnitaryFreePhaseInfidelityObjective</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">UnitaryFreePhaseInfidelityObjective</code></pre><p>A type of objective that measures the infidelity of a unitary operator to a target unitary operator, where the target unitary operator is allowed to have phases on qubit subspaces.</p><p>Fields:     <code>name</code>: the name of the unitary operator in the trajectory     <code>global_name</code>: the name of the global phase in the trajectory     <code>goal</code>: the target unitary operator     <code>Q</code>: a scaling factor     <code>eval_hessian</code>: whether to evaluate the Hessian     <code>subspace</code>: the subspace in which to evaluate the objective</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kestrelquantum/QuantumCollocation.jl/blob/46a6f190494a3bc0567a257783e5891db6970f13/src/objectives/unitary_infidelity_objective.jl#L105-L119">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumCollocation.Objectives.UnitaryInfidelityObjective-Tuple{}" href="#QuantumCollocation.Objectives.UnitaryInfidelityObjective-Tuple{}"><code>QuantumCollocation.Objectives.UnitaryInfidelityObjective</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">UnitaryInfidelityObjective</code></pre><p>A type of objective that measures the infidelity of a unitary operator to a target unitary operator.</p><p>Fields:     <code>name</code>: the name of the unitary operator in the trajectory     <code>goal</code>: the target unitary operator     <code>Q</code>: a scaling factor     <code>eval_hessian</code>: whether to evaluate the Hessian     <code>subspace</code>: the subspace in which to evaluate the objective</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kestrelquantum/QuantumCollocation.jl/blob/46a6f190494a3bc0567a257783e5891db6970f13/src/objectives/unitary_infidelity_objective.jl#L8-L20">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumCollocation.Objectives.UnitaryRobustnessObjective-Tuple{}" href="#QuantumCollocation.Objectives.UnitaryRobustnessObjective-Tuple{}"><code>QuantumCollocation.Objectives.UnitaryRobustnessObjective</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>UnitaryRobustnessObjective(;     H::::Union{OperatorType, Nothing}=nothing,     eval_hessian::Bool=false,     symb::Symbol=:Ũ⃗ )</p><p>Create a control objective which penalizes the sensitivity of the infidelity to the provided operator defined in the subspace of the control dynamics, thereby realizing robust control.</p><p>The control dynamics are</p><p class="math-container">\[U_C(a)= \prod_t \exp{-i H_C(a_t)}\]</p><p>In the control frame, the H operator is (proportional to)</p><p class="math-container">\[R_{Robust}(a) = \frac{1}{T \norm{H_e}_2} \sum_t U_C(a_t)^\dag H_e U_C(a_t) \Delta t\]</p><p>where we have adjusted to a unitless expression of the operator.</p><p>The robustness objective is</p><p class="math-container">\[R_{Robust}(a) = \frac{1}{N} \norm{R}^2_F\]</p><p>where N is the dimension of the Hilbert space.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kestrelquantum/QuantumCollocation.jl/blob/46a6f190494a3bc0567a257783e5891db6970f13/src/objectives/unitary_robustness_objective.jl#L8-L34">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumCollocation.Objectives.sparse_to_moi-Tuple{SparseArrays.SparseMatrixCSC}" href="#QuantumCollocation.Objectives.sparse_to_moi-Tuple{SparseArrays.SparseMatrixCSC}"><code>QuantumCollocation.Objectives.sparse_to_moi</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sparse_to_moi(A::SparseMatrixCSC)</code></pre><p>Converts a sparse matrix to tuple of vector of nonzero indices and vector of nonzero values</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kestrelquantum/QuantumCollocation.jl/blob/46a6f190494a3bc0567a257783e5891db6970f13/src/objectives/_objectives.jl#L29-L33">source</a></section></article><h2 id="Losses"><a class="docs-heading-anchor" href="#Losses">Losses</a><a id="Losses-1"></a><a class="docs-heading-anchor-permalink" href="#Losses" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumCollocation.Losses.fidelity-Tuple{AbstractVector, AbstractVector}" href="#QuantumCollocation.Losses.fidelity-Tuple{AbstractVector, AbstractVector}"><code>QuantumCollocation.Losses.fidelity</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">fidelity(ψ, ψ_goal)</code></pre><p>Calculate the fidelity between two quantum states <code>ψ</code> and <code>ψ_goal</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kestrelquantum/QuantumCollocation.jl/blob/46a6f190494a3bc0567a257783e5891db6970f13/src/losses/quantum_state_infidelity_loss.jl#L10-L14">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumCollocation.Losses.iso_fidelity-Tuple{AbstractVector, AbstractVector}" href="#QuantumCollocation.Losses.iso_fidelity-Tuple{AbstractVector, AbstractVector}"><code>QuantumCollocation.Losses.iso_fidelity</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">iso_fidelity(ψ̃, ψ̃_goal)</code></pre><p>Calculate the fidelity between two quantum states in their isomorphic form <code>ψ̃</code> and <code>ψ̃_goal</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kestrelquantum/QuantumCollocation.jl/blob/46a6f190494a3bc0567a257783e5891db6970f13/src/losses/quantum_state_infidelity_loss.jl#L25-L29">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumCollocation.Losses.iso_infidelity" href="#QuantumCollocation.Losses.iso_infidelity"><code>QuantumCollocation.Losses.iso_infidelity</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">iso_infidelity(ψ̃, ψ̃goal)</code></pre><p>Returns the iso_infidelity between two quantum statevectors specified in the <span>$\mathbb{C}^n \to \mathbb{R}^{2n}$</span> isomorphism space.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kestrelquantum/QuantumCollocation.jl/blob/46a6f190494a3bc0567a257783e5891db6970f13/src/losses/quantum_state_infidelity_loss.jl#L40-L46">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumCollocation.Losses.iso_vec_unitary_fidelity-Tuple{AbstractVector, AbstractVector}" href="#QuantumCollocation.Losses.iso_vec_unitary_fidelity-Tuple{AbstractVector, AbstractVector}"><code>QuantumCollocation.Losses.iso_vec_unitary_fidelity</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">iso_vec_unitary_fidelity(Ũ⃗::AbstractVector, Ũ⃗_goal::AbstractVector)</code></pre><p>Returns the fidelity between the isomorphic unitary vector <span>$\vec{\widetilde{U}} \sim U \in SU(n)$</span> and the isomorphic goal unitary vector <span>$\vec{\widetilde{U}}_{\text{goal}}$</span>.</p><p class="math-container">\[\begin{aligned}
\mathcal{F}(\vec{\widetilde{U}}, \vec{\widetilde{U}}_{\text{goal}}) &amp;= \frac{1}{n} \abs{\tr \qty(U_{\text{goal}}^\dagger U)} \\
&amp;= \frac{1}{n} \sqrt{T_R^{2} + T_I^{2}}
\end{aligned}\]</p><p>where <span>$T_R = \langle \vec{\widetilde{U}}_{\text{goal}, R}, \vec{\widetilde{U}}_R \rangle + \langle \vec{\widetilde{U}}_{\text{goal}, I}, \vec{\widetilde{U}}_I \rangle$</span> and <span>$T_I = \langle \vec{\widetilde{U}}_{\text{goal}, R}, \vec{\widetilde{U}}_I \rangle - \langle \vec{\widetilde{U}}_{\text{goal}, I}, \vec{\widetilde{U}}_R \rangle$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kestrelquantum/QuantumCollocation.jl/blob/46a6f190494a3bc0567a257783e5891db6970f13/src/losses/unitary_infidelity_loss.jl#L42-L57">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumCollocation.Losses.unitary_fidelity-Tuple{Matrix, Matrix}" href="#QuantumCollocation.Losses.unitary_fidelity-Tuple{Matrix, Matrix}"><code>QuantumCollocation.Losses.unitary_fidelity</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">unitary_fidelity(U::Matrix, U_goal::Matrix; kwargs...)
unitary_fidelity(Ũ⃗::AbstractVector, Ũ⃗_goal::AbstractVector; kwargs...)</code></pre><p>Calculate the fidelity between two unitary operators <code>U</code> and <code>U_goal</code>.</p><p class="math-container">\[\mathcal{F}(U, U_{\text{goal}}) = \frac{1}{n} \abs{\tr \qty(U_{\text{goal}}^\dagger U)}\]</p><p>where <span>$n$</span> is the dimension of the unitary operators.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>subspace::AbstractVector{Int}</code>: The subspace to calculate the fidelity over.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kestrelquantum/QuantumCollocation.jl/blob/46a6f190494a3bc0567a257783e5891db6970f13/src/losses/unitary_infidelity_loss.jl#L13-L27">source</a></section></article><h2 id="Embedded-Operators"><a class="docs-heading-anchor" href="#Embedded-Operators">Embedded Operators</a><a id="Embedded-Operators-1"></a><a class="docs-heading-anchor-permalink" href="#Embedded-Operators" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumCollocation.EmbeddedOperators.EmbeddedOperator-Tuple{Matrix{&lt;:Number}, AbstractVector{Int64}, AbstractVector{Int64}}" href="#QuantumCollocation.EmbeddedOperators.EmbeddedOperator-Tuple{Matrix{&lt;:Number}, AbstractVector{Int64}, AbstractVector{Int64}}"><code>QuantumCollocation.EmbeddedOperators.EmbeddedOperator</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">EmbeddedOperator(op::Matrix{&lt;:Number}, subspace_indices::AbstractVector{Int}, subsystem_levels::AbstractVector{Int})</code></pre><p>Create an embedded operator. The operator <code>op</code> is embedded in the subspace defined by <code>subspace_indices</code> in <code>subsystem_levels</code>.</p><p><strong>Arguments</strong></p><ul><li><code>op::Matrix{&lt;:Number}</code>: Operator to embed.</li><li><code>subspace_indices::AbstractVector{Int}</code>: Indices of the subspace to embed the operator in. e.g. <code>get_subspace_indices([1:2, 1:2], [3, 3])</code>.</li><li><code>subsystem_levels::AbstractVector{Int}</code>: Levels of the subsystems in the composite system. e.g. <code>[3, 3]</code> for two 3-level systems.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kestrelquantum/QuantumCollocation.jl/blob/46a6f190494a3bc0567a257783e5891db6970f13/src/embedded_operators.jl#L76-L85">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumCollocation.EmbeddedOperators.embed-Tuple{Matrix{ComplexF64}, AbstractVector{Int64}, Int64}" href="#QuantumCollocation.EmbeddedOperators.embed-Tuple{Matrix{ComplexF64}, AbstractVector{Int64}, Int64}"><code>QuantumCollocation.EmbeddedOperators.embed</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">embed(matrix::Matrix{ComplexF64}, subspace_indices::AbstractVector{Int}, levels::Int)</code></pre><p>Embed an operator <span>$U$</span> in the subspace of a larger system <span>$\mathcal{X} = \mathcal{X}_{\text{subspace}} \oplus \mathcal{X}_{\text{leakage}}$</span> which is composed of matrices of size <span>$\text{levels} \times \text{levels}$</span>.</p><p><strong>Arguments</strong></p><ul><li><code>matrix::Matrix{ComplexF64}</code>: Operator to embed.</li><li><code>subspace_indices::AbstractVector{Int}</code>: Indices of the subspace to embed the operator in.</li><li><code>levels::Int</code>: Total number of levels in the system.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kestrelquantum/QuantumCollocation.jl/blob/46a6f190494a3bc0567a257783e5891db6970f13/src/embedded_operators.jl#L25-L34">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumCollocation.EmbeddedOperators.get_subspace_indices-Tuple{Vector{&lt;:AbstractVector{Int64}}, AbstractVector{Int64}}" href="#QuantumCollocation.EmbeddedOperators.get_subspace_indices-Tuple{Vector{&lt;:AbstractVector{Int64}}, AbstractVector{Int64}}"><code>QuantumCollocation.EmbeddedOperators.get_subspace_indices</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_subspace_indices(subspaces::Vector{&lt;:AbstractVector{Int}}, subsystem_levels::AbstractVector{Int})</code></pre><p>Get the indices for the subspace of composite quantum system.</p><p>Example: for the two-qubit subspace of two 3-level systems:</p><pre><code class="language-julia hljs">subspaces = [1:2, 1:2]
subsystem_levels = [3, 3]
get_subspace_indices(subspaces, subsystem_levels) == [1, 2, 4, 5]</code></pre><p><strong>Arguments</strong></p><ul><li><code>subspaces::Vector{&lt;:AbstractVector{Int}}</code>: Subspaces to get indices for. e.g. <code>[1:2, 1:2]</code>.</li><li><code>subsystem_levels::AbstractVector{Int}</code>: Levels of the subsystems in the composite system. e.g. <code>[3, 3]</code>. Each element corresponds to a subsystem.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kestrelquantum/QuantumCollocation.jl/blob/46a6f190494a3bc0567a257783e5891db6970f13/src/embedded_operators.jl#L224-L240">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumCollocation.EmbeddedOperators.unembed-Tuple{AbstractMatrix, AbstractVector{Int64}}" href="#QuantumCollocation.EmbeddedOperators.unembed-Tuple{AbstractMatrix, AbstractVector{Int64}}"><code>QuantumCollocation.EmbeddedOperators.unembed</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">unembed(matrix::AbstractMatrix, subspace_indices::AbstractVector{Int})</code></pre><p>Unembed an operator <span>$U$</span> from a subspace of a larger system <span>$\mathcal{X} = \mathcal{X}_{\text{subspace}} \oplus \mathcal{X}_{\text{leakage}}$</span> which is composed of matrices of size <span>$\text{levels} \times \text{levels}$</span>.</p><p>This is equivalent to calling <code>matrix[subspace_indices, subspace_indices]</code>.</p><p><strong>Arguments</strong></p><ul><li><code>matrix::AbstractMatrix</code>: Operator to unembed.</li><li><code>subspace_indices::AbstractVector{Int}</code>: Indices of the subspace to unembed the operator from.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kestrelquantum/QuantumCollocation.jl/blob/46a6f190494a3bc0567a257783e5891db6970f13/src/embedded_operators.jl#L42-L52">source</a></section></article><h2 id="Isomorphisms"><a class="docs-heading-anchor" href="#Isomorphisms">Isomorphisms</a><a id="Isomorphisms-1"></a><a class="docs-heading-anchor-permalink" href="#Isomorphisms" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumCollocation.Isomorphisms.G-Tuple{AbstractMatrix{&lt;:Number}}" href="#QuantumCollocation.Isomorphisms.G-Tuple{AbstractMatrix{&lt;:Number}}"><code>QuantumCollocation.Isomorphisms.G</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">G(H::AbstractMatrix)::Matrix{Float64}</code></pre><p>Returns the isomorphism of <span>$-iH$</span>:</p><p class="math-container">\[G(H) = \widetilde{- i H} = \mqty(1 &amp; 0 \\ 0 &amp; 1) \otimes \Im(H) - \mqty(0 &amp; -1 \\ 1 &amp; 0) \otimes \Re(H)\]</p><p>where <span>$\Im(H)$</span> and <span>$\Re(H)$</span> are the imaginary and real parts of <span>$H$</span> and the tilde indicates the standard isomorphism of a complex valued matrix:</p><p class="math-container">\[\widetilde{H} = \mqty(1 &amp; 0 \\ 0 &amp; 1) \otimes \Re(H) + \mqty(0 &amp; -1 \\ 1 &amp; 0) \otimes \Im(H)\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kestrelquantum/QuantumCollocation.jl/blob/46a6f190494a3bc0567a257783e5891db6970f13/src/isomorphisms.jl#L175-L189">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumCollocation.Isomorphisms.H-Tuple{AbstractMatrix{&lt;:Number}}" href="#QuantumCollocation.Isomorphisms.H-Tuple{AbstractMatrix{&lt;:Number}}"><code>QuantumCollocation.Isomorphisms.H</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">H(G::AbstractMatrix{&lt;:Number})::Matrix{ComplexF64}</code></pre><p>Returns the inverse of <code>G(H) = iso(-iH)</code>, i.e. returns H</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kestrelquantum/QuantumCollocation.jl/blob/46a6f190494a3bc0567a257783e5891db6970f13/src/isomorphisms.jl#L195-L200">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumCollocation.Isomorphisms.iso_dm-Tuple{AbstractMatrix}" href="#QuantumCollocation.Isomorphisms.iso_dm-Tuple{AbstractMatrix}"><code>QuantumCollocation.Isomorphisms.iso_dm</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">iso_dm(ρ::AbstractMatrix)</code></pre><p>returns the isomorphism <code>ρ⃗̃ = ket_to_iso(vec(ρ))</code> of a density matrix <code>ρ</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kestrelquantum/QuantumCollocation.jl/blob/46a6f190494a3bc0567a257783e5891db6970f13/src/isomorphisms.jl#L208-L212">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumCollocation.Isomorphisms.iso_operator_to_iso_vec-Union{Tuple{AbstractMatrix{R}}, Tuple{R}} where R" href="#QuantumCollocation.Isomorphisms.iso_operator_to_iso_vec-Union{Tuple{AbstractMatrix{R}}, Tuple{R}} where R"><code>QuantumCollocation.Isomorphisms.iso_operator_to_iso_vec</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">iso_operator_to_iso_vec(Ũ::AbstractMatrix)</code></pre><p>Convert a real matrix <code>Ũ</code> representing an isomorphism operator into a real vector.</p><p>Must be differentiable.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kestrelquantum/QuantumCollocation.jl/blob/46a6f190494a3bc0567a257783e5891db6970f13/src/isomorphisms.jl#L137-L143">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumCollocation.Isomorphisms.iso_to_ket-Tuple{Any}" href="#QuantumCollocation.Isomorphisms.iso_to_ket-Tuple{Any}"><code>QuantumCollocation.Isomorphisms.iso_to_ket</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">iso_to_ket(ψ̃)</code></pre><p>Convert a complex vector <code>ψ̃</code> with real and imaginary parts into a ket vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kestrelquantum/QuantumCollocation.jl/blob/46a6f190494a3bc0567a257783e5891db6970f13/src/isomorphisms.jl#L43-L47">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumCollocation.Isomorphisms.iso_vec_to_iso_operator-Union{Tuple{AbstractVector{R}}, Tuple{R}} where R" href="#QuantumCollocation.Isomorphisms.iso_vec_to_iso_operator-Union{Tuple{AbstractVector{R}}, Tuple{R}} where R"><code>QuantumCollocation.Isomorphisms.iso_vec_to_iso_operator</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">iso_vec_to_iso_operator(Ũ⃗::AbstractVector)</code></pre><p>Convert a real vector <code>Ũ⃗</code> into a real matrix representing an isomorphism operator.</p><p>Must be differentiable.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kestrelquantum/QuantumCollocation.jl/blob/46a6f190494a3bc0567a257783e5891db6970f13/src/isomorphisms.jl#L84-L90">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumCollocation.Isomorphisms.iso_vec_to_operator-Union{Tuple{AbstractVector{R}}, Tuple{R}} where R" href="#QuantumCollocation.Isomorphisms.iso_vec_to_operator-Union{Tuple{AbstractVector{R}}, Tuple{R}} where R"><code>QuantumCollocation.Isomorphisms.iso_vec_to_operator</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">iso_vec_to_operator(Ũ⃗::AbstractVector)</code></pre><p>Convert a real vector <code>Ũ⃗</code> into a complex matrix representing an operator.</p><p>Must be differentiable.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kestrelquantum/QuantumCollocation.jl/blob/46a6f190494a3bc0567a257783e5891db6970f13/src/isomorphisms.jl#L54-L60">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumCollocation.Isomorphisms.ket_to_iso-Tuple{Any}" href="#QuantumCollocation.Isomorphisms.ket_to_iso-Tuple{Any}"><code>QuantumCollocation.Isomorphisms.ket_to_iso</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ket_to_iso(ψ)</code></pre><p>Convert a ket vector <code>ψ</code> into a complex vector with real and imaginary parts.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kestrelquantum/QuantumCollocation.jl/blob/46a6f190494a3bc0567a257783e5891db6970f13/src/isomorphisms.jl#L36-L40">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumCollocation.Isomorphisms.mat-Tuple{AbstractVector}" href="#QuantumCollocation.Isomorphisms.mat-Tuple{AbstractVector}"><code>QuantumCollocation.Isomorphisms.mat</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">mat(x::AbstractVector)</code></pre><p>Convert a vector <code>x</code> into a square matrix. The length of <code>x</code> must be a perfect square.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kestrelquantum/QuantumCollocation.jl/blob/46a6f190494a3bc0567a257783e5891db6970f13/src/isomorphisms.jl#L20-L24">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumCollocation.Isomorphisms.operator_to_iso_vec-Union{Tuple{AbstractMatrix{R}}, Tuple{R}} where R" href="#QuantumCollocation.Isomorphisms.operator_to_iso_vec-Union{Tuple{AbstractMatrix{R}}, Tuple{R}} where R"><code>QuantumCollocation.Isomorphisms.operator_to_iso_vec</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">operator_to_iso_vec(U::AbstractMatrix{&lt;:Complex})</code></pre><p>Convert a complex matrix <code>U</code> representing an operator into a real vector.</p><p>Must be differentiable.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kestrelquantum/QuantumCollocation.jl/blob/46a6f190494a3bc0567a257783e5891db6970f13/src/isomorphisms.jl#L107-L113">source</a></section></article><h2 id="Options"><a class="docs-heading-anchor" href="#Options">Options</a><a id="Options-1"></a><a class="docs-heading-anchor-permalink" href="#Options" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumCollocation.Options.IpoptOptions" href="#QuantumCollocation.Options.IpoptOptions"><code>QuantumCollocation.Options.IpoptOptions</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Solver options for Ipopt

https://coin-or.github.io/Ipopt/OPTIONS.html#OPT_print_options_documentation</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kestrelquantum/QuantumCollocation.jl/blob/46a6f190494a3bc0567a257783e5891db6970f13/src/options.jl#L14-L18">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumCollocation.Options.PiccoloOptions" href="#QuantumCollocation.Options.PiccoloOptions"><code>QuantumCollocation.Options.PiccoloOptions</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">PiccoloOptions</code></pre><p>Options for the Piccolo quantum optimal control library.</p><p><strong>Fields</strong></p><ul><li><code>verbose::Bool = true</code>: Print verbose output</li><li><code>verbose_evaluator::Bool = false</code>: Print verbose output from the evaluator</li><li><code>free_time::Bool = true</code>: Allow free time optimization</li><li><code>timesteps_all_equal::Bool = true</code>: Use equal timesteps</li><li><code>integrator::Symbol = :pade</code>: Integrator to use</li><li><code>pade_order::Int = 4</code>: Order of the Pade approximation</li><li><code>rollout_integrator::Function = expv</code>: Integrator to use for rollout</li><li><code>jacobian_structure::Bool = integrator == :pade</code>: Use the integrator&#39;s Jacobian structure</li><li><code>eval_hessian::Bool = false</code>: Evaluate the Hessian</li><li><code>geodesic = true</code>: Use the geodesic to initialize the optimization.</li><li><code>blas_multithreading::Bool = true</code>: Use BLAS multithreading.</li><li><code>build_trajectory_constraints::Bool = true</code>: Build trajectory constraints.</li><li><code>complex_control_norm_constraint_name::Union{Nothing, Symbol} = nothing</code>: Name of the complex control norm constraint.</li><li><code>complex_control_norm_constraint_radius::Float64 = 1.0</code>: Radius of the complex control norm constraint.</li><li><code>bound_state::Bool = false</code>: Bound the state.</li><li><code>leakage_suppression::Bool = false</code>: Suppress leakage.</li><li><code>R_leakage::Float64 = 1.0</code>: Leakage suppression parameter.</li><li><code>free_phase_infidelity::Bool = false</code>: Free phase infidelity.</li><li><code>phase_operators::Union{Nothing, AbstractVector{&lt;:AbstractMatrix{&lt;:Complex}}} = nothing</code>: Phase operators.</li><li><code>phase_name::Symbol = :ϕ</code>: Name of the phase.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kestrelquantum/QuantumCollocation.jl/blob/46a6f190494a3bc0567a257783e5891db6970f13/src/options.jl#L57-L83">source</a></section></article><h2 id="Plotting"><a class="docs-heading-anchor" href="#Plotting">Plotting</a><a id="Plotting-1"></a><a class="docs-heading-anchor-permalink" href="#Plotting" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumCollocation.Plotting.plot_unitary_populations" href="#QuantumCollocation.Plotting.plot_unitary_populations"><code>QuantumCollocation.Plotting.plot_unitary_populations</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">plot_unitary_populations(
    traj::NamedTrajectory;
    unitary_columns::AbstractVector{Int}=1:2,
    unitary_name::Symbol=:Ũ⃗,
    control_name::Symbol=:a,
    kwargs...
)

plot_unitary_populations(
    prob::QuantumControlProblem;
    kwargs...
)</code></pre><p>Plot the populations of the unitary columns of the unitary matrix in the trajectory. <code>kwargs</code> are passed to <a href="https://aarontrowbridge.github.io/NamedTrajectories.jl/dev/generated/plotting/"><code>NamedTrajectories.plot</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kestrelquantum/QuantumCollocation.jl/blob/46a6f190494a3bc0567a257783e5891db6970f13/src/plotting.jl#L19-L34">source</a></section></article><h2 id="Problem-Solvers"><a class="docs-heading-anchor" href="#Problem-Solvers">Problem Solvers</a><a id="Problem-Solvers-1"></a><a class="docs-heading-anchor-permalink" href="#Problem-Solvers" title="Permalink"></a></h2><h2 id="Rollouts"><a class="docs-heading-anchor" href="#Rollouts">Rollouts</a><a id="Rollouts-1"></a><a class="docs-heading-anchor-permalink" href="#Rollouts" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumCollocation.Losses.iso_vec_unitary_fidelity-Tuple{AbstractVector{&lt;:Real}, AbstractVector{&lt;:Real}, AbstractMatrix, AbstractVector, AbstractQuantumSystem}" href="#QuantumCollocation.Losses.iso_vec_unitary_fidelity-Tuple{AbstractVector{&lt;:Real}, AbstractVector{&lt;:Real}, AbstractMatrix, AbstractVector, AbstractQuantumSystem}"><code>QuantumCollocation.Losses.iso_vec_unitary_fidelity</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Compute the rollout fidelity.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kestrelquantum/QuantumCollocation.jl/blob/46a6f190494a3bc0567a257783e5891db6970f13/src/rollouts.jl#L278-L280">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumCollocation.Rollouts.infer_is_evp-Tuple{Function}" href="#QuantumCollocation.Rollouts.infer_is_evp-Tuple{Function}"><code>QuantumCollocation.Rollouts.infer_is_evp</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">infer_is_evp(integrator::Function)</code></pre><p>Infer whether the integrator is a exponential-vector product (EVP) function.</p><p>If <code>true</code>, the integrator is expected to have a signature like the exponential action, <code>expv</code>. Otherwise, it is expected to have a signature like <code>exp</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kestrelquantum/QuantumCollocation.jl/blob/46a6f190494a3bc0567a257783e5891db6970f13/src/rollouts.jl#L29-L36">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumCollocation.Rollouts.lab_frame_unitary_rollout-Tuple{AbstractQuantumSystem, AbstractMatrix{Float64}}" href="#QuantumCollocation.Rollouts.lab_frame_unitary_rollout-Tuple{AbstractQuantumSystem, AbstractMatrix{Float64}}"><code>QuantumCollocation.Rollouts.lab_frame_unitary_rollout</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">lab_frame_unitary_rollout(
    sys::AbstractQuantumSystem,
    controls::AbstractMatrix{Float64};
    duration=nothing,
    timestep=nothing,
    ω=nothing,
    timestep_nyquist=1 / (50 * ω)
)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kestrelquantum/QuantumCollocation.jl/blob/46a6f190494a3bc0567a257783e5891db6970f13/src/rollouts.jl#L372-L381">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumCollocation.Rollouts.rollout-Tuple{AbstractVector{&lt;:Real}, AbstractMatrix, AbstractVector, AbstractQuantumSystem}" href="#QuantumCollocation.Rollouts.rollout-Tuple{AbstractVector{&lt;:Real}, AbstractMatrix, AbstractVector, AbstractQuantumSystem}"><code>QuantumCollocation.Rollouts.rollout</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">rollout(
    ψ̃_init::AbstractVector{&lt;:Float64},
    controls::AbstractMatrix,
    Δt::AbstractVector,
    system::AbstractQuantumSystem
)</code></pre><p>Rollout a quantum state <code>ψ̃_init</code> under the control <code>controls</code> for a time <code>Δt</code> using the system <code>system</code>.</p><p>If <code>exp_vector_product</code> is <code>true</code>, the integrator is expected to have a signature like the exponential action, <code>expv</code>. Otherwise, it is expected to have a signature like <code>exp</code>.</p><p>Types should allow for autodifferentiable controls and times.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kestrelquantum/QuantumCollocation.jl/blob/46a6f190494a3bc0567a257783e5891db6970f13/src/rollouts.jl#L57-L72">source</a></section></article><h2 id="Saving-and-Loading"><a class="docs-heading-anchor" href="#Saving-and-Loading">Saving and Loading</a><a id="Saving-and-Loading-1"></a><a class="docs-heading-anchor-permalink" href="#Saving-and-Loading" title="Permalink"></a></h2><h2 id="Structure-Utils"><a class="docs-heading-anchor" href="#Structure-Utils">Structure Utils</a><a id="Structure-Utils-1"></a><a class="docs-heading-anchor-permalink" href="#Structure-Utils" title="Permalink"></a></h2><h2 id="Trajectory-Initialization"><a class="docs-heading-anchor" href="#Trajectory-Initialization">Trajectory Initialization</a><a id="Trajectory-Initialization-1"></a><a class="docs-heading-anchor-permalink" href="#Trajectory-Initialization" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumCollocation.TrajectoryInitialization.initialize_quantum_states-Tuple{AbstractVector{&lt;:AbstractVector{Float64}}, AbstractVector{&lt;:AbstractVector{Float64}}, Int64, AbstractVector{&lt;:Real}}" href="#QuantumCollocation.TrajectoryInitialization.initialize_quantum_states-Tuple{AbstractVector{&lt;:AbstractVector{Float64}}, AbstractVector{&lt;:AbstractVector{Float64}}, Int64, AbstractVector{&lt;:Real}}"><code>QuantumCollocation.TrajectoryInitialization.initialize_quantum_states</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">initialize_quantum_states</code></pre><p>Initialize the quantum states for a single set of parameters.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kestrelquantum/QuantumCollocation.jl/blob/46a6f190494a3bc0567a257783e5891db6970f13/src/trajectory_initialization.jl#L501-L505">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumCollocation.TrajectoryInitialization.initialize_trajectory-Tuple{AbstractVector{&lt;:AbstractVector{ComplexF64}}, AbstractVector{&lt;:AbstractVector{ComplexF64}}, Int64, Union{Real, AbstractVector{&lt;:Real}}, Vararg{Any}}" href="#QuantumCollocation.TrajectoryInitialization.initialize_trajectory-Tuple{AbstractVector{&lt;:AbstractVector{ComplexF64}}, AbstractVector{&lt;:AbstractVector{ComplexF64}}, Int64, Union{Real, AbstractVector{&lt;:Real}}, Vararg{Any}}"><code>QuantumCollocation.TrajectoryInitialization.initialize_trajectory</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">initialize_trajectory</code></pre><p>Trajectory initialization of quantum states can broadcast over multiple systems.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kestrelquantum/QuantumCollocation.jl/blob/46a6f190494a3bc0567a257783e5891db6970f13/src/trajectory_initialization.jl#L534-L538">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumCollocation.TrajectoryInitialization.initialize_trajectory-Tuple{OperatorType, Int64, Union{Real, AbstractVecOrMat{&lt;:Real}}, Vararg{Any}}" href="#QuantumCollocation.TrajectoryInitialization.initialize_trajectory-Tuple{OperatorType, Int64, Union{Real, AbstractVecOrMat{&lt;:Real}}, Vararg{Any}}"><code>QuantumCollocation.TrajectoryInitialization.initialize_trajectory</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">initialize_trajectory</code></pre><p>Trajectory initialization of unitary states can broadcast over multiple systems.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kestrelquantum/QuantumCollocation.jl/blob/46a6f190494a3bc0567a257783e5891db6970f13/src/trajectory_initialization.jl#L413-L417">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumCollocation.TrajectoryInitialization.initialize_trajectory-Tuple{Vector{&lt;:AbstractMatrix{Float64}}, Vector{&lt;:AbstractVector{Float64}}, Vector{&lt;:AbstractVector{Float64}}, AbstractVector{Symbol}, Int64, Union{Float64, AbstractVecOrMat{&lt;:Float64}}, Int64, Tuple{Vararg{Union{Tuple{AbstractVector{R}, AbstractVector{R}}, AbstractVector{R}} where R&lt;:Real}}}" href="#QuantumCollocation.TrajectoryInitialization.initialize_trajectory-Tuple{Vector{&lt;:AbstractMatrix{Float64}}, Vector{&lt;:AbstractVector{Float64}}, Vector{&lt;:AbstractVector{Float64}}, AbstractVector{Symbol}, Int64, Union{Float64, AbstractVecOrMat{&lt;:Float64}}, Int64, Tuple{Vararg{Union{Tuple{AbstractVector{R}, AbstractVector{R}}, AbstractVector{R}} where R&lt;:Real}}}"><code>QuantumCollocation.TrajectoryInitialization.initialize_trajectory</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">initialize_trajectory</code></pre><p>Initialize a trajectory for a control problem. The trajectory is initialized with data that should be consistently the same type (in this case, Float64).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kestrelquantum/QuantumCollocation.jl/blob/46a6f190494a3bc0567a257783e5891db6970f13/src/trajectory_initialization.jl#L254-L261">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumCollocation.TrajectoryInitialization.initialize_unitaries-Tuple{OperatorType, Int64, AbstractVector{&lt;:Real}}" href="#QuantumCollocation.TrajectoryInitialization.initialize_unitaries-Tuple{OperatorType, Int64, AbstractVector{&lt;:Real}}"><code>QuantumCollocation.TrajectoryInitialization.initialize_unitaries</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Initialize the unitary states for a single set of parameters.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kestrelquantum/QuantumCollocation.jl/blob/46a6f190494a3bc0567a257783e5891db6970f13/src/trajectory_initialization.jl#L380-L383">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumCollocation.TrajectoryInitialization.unitary_geodesic" href="#QuantumCollocation.TrajectoryInitialization.unitary_geodesic"><code>QuantumCollocation.TrajectoryInitialization.unitary_geodesic</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">unitary_geodesic(
    operator::EmbeddedOperator,
    samples::Int;
    kwargs...
)

unitary_geodesic(
    U_goal::AbstractMatrix{&lt;:Number},
    samples::Int;
    kwargs...
)

unitary_geodesic(
    U₀::AbstractMatrix{&lt;:Number},
    U₁::AbstractMatrix{&lt;:Number},
    samples::Number;
    kwargs...
)

unitary_geodesic(
    U₀::AbstractMatrix{&lt;:Number},
    U₁::AbstractMatrix{&lt;:Number},
    timesteps::AbstractVector{&lt;:Number};
    return_generator=false
)</code></pre><p>Compute a geodesic connecting two unitary operators.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kestrelquantum/QuantumCollocation.jl/blob/46a6f190494a3bc0567a257783e5891db6970f13/src/trajectory_initialization.jl#L57-L85">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumCollocation.TrajectoryInitialization.unitary_geodesic-Tuple{AbstractMatrix{&lt;:Number}, AbstractMatrix{&lt;:Number}, AbstractVector{&lt;:Number}}" href="#QuantumCollocation.TrajectoryInitialization.unitary_geodesic-Tuple{AbstractMatrix{&lt;:Number}, AbstractMatrix{&lt;:Number}, AbstractVector{&lt;:Number}}"><code>QuantumCollocation.TrajectoryInitialization.unitary_geodesic</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">unitary_geodesic(U_init, U_goal, times; kwargs...)</code></pre><p>Compute the geodesic connecting U<em>init and U</em>goal at the specified times. Allows for the possibility of unequal times and ranges outside [0,1].</p><p><strong>Arguments</strong></p><ul><li><code>U_init::AbstractMatrix{&lt;:Number}</code>: The initial unitary operator.</li><li><code>U_goal::AbstractMatrix{&lt;:Number}</code>: The goal unitary operator.</li><li><code>times::AbstractVector{&lt;:Number}</code>: The times at which to evaluate the geodesic.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>return_unitary_isos::Bool=true</code>: If true returns a matrix where each column is a unitary isovec, i.e. vec(vcat(real(U), imag(U))). If false, returns a vector of unitary matrices.</li><li><code>return_generator::Bool=false</code>: If true, returns the effective Hamiltonian generating the geodesic.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kestrelquantum/QuantumCollocation.jl/blob/46a6f190494a3bc0567a257783e5891db6970f13/src/trajectory_initialization.jl#L128-L141">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumCollocation.TrajectoryInitialization.unitary_linear_interpolation-Tuple{AbstractMatrix{&lt;:Number}, AbstractMatrix{&lt;:Number}, Int64}" href="#QuantumCollocation.TrajectoryInitialization.unitary_linear_interpolation-Tuple{AbstractMatrix{&lt;:Number}, AbstractMatrix{&lt;:Number}, Int64}"><code>QuantumCollocation.TrajectoryInitialization.unitary_linear_interpolation</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">unitary_linear_interpolation(
    U_init::AbstractMatrix,
    U_goal::AbstractMatrix,
    samples::Int
)</code></pre><p>Compute a linear interpolation of unitary operators with <code>samples</code> samples.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kestrelquantum/QuantumCollocation.jl/blob/46a6f190494a3bc0567a257783e5891db6970f13/src/trajectory_initialization.jl#L28-L36">source</a></section></article><h2 id="Trajectory-Interpolations"><a class="docs-heading-anchor" href="#Trajectory-Interpolations">Trajectory Interpolations</a><a id="Trajectory-Interpolations-1"></a><a class="docs-heading-anchor-permalink" href="#Trajectory-Interpolations" title="Permalink"></a></h2></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../generated/examples/multilevel_transmon/">« Multilevel Transmon</a><a class="docs-footer-nextpage" href="../release_notes/">Release Notes »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.7.0 on <span class="colophon-date" title="Saturday 9 November 2024 23:55">Saturday 9 November 2024</span>. Using Julia version 1.11.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
