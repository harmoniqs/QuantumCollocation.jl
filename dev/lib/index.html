<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Library · QuantumCollocation.jl</title><meta name="title" content="Library · QuantumCollocation.jl"/><meta property="og:title" content="Library · QuantumCollocation.jl"/><meta property="twitter:title" content="Library · QuantumCollocation.jl"/><meta name="description" content="Documentation for QuantumCollocation.jl."/><meta property="og:description" content="Documentation for QuantumCollocation.jl."/><meta property="twitter:description" content="Documentation for QuantumCollocation.jl."/><meta property="og:url" content="https://docs.harmoniqs.co/QuantumCollocation.jl/lib/"/><meta property="twitter:url" content="https://docs.harmoniqs.co/QuantumCollocation.jl/lib/"/><link rel="canonical" href="https://docs.harmoniqs.co/QuantumCollocation.jl/lib/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">QuantumCollocation.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Library</span><ul><li><a class="tocitem" href="../generated/man/ket_problem_templates/">Ket Problem Templates</a></li><li><a class="tocitem" href="../generated/man/unitary_problem_templates/">Unitary Problem Templates</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Library</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Library</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/harmoniqs/QuantumCollocation.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/harmoniqs/QuantumCollocation.jl/blob/main/docs/src/lib.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Library"><a class="docs-heading-anchor" href="#Library">Library</a><a id="Library-1"></a><a class="docs-heading-anchor-permalink" href="#Library" title="Permalink"></a></h1><h2 id="Problem-Templates"><a class="docs-heading-anchor" href="#Problem-Templates">Problem Templates</a><a id="Problem-Templates-1"></a><a class="docs-heading-anchor-permalink" href="#Problem-Templates" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumCollocation.ProblemTemplates.QuantumStateMinimumTimeProblem" href="#QuantumCollocation.ProblemTemplates.QuantumStateMinimumTimeProblem"><code>QuantumCollocation.ProblemTemplates.QuantumStateMinimumTimeProblem</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">QuantumStateMinimumTimeProblem(traj, sys, obj, integrators, constraints; kwargs...)
QuantumStateMinimumTimeProblem(prob; kwargs...)</code></pre><p>Construct a <code>DirectTrajOptProblem</code> for the minimum time problem of reaching a target state.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>state_name::Symbol=:ψ̃</code>: The symbol for the state variables.</li><li><code>final_fidelity::Union{Real, Nothing}=nothing</code>: The final fidelity.</li><li><code>D=1.0</code>: The cost weight on the time.</li><li><code>piccolo_options::PiccoloOptions=PiccoloOptions()</code>: The Piccolo options.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/QuantumCollocation.jl/blob/98a6ad8b8de2167576e77b6e32dbc8948198d2d8/src/problem_templates/quantum_state_minimum_time_problem.jl#L4-L15">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumCollocation.ProblemTemplates.QuantumStateSamplingProblem" href="#QuantumCollocation.ProblemTemplates.QuantumStateSamplingProblem"><code>QuantumCollocation.ProblemTemplates.QuantumStateSamplingProblem</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/QuantumCollocation.jl/blob/98a6ad8b8de2167576e77b6e32dbc8948198d2d8/src/problem_templates/quantum_state_sampling_problem.jl#L3-L5">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumCollocation.ProblemTemplates.QuantumStateSmoothPulseProblem" href="#QuantumCollocation.ProblemTemplates.QuantumStateSmoothPulseProblem"><code>QuantumCollocation.ProblemTemplates.QuantumStateSmoothPulseProblem</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">QuantumStateSmoothPulseProblem(system, ψ_inits, ψ_goals, T, Δt; kwargs...)
QuantumStateSmoothPulseProblem(system, ψ_init, ψ_goal, T, Δt; kwargs...)
QuantumStateSmoothPulseProblem(H_drift, H_drives, args...; kwargs...)</code></pre><p>Create a quantum state smooth pulse problem. The goal is to find a control pulse <code>a(t)</code>  that drives all of the initial states <code>ψ_inits</code> to the corresponding target states  <code>ψ_goals</code> using <code>T</code> timesteps of size <code>Δt</code>. This problem also controls the  first and  second derivatives of the control pulse, <code>da(t)</code> and <code>dda(t)</code>, to ensure smoothness.</p><p><strong>Arguments</strong></p><ul><li><code>system::AbstractQuantumSystem</code>: The quantum system.</li></ul><p>or</p><ul><li><code>H_drift::AbstractMatrix{&lt;:Number}</code>: The drift Hamiltonian.</li><li><code>H_drives::Vector{&lt;:AbstractMatrix{&lt;:Number}}</code>: The control Hamiltonians.</li></ul><p>with</p><ul><li><code>ψ_inits::Vector{&lt;:AbstractVector{&lt;:ComplexF64}}</code>: The initial states.</li><li><code>ψ_goals::Vector{&lt;:AbstractVector{&lt;:ComplexF64}}</code>: The target states.</li></ul><p>or</p><ul><li><code>ψ_init::AbstractVector{&lt;:ComplexF64}</code>: The initial state.</li><li><code>ψ_goal::AbstractVector{&lt;:ComplexF64}</code>: The target state.</li></ul><p>with</p><ul><li><code>T::Int</code>: The number of timesteps.</li><li><code>Δt::Float64</code>: The timestep size.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>state_name::Symbol=:ψ̃</code>: The name of the state variable.</li><li><code>control_name::Symbol=:a</code>: The name of the control variable.</li><li><code>timestep_name::Symbol=:Δt</code>: The name of the timestep variable.</li><li><code>init_trajectory::Union{NamedTrajectory, Nothing}=nothing</code>: The initial trajectory.</li><li><code>a_bound::Float64=1.0</code>: The bound on the control pulse.</li><li><code>a_bounds::Vector{Float64}=fill(a_bound, length(system.G_drives))</code>: The bounds on the control pulse.</li><li><code>a_guess::Union{Matrix{Float64}, Nothing}=nothing</code>: The initial guess for the control pulse.</li><li><code>da_bound::Float64=Inf</code>: The bound on the first derivative of the control pulse.</li><li><code>da_bounds::Vector{Float64}=fill(da_bound, length(system.G_drives))</code>: The bounds on the first derivative of the control pulse.</li><li><code>dda_bound::Float64=1.0</code>: The bound on the second derivative of the control pulse.</li><li><code>dda_bounds::Vector{Float64}=fill(dda_bound, length(system.G_drives))</code>: The bounds on the second derivative of the control pulse.</li><li><code>Δt_min::Float64=0.5 * Δt</code>: The minimum timestep size.</li><li><code>Δt_max::Float64=1.5 * Δt</code>: The maximum timestep size.</li><li><code>drive_derivative_σ::Float64=0.01</code>: The standard deviation of the drive derivative random initialization.</li><li><code>Q::Float64=100.0</code>: The weight on the state objective.</li><li><code>R=1e-2</code>: The weight on the control pulse and its derivatives.</li><li><code>R_a::Union{Float64, Vector{Float64}}=R</code>: The weight on the control pulse.</li><li><code>R_da::Union{Float64, Vector{Float64}}=R</code>: The weight on the first derivative of the control pulse.</li><li><code>R_dda::Union{Float64, Vector{Float64}}=R</code>: The weight on the second derivative of the control pulse.</li><li><code>constraints::Vector{&lt;:AbstractConstraint}=AbstractConstraint[]</code>: The constraints.</li><li><code>piccolo_options::PiccoloOptions=PiccoloOptions()</code>: The Piccolo options.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/QuantumCollocation.jl/blob/98a6ad8b8de2167576e77b6e32dbc8948198d2d8/src/problem_templates/quantum_state_smooth_pulse_problem.jl#L4-L52">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumCollocation.ProblemTemplates.UnitaryMinimumTimeProblem" href="#QuantumCollocation.ProblemTemplates.UnitaryMinimumTimeProblem"><code>QuantumCollocation.ProblemTemplates.UnitaryMinimumTimeProblem</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">UnitaryMinimumTimeProblem(
    goal::AbstractPiccoloOperator,
    trajectory::NamedTrajectory,
    objective::Objective,
    dynamics::TrajectoryDynamics,
    constraints::AbstractVector{&lt;:AbstractConstraint};
    kwargs...
)

UnitaryMinimumTimeProblem(
    goal::AbstractPiccoloOperator,
    prob::DirectTrajOptProblem;
    kwargs...
)</code></pre><p>Create a minimum-time problem for unitary control.</p><p class="math-container">\[\begin{aligned}
\underset{\vec{\tilde{U}}, a, \dot{a}, \ddot{a}, \Delta t}{\text{minimize}} &amp; \quad
J(\vec{\tilde{U}}, a, \dot{a}, \ddot{a}) + D \sum_t \Delta t_t \\
\text{ subject to } &amp; \quad \vb{P}^{(n)}\qty(\vec{\tilde{U}}_{t+1}, \vec{\tilde{U}}_t, a_t, \Delta t_t) = 0 \\
&amp; c(\vec{\tilde{U}}, a, \dot{a}, \ddot{a}) = 0 \\
&amp; \quad \Delta t_{\text{min}} \leq \Delta t_t \leq \Delta t_{\text{max}} \\
\end{aligned}\]</p><p><strong>Keyword Arguments</strong></p><ul><li><code>piccolo_options::PiccoloOptions=PiccoloOptions()</code>: The Piccolo options.</li><li><code>unitary_name::Symbol=:Ũ⃗</code>: The name of the unitary for the goal.</li><li><code>final_fidelity::Float64=1.0</code>: The final fidelity constraint.</li><li><code>D::Float64=1.0</code>: The scaling factor for the minimum-time objective.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/QuantumCollocation.jl/blob/98a6ad8b8de2167576e77b6e32dbc8948198d2d8/src/problem_templates/unitary_minimum_time_problem.jl#L4-L37">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumCollocation.ProblemTemplates.UnitarySamplingProblem-Tuple{AbstractVector{&lt;:PiccoloQuantumObjects.QuantumSystems.AbstractQuantumSystem}, AbstractVector{&lt;:PiccoloQuantumObjects.EmbeddedOperators.AbstractPiccoloOperator}, Int64, Union{Float64, Vector{Float64}}}" href="#QuantumCollocation.ProblemTemplates.UnitarySamplingProblem-Tuple{AbstractVector{&lt;:PiccoloQuantumObjects.QuantumSystems.AbstractQuantumSystem}, AbstractVector{&lt;:PiccoloQuantumObjects.EmbeddedOperators.AbstractPiccoloOperator}, Int64, Union{Float64, Vector{Float64}}}"><code>QuantumCollocation.ProblemTemplates.UnitarySamplingProblem</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">UnitarySamplingProblem(systemns, operator, T, Δt; kwargs...)</code></pre><p>A <code>UnitarySamplingProblem</code> is a quantum control problem where the goal is to find a control pulse that generates a target unitary operator for a set of quantum systems. The controls are shared among all systems, and the optimization seeks to find the control  pulse that achieves the operator for each system. The idea is to enforce a robust solution by including multiple systems reflecting the problem uncertainty.</p><p><strong>Arguments</strong></p><ul><li><code>systems::AbstractVector{&lt;:AbstractQuantumSystem}</code>: A vector of quantum systems.</li><li><code>operators::AbstractVector{&lt;:AbstractPiccoloOperator}</code>: A vector of target operators.</li><li><code>T::Int</code>: The number of time steps.</li><li><code>Δt::Union{Float64, Vector{Float64}}</code>: The time step value or vector of time steps.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>system_labels::Vector{String} = string.(1:length(systems))</code>: The labels for each system.</li><li><code>system_weights::Vector{Float64} = fill(1.0, length(systems))</code>: The weights for each system.</li><li><code>init_trajectory::Union{NamedTrajectory, Nothing} = nothing</code>: The initial trajectory.</li><li><code>state_name::Symbol = :Ũ⃗</code>: The name of the state variable.</li><li><code>control_name::Symbol = :a</code>: The name of the control variable.</li><li><code>timestep_name::Symbol = :Δt</code>: The name of the timestep variable.</li><li><code>constraints::Vector{&lt;:AbstractConstraint} = AbstractConstraint[]</code>: The constraints.</li><li><code>a_bound::Float64 = 1.0</code>: The bound for the control amplitudes.</li><li><code>a_bounds::Vector{Float64} = fill(a_bound, length(systems[1].G_drives))</code>: The bounds for the control amplitudes.</li><li><code>a_guess::Union{Matrix{Float64}, Nothing} = nothing</code>: The initial guess for the control amplitudes.</li><li><code>da_bound::Float64 = Inf</code>: The bound for the control first derivatives.</li><li><code>da_bounds::Vector{Float64} = fill(da_bound, length(systems[1].G_drives))</code>: The bounds for the control first derivatives.</li><li><code>dda_bound::Float64 = 1.0</code>: The bound for the control second derivatives.</li><li><code>dda_bounds::Vector{Float64} = fill(dda_bound, length(systems[1].G_drives))</code>: The bounds for the control second derivatives.</li><li><code>Δt_min::Float64 = 0.5 * Δt</code>: The minimum time step size.</li><li><code>Δt_max::Float64 = 1.5 * Δt</code>: The maximum time step size.</li><li><code>Q::Float64 = 100.0</code>: The fidelity weight.</li><li><code>R::Float64 = 1e-2</code>: The regularization weight.</li><li><code>R_a::Union{Float64, Vector{Float64}} = R</code>: The regularization weight for the control amplitudes.</li><li><code>R_da::Union{Float64, Vector{Float64}} = R</code>: The regularization weight for the control first derivatives.</li><li><code>R_dda::Union{Float64, Vector{Float64}} = R</code>: The regularization weight for the control second derivatives.</li><li><code>piccolo_options::PiccoloOptions = PiccoloOptions()</code>: The Piccolo options.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/QuantumCollocation.jl/blob/98a6ad8b8de2167576e77b6e32dbc8948198d2d8/src/problem_templates/unitary_sampling_problem.jl#L4-L43">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumCollocation.ProblemTemplates.UnitarySmoothPulseProblem" href="#QuantumCollocation.ProblemTemplates.UnitarySmoothPulseProblem"><code>QuantumCollocation.ProblemTemplates.UnitarySmoothPulseProblem</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">UnitarySmoothPulseProblem(system::AbstractQuantumSystem, operator, T, Δt; kwargs...)
UnitarySmoothPulseProblem(H_drift, H_drives, operator, T, Δt; kwargs...)</code></pre><p>Construct a <code>DirectTrajOptProblem</code> for a free-time unitary gate problem with smooth control pulses enforced by constraining the second derivative of the pulse trajectory, i.e.,</p><p class="math-container">\[\begin{aligned}
\underset{\vec{\tilde{U}}, a, \dot{a}, \ddot{a}, \Delta t}{\text{minimize}} &amp; \quad
Q \cdot \ell\qty(\vec{\tilde{U}}_T, \vec{\tilde{U}}_{\text{goal}}) + \frac{1}{2} \sum_t \qty(R_a a_t^2 + R_{\dot{a}} \dot{a}_t^2 + R_{\ddot{a}} \ddot{a}_t^2) \\
\text{ subject to } &amp; \quad \vb{P}^{(n)}\qty(\vec{\tilde{U}}_{t+1}, \vec{\tilde{U}}_t, a_t, \Delta t_t) = 0 \\
&amp; \quad a_{t+1} - a_t - \dot{a}_t \Delta t_t = 0 \\
&amp; \quad \dot{a}_{t+1} - \dot{a}_t - \ddot{a}_t \Delta t_t = 0 \\
&amp; \quad |a_t| \leq a_{\text{bound}} \\
&amp; \quad |\ddot{a}_t| \leq \ddot{a}_{\text{bound}} \\
&amp; \quad \Delta t_{\text{min}} \leq \Delta t_t \leq \Delta t_{\text{max}} \\
\end{aligned}\]</p><p>where, for <span>$U \in SU(N)$</span>,</p><p class="math-container">\[\ell\qty(\vec{\tilde{U}}_T, \vec{\tilde{U}}_{\text{goal}}) =
\abs{1 - \frac{1}{N} \abs{ \tr \qty(U_{\text{goal}}, U_T)} }\]</p><p>is the <em>infidelity</em> objective function, <span>$Q$</span> is a weight, <span>$R_a$</span>, <span>$R_{\dot{a}}$</span>, and <span>$R_{\ddot{a}}$</span> are weights on the regularization terms, and <span>$\vb{P}^{(n)}$</span> is the <span>$n$</span>th-order Pade integrator.</p><p><strong>Arguments</strong></p><ul><li><code>system::AbstractQuantumSystem</code>: the system to be controlled</li></ul><p>or</p><ul><li><code>H_drift::AbstractMatrix{&lt;:Number}</code>: the drift hamiltonian</li><li><code>H_drives::Vector{&lt;:AbstractMatrix{&lt;:Number}}</code>: the control hamiltonians</li></ul><p>with</p><ul><li><code>goal::AbstractPiccoloOperator</code>: the target unitary, either in the form of an <code>EmbeddedOperator</code> or a `Matrix{ComplexF64}</li><li><code>T::Int</code>: the number of timesteps</li><li><code>Δt::Float64</code>: the (initial) time step size</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>piccolo_options::PiccoloOptions=PiccoloOptions()</code>: the options for the Piccolo solver</li><li><code>state_name::Symbol = :Ũ⃗</code>: the name of the state</li><li><code>control_name::Symbol = :a</code>: the name of the control</li><li><code>timestep_name::Symbol = :Δt</code>: the name of the timestep</li><li><code>init_trajectory::Union{NamedTrajectory, Nothing}=nothing</code>: an initial trajectory to use</li><li><code>a_guess::Union{Matrix{Float64}, Nothing}=nothing</code>: an initial guess for the control pulses</li><li><code>a_bound::Float64=1.0</code>: the bound on the control pulse</li><li><code>a_bounds::Vector{Float64}=fill(a_bound, length(system.G_drives))</code>: the bounds on the control pulses, one for each drive</li><li><code>da_bound::Float64=Inf</code>: the bound on the control pulse derivative</li><li><code>da_bounds::Vector{Float64}=fill(da_bound, length(system.G_drives))</code>: the bounds on the control pulse derivatives, one for each drive</li><li><code>dda_bound::Float64=1.0</code>: the bound on the control pulse second derivative</li><li><code>dda_bounds::Vector{Float64}=fill(dda_bound, length(system.G_drives))</code>: the bounds on the control pulse second derivatives, one for each drive</li><li><code>Δt_min::Float64=Δt isa Float64 ? 0.5 * Δt : 0.5 * mean(Δt)</code>: the minimum time step size</li><li><code>Δt_max::Float64=Δt isa Float64 ? 1.5 * Δt : 1.5 * mean(Δt)</code>: the maximum time step size</li><li><code>Q::Float64=100.0</code>: the weight on the infidelity objective</li><li><code>R=1e-2</code>: the weight on the regularization terms</li><li><code>R_a::Union{Float64, Vector{Float64}}=R</code>: the weight on the regularization term for the control pulses</li><li><code>R_da::Union{Float64, Vector{Float64}}=R</code>: the weight on the regularization term for the control pulse derivatives</li><li><code>R_dda::Union{Float64, Vector{Float64}}=R</code>: the weight on the regularization term for the control pulse second derivatives</li><li><code>constraints::Vector{&lt;:AbstractConstraint}=AbstractConstraint[]</code>: the constraints to enforce</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/QuantumCollocation.jl/blob/98a6ad8b8de2167576e77b6e32dbc8948198d2d8/src/problem_templates/unitary_smooth_pulse_problem.jl#L4-L65">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumCollocation.ProblemTemplates.UnitaryVariationalProblem" href="#QuantumCollocation.ProblemTemplates.UnitaryVariationalProblem"><code>QuantumCollocation.ProblemTemplates.UnitaryVariationalProblem</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">UnitaryVariationalProblem(
    system::VariationalQuantumSystem,
    goal::AbstractPiccoloOperator,
    T::Int,
    Δt::Union{Float64, &lt;:AbstractVector{Float64}};
    robust_times::AbstractVector{&lt;:Union{AbstractVector{Int}, Nothing}}=[nothing for s ∈ system.G_vars],
    sensitive_times::AbstractVector{&lt;:Union{AbstractVector{Int}, Nothing}}=[nothing for s ∈ system.G_vars],
    kwargs...
)</code></pre><p>Constructs a unitary variational problem for optimizing quantum control trajectories.</p><p><strong>Arguments</strong></p><ul><li><code>system::VariationalQuantumSystem</code>: The quantum system to be controlled, containing variational parameters.</li><li><code>goal::AbstractPiccoloOperator</code>: The target operator or state to achieve at the end of the trajectory.</li><li><code>T::Int</code>: The total number of timesteps in the trajectory.</li><li><code>Δt::Union{Float64, &lt;:AbstractVector{Float64}}</code>: The timestep duration or a vector of timestep durations.</li><li><code>robust_times::AbstractVector</code>: Times at which robustness to variations in the trajectory is enforced.</li><li><code>sensitive_times::AbstractVector</code>: Times at which sensitivity to variations in the trajectory is enhanced.</li><li><code>unitary_integrator</code>: The integrator used for unitary evolution (default: <code>VariationalUnitaryIntegrator</code>).</li><li><code>state_name::Symbol</code>: The name of the state variable in the trajectory (default: <code>:Ũ⃗</code>).</li><li><code>variational_state_name::Symbol</code>: The name of the variational state variable (default: <code>:Ũ⃗ₐ</code>).</li><li><code>variational_scales::AbstractVector</code>: Scaling factors for the variational state variables (default: <code>1.0</code>).</li><li><code>control_name::Symbol</code>: The name of the control variable (default: <code>:a</code>).</li><li><code>timestep_name::Symbol</code>: The name of the timestep variable (default: <code>:Δt</code>).</li><li><code>init_trajectory::Union{NamedTrajectory, Nothing}</code>: An optional initial trajectory to start optimization.</li><li><code>a_bound::Float64</code>: The bound for the control variable <code>a</code> (default: <code>1.0</code>).</li><li><code>a_bounds::Vector</code>: Bounds for each control variable (default: filled with <code>a_bound</code>).</li><li><code>da_bound::Float64</code>: The bound for the derivative of the control variable (default: <code>Inf</code>).</li><li><code>da_bounds::Vector</code>: Bounds for each derivative of the control variable.</li><li><code>dda_bound::Float64</code>: The bound for the second derivative of the control variable (default: <code>1.0</code>).</li><li><code>dda_bounds::Vector</code>: Bounds for each second derivative of the control variable.</li><li><code>Δt_min::Float64</code>: Minimum allowed timestep duration.</li><li><code>Δt_max::Float64</code>: Maximum allowed timestep duration.</li><li><code>Q::Float64</code>: Weight for the unitary infidelity objective (default: <code>100.0</code>).</li><li><code>Q_v::Float64</code>: Weight for sensitivity objectives (default: <code>1.0</code>).</li><li><code>R</code>: Regularization weight for control variables (default: <code>1e-2</code>).</li><li><code>R_a</code>, <code>R_da</code>, <code>R_dda</code>: Regularization weights for control, its derivative, and second derivative.</li><li><code>constraints::Vector</code>: Additional constraints for the optimization problem.</li><li><code>piccolo_options::PiccoloOptions</code>: Options for configuring the Piccolo optimization framework.</li></ul><p><strong>Returns</strong></p><p>A <code>DirectTrajOptProblem</code> object representing the optimization problem, including the  trajectory, objective, integrators, and constraints.</p><p><strong>Notes</strong></p><p>This function constructs a trajectory optimization problem for quantum control using  variational principles. It supports robust and sensitive trajectory design, regularization,  and optional constraints. The problem is solved using the Piccolo optimization framework.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/QuantumCollocation.jl/blob/98a6ad8b8de2167576e77b6e32dbc8948198d2d8/src/problem_templates/unitary_variational_problem.jl#L4-L55">source</a></section></article><h2 id="Options"><a class="docs-heading-anchor" href="#Options">Options</a><a id="Options-1"></a><a class="docs-heading-anchor-permalink" href="#Options" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumCollocation.Options.PiccoloOptions" href="#QuantumCollocation.Options.PiccoloOptions"><code>QuantumCollocation.Options.PiccoloOptions</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">PiccoloOptions</code></pre><p>Options for the Piccolo quantum optimal control library.</p><p><strong>Fields</strong></p><ul><li><code>verbose::Bool = true</code>: Print verbose output</li><li><code>timesteps_all_equal::Bool = true</code>: Use equal timesteps</li><li><code>rollout_integrator::Function = expv</code>: Integrator to use for rollout</li><li><code>geodesic = true</code>: Use the geodesic to initialize the optimization.</li><li><code>zero_initial_and_final_derivative::Bool=false</code>: Zero the initial and final control pulse derivatives.</li><li><code>complex_control_norm_constraint_name::Union{Nothing, Symbol} = nothing</code>: Name of the complex control norm constraint.</li><li><code>complex_control_norm_constraint_radius::Float64 = 1.0</code>: Radius of the complex control norm constraint.</li><li><code>bound_state::Bool = false</code>: Bound the state.</li><li><code>leakage_suppression::Bool = false</code>: Suppress leakage.</li><li><code>R_leakage::Float64 = 1.0</code>: Leakage suppression parameter.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/QuantumCollocation.jl/blob/98a6ad8b8de2167576e77b6e32dbc8948198d2d8/src/piccolo_options.jl#L7-L23">source</a></section></article><h2 id="Trajectory-Initialization"><a class="docs-heading-anchor" href="#Trajectory-Initialization">Trajectory Initialization</a><a id="Trajectory-Initialization-1"></a><a class="docs-heading-anchor-permalink" href="#Trajectory-Initialization" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumCollocation.TrajectoryInitialization.initialize_trajectory-Tuple{AbstractVector{&lt;:AbstractVector{ComplexF64}}, AbstractVector{&lt;:AbstractVector{ComplexF64}}, Int64, Union{Real, AbstractVector{&lt;:Real}}, Vararg{Any}}" href="#QuantumCollocation.TrajectoryInitialization.initialize_trajectory-Tuple{AbstractVector{&lt;:AbstractVector{ComplexF64}}, AbstractVector{&lt;:AbstractVector{ComplexF64}}, Int64, Union{Real, AbstractVector{&lt;:Real}}, Vararg{Any}}"><code>QuantumCollocation.TrajectoryInitialization.initialize_trajectory</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">initialize_trajectory</code></pre><p>Trajectory initialization of quantum states.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/QuantumCollocation.jl/blob/98a6ad8b8de2167576e77b6e32dbc8948198d2d8/src/trajectory_initialization.jl#L444-L448">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumCollocation.TrajectoryInitialization.initialize_trajectory-Tuple{Any, Any, Int64, Union{Real, AbstractVecOrMat{&lt;:Real}}, Vararg{Any}}" href="#QuantumCollocation.TrajectoryInitialization.initialize_trajectory-Tuple{Any, Any, Int64, Union{Real, AbstractVecOrMat{&lt;:Real}}, Vararg{Any}}"><code>QuantumCollocation.TrajectoryInitialization.initialize_trajectory</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">initialize_trajectory</code></pre><p>Trajectory initialization of density matrices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/QuantumCollocation.jl/blob/98a6ad8b8de2167576e77b6e32dbc8948198d2d8/src/trajectory_initialization.jl#L509-L513">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumCollocation.TrajectoryInitialization.initialize_trajectory-Tuple{PiccoloQuantumObjects.EmbeddedOperators.AbstractPiccoloOperator, Int64, Union{Real, AbstractVecOrMat{&lt;:Real}}, Vararg{Any}}" href="#QuantumCollocation.TrajectoryInitialization.initialize_trajectory-Tuple{PiccoloQuantumObjects.EmbeddedOperators.AbstractPiccoloOperator, Int64, Union{Real, AbstractVecOrMat{&lt;:Real}}, Vararg{Any}}"><code>QuantumCollocation.TrajectoryInitialization.initialize_trajectory</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">initialize_trajectory</code></pre><p>Trajectory initialization of unitaries.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/QuantumCollocation.jl/blob/98a6ad8b8de2167576e77b6e32dbc8948198d2d8/src/trajectory_initialization.jl#L379-L383">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumCollocation.TrajectoryInitialization.initialize_trajectory-Tuple{Vector{&lt;:AbstractMatrix{Float64}}, Vector{&lt;:AbstractVector{Float64}}, Vector{&lt;:AbstractVector{Float64}}, AbstractVector{Symbol}, Int64, Union{Float64, AbstractVecOrMat{&lt;:Float64}}, Int64, Tuple{Vararg{Union{Tuple{AbstractVector{R}, AbstractVector{R}}, AbstractVector{R}} where R&lt;:Real}}}" href="#QuantumCollocation.TrajectoryInitialization.initialize_trajectory-Tuple{Vector{&lt;:AbstractMatrix{Float64}}, Vector{&lt;:AbstractVector{Float64}}, Vector{&lt;:AbstractVector{Float64}}, AbstractVector{Symbol}, Int64, Union{Float64, AbstractVecOrMat{&lt;:Float64}}, Int64, Tuple{Vararg{Union{Tuple{AbstractVector{R}, AbstractVector{R}}, AbstractVector{R}} where R&lt;:Real}}}"><code>QuantumCollocation.TrajectoryInitialization.initialize_trajectory</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">initialize_trajectory</code></pre><p>Initialize a trajectory for a control problem. The trajectory is initialized with data that should be consistently the same type (in this case, Float64).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/QuantumCollocation.jl/blob/98a6ad8b8de2167576e77b6e32dbc8948198d2d8/src/trajectory_initialization.jl#L247-L254">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumCollocation.TrajectoryInitialization.unitary_geodesic" href="#QuantumCollocation.TrajectoryInitialization.unitary_geodesic"><code>QuantumCollocation.TrajectoryInitialization.unitary_geodesic</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">unitary_geodesic(
    operator::EmbeddedOperator,
    samples::Int;
    kwargs...
)

unitary_geodesic(
    U_goal::AbstractMatrix{&lt;:Number},
    samples::Int;
    kwargs...
)

unitary_geodesic(
    U₀::AbstractMatrix{&lt;:Number},
    U₁::AbstractMatrix{&lt;:Number},
    samples::Number;
    kwargs...
)

unitary_geodesic(
    U₀::AbstractMatrix{&lt;:Number},
    U₁::AbstractMatrix{&lt;:Number},
    timesteps::AbstractVector{&lt;:Number};
    return_generator=false
)</code></pre><p>Compute a geodesic connecting two unitary operators.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/QuantumCollocation.jl/blob/98a6ad8b8de2167576e77b6e32dbc8948198d2d8/src/trajectory_initialization.jl#L50-L78">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumCollocation.TrajectoryInitialization.unitary_geodesic-Tuple{AbstractMatrix{&lt;:Number}, AbstractMatrix{&lt;:Number}, AbstractVector{&lt;:Number}}" href="#QuantumCollocation.TrajectoryInitialization.unitary_geodesic-Tuple{AbstractMatrix{&lt;:Number}, AbstractMatrix{&lt;:Number}, AbstractVector{&lt;:Number}}"><code>QuantumCollocation.TrajectoryInitialization.unitary_geodesic</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">unitary_geodesic(U_init, U_goal, times; kwargs...)</code></pre><p>Compute the geodesic connecting U<em>init and U</em>goal at the specified times. Allows for the possibility of unequal times and ranges outside [0,1].</p><p><strong>Arguments</strong></p><ul><li><code>U_init::AbstractMatrix{&lt;:Number}</code>: The initial unitary operator.</li><li><code>U_goal::AbstractMatrix{&lt;:Number}</code>: The goal unitary operator.</li><li><code>times::AbstractVector{&lt;:Number}</code>: The times at which to evaluate the geodesic.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>return_unitary_isos::Bool=true</code>: If true returns a matrix where each column is a unitary isovec, i.e. vec(vcat(real(U), imag(U))). If false, returns a vector of unitary matrices.</li><li><code>return_generator::Bool=false</code>: If true, returns the effective Hamiltonian generating the geodesic.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/QuantumCollocation.jl/blob/98a6ad8b8de2167576e77b6e32dbc8948198d2d8/src/trajectory_initialization.jl#L121-L134">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumCollocation.TrajectoryInitialization.unitary_linear_interpolation-Tuple{AbstractMatrix{&lt;:Number}, AbstractMatrix{&lt;:Number}, Int64}" href="#QuantumCollocation.TrajectoryInitialization.unitary_linear_interpolation-Tuple{AbstractMatrix{&lt;:Number}, AbstractMatrix{&lt;:Number}, Int64}"><code>QuantumCollocation.TrajectoryInitialization.unitary_linear_interpolation</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">unitary_linear_interpolation(
    U_init::AbstractMatrix,
    U_goal::AbstractMatrix,
    samples::Int
)</code></pre><p>Compute a linear interpolation of unitary operators with <code>samples</code> samples.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/QuantumCollocation.jl/blob/98a6ad8b8de2167576e77b6e32dbc8948198d2d8/src/trajectory_initialization.jl#L21-L29">source</a></section></article><h2 id="Trajectory-Interpolations"><a class="docs-heading-anchor" href="#Trajectory-Interpolations">Trajectory Interpolations</a><a id="Trajectory-Interpolations-1"></a><a class="docs-heading-anchor-permalink" href="#Trajectory-Interpolations" title="Permalink"></a></h2></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.10.1 on <span class="colophon-date" title="Friday 25 April 2025 02:51">Friday 25 April 2025</span>. Using Julia version 1.11.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
