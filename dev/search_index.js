var documenterSearchIndex = {"docs":
[{"location":"lib/#Library","page":"Library","title":"Library","text":"","category":"section"},{"location":"lib/#Problem-Templates","page":"Library","title":"Problem Templates","text":"","category":"section"},{"location":"lib/#QuantumCollocation.ProblemTemplates.QuantumStateMinimumTimeProblem","page":"Library","title":"QuantumCollocation.ProblemTemplates.QuantumStateMinimumTimeProblem","text":"QuantumStateMinimumTimeProblem(traj, sys, obj, integrators, constraints; kwargs...)\nQuantumStateMinimumTimeProblem(prob; kwargs...)\n\nConstruct a DirectTrajOptProblem for the minimum time problem of reaching a target state.\n\nKeyword Arguments\n\nstate_name::Symbol=:ψ̃: The symbol for the state variables.\nfinal_fidelity::Union{Real, Nothing}=nothing: The final fidelity.\nD=1.0: The cost weight on the time.\npiccolo_options::PiccoloOptions=PiccoloOptions(): The Piccolo options.\n\n\n\n\n\n","category":"function"},{"location":"lib/#QuantumCollocation.ProblemTemplates.QuantumStateSamplingProblem","page":"Library","title":"QuantumCollocation.ProblemTemplates.QuantumStateSamplingProblem","text":"\n\n\n\n","category":"function"},{"location":"lib/#QuantumCollocation.ProblemTemplates.QuantumStateSmoothPulseProblem","page":"Library","title":"QuantumCollocation.ProblemTemplates.QuantumStateSmoothPulseProblem","text":"QuantumStateSmoothPulseProblem(system, ψ_inits, ψ_goals, T, Δt; kwargs...)\nQuantumStateSmoothPulseProblem(system, ψ_init, ψ_goal, T, Δt; kwargs...)\nQuantumStateSmoothPulseProblem(H_drift, H_drives, args...; kwargs...)\n\nCreate a quantum state smooth pulse problem. The goal is to find a control pulse a(t)  that drives all of the initial states ψ_inits to the corresponding target states  ψ_goals using T timesteps of size Δt. This problem also controls the  first and  second derivatives of the control pulse, da(t) and dda(t), to ensure smoothness.\n\nArguments\n\nsystem::AbstractQuantumSystem: The quantum system.\n\nor\n\nH_drift::AbstractMatrix{<:Number}: The drift Hamiltonian.\nH_drives::Vector{<:AbstractMatrix{<:Number}}: The control Hamiltonians.\n\nwith\n\nψ_inits::Vector{<:AbstractVector{<:ComplexF64}}: The initial states.\nψ_goals::Vector{<:AbstractVector{<:ComplexF64}}: The target states.\n\nor\n\nψ_init::AbstractVector{<:ComplexF64}: The initial state.\nψ_goal::AbstractVector{<:ComplexF64}: The target state.\n\nwith\n\nT::Int: The number of timesteps.\nΔt::Float64: The timestep size.\n\nKeyword Arguments\n\nstate_name::Symbol=:ψ̃: The name of the state variable.\ncontrol_name::Symbol=:a: The name of the control variable.\ntimestep_name::Symbol=:Δt: The name of the timestep variable.\ninit_trajectory::Union{NamedTrajectory, Nothing}=nothing: The initial trajectory.\na_bound::Float64=1.0: The bound on the control pulse.\na_bounds=fill(a_bound, length(system.G_drives)): The bounds on the control pulse.\na_guess::Union{Matrix{Float64}, Nothing}=nothing: The initial guess for the control pulse.\nda_bound::Float64=Inf: The bound on the first derivative of the control pulse.\nda_bounds=fill(da_bound, length(system.G_drives)): The bounds on the first derivative of the control pulse.\ndda_bound::Float64=1.0: The bound on the second derivative of the control pulse.\ndda_bounds=fill(dda_bound, length(system.G_drives)): The bounds on the second derivative of the control pulse.\nΔt_min::Float64=0.5 * Δt: The minimum timestep size.\nΔt_max::Float64=1.5 * Δt: The maximum timestep size.\ndrive_derivative_σ::Float64=0.01: The standard deviation of the drive derivative random initialization.\nQ::Float64=100.0: The weight on the state objective.\nR=1e-2: The weight on the control pulse and its derivatives.\nR_a::Union{Float64, Vector{Float64}}=R: The weight on the control pulse.\nR_da::Union{Float64, Vector{Float64}}=R: The weight on the first derivative of the control pulse.\nR_dda::Union{Float64, Vector{Float64}}=R: The weight on the second derivative of the control pulse.\nconstraints::Vector{<:AbstractConstraint}=AbstractConstraint[]: The constraints.\npiccolo_options::PiccoloOptions=PiccoloOptions(): The Piccolo options.\n\n\n\n\n\n","category":"function"},{"location":"lib/#QuantumCollocation.ProblemTemplates.UnitaryFreePhaseProblem-Tuple{PiccoloQuantumObjects.QuantumSystems.AbstractQuantumSystem, Function, Int64, Union{Float64, AbstractVector{Float64}}}","page":"Library","title":"QuantumCollocation.ProblemTemplates.UnitaryFreePhaseProblem","text":"UnitaryFreePhaseProblem(system::AbstractQuantumSystem, goal::Function, T, Δt; kwargs...)\n\nConstruct a DirectTrajOptProblem for a free-time unitary gate problem with smooth control pulses enforced by constraining the second derivative of the pulse trajectory. The problem follows the same structure as UnitarySmoothPulseProblem, but allows for free global phases on the goal unitary, via cosines and sines parameterizing phase variables.\n\nThe goal function should accept a vector of global phases [cos(θ); sin(θ)] and return an AbstractPiccoloOperator.\n\n\n\n\n\n","category":"method"},{"location":"lib/#QuantumCollocation.ProblemTemplates.UnitaryMinimumTimeProblem","page":"Library","title":"QuantumCollocation.ProblemTemplates.UnitaryMinimumTimeProblem","text":"UnitaryMinimumTimeProblem(\n    goal::AbstractPiccoloOperator,\n    trajectory::NamedTrajectory,\n    objective::Objective,\n    dynamics::TrajectoryDynamics,\n    constraints::AbstractVector{<:AbstractConstraint};\n    kwargs...\n)\n\nUnitaryMinimumTimeProblem(\n    goal::AbstractPiccoloOperator,\n    prob::DirectTrajOptProblem;\n    kwargs...\n)\n\nCreate a minimum-time problem for unitary control.\n\nbeginaligned\nundersetvectildeU a dota ddota Delta ttextminimize  quad\nJ(vectildeU a dota ddota) + D sum_t Delta t_t \ntext subject to   quad vbP^(n)qty(vectildeU_t+1 vectildeU_t a_t Delta t_t) = 0 \n c(vectildeU a dota ddota) = 0 \n quad Delta t_textmin leq Delta t_t leq Delta t_textmax \nendaligned\n\nKeyword Arguments\n\npiccolo_options::PiccoloOptions=PiccoloOptions(): The Piccolo options.\nunitary_name::Symbol=:Ũ⃗: The name of the unitary for the goal.\nfinal_fidelity::Float64=1.0: The final fidelity constraint.\nD::Float64=1.0: The scaling factor for the minimum-time objective.\n\n\n\n\n\n","category":"function"},{"location":"lib/#QuantumCollocation.ProblemTemplates.UnitarySamplingProblem-Tuple{AbstractVector{<:PiccoloQuantumObjects.QuantumSystems.AbstractQuantumSystem}, AbstractVector{<:PiccoloQuantumObjects.EmbeddedOperators.AbstractPiccoloOperator}, Int64, Union{Float64, Vector{Float64}}}","page":"Library","title":"QuantumCollocation.ProblemTemplates.UnitarySamplingProblem","text":"UnitarySamplingProblem(systemns, operator, T, Δt; kwargs...)\n\nA UnitarySamplingProblem is a quantum control problem where the goal is to find a control pulse that generates a target unitary operator for a set of quantum systems. The controls are shared among all systems, and the optimization seeks to find the control  pulse that achieves the operator for each system. The idea is to enforce a robust solution by including multiple systems reflecting the problem uncertainty.\n\nArguments\n\nsystems::AbstractVector{<:AbstractQuantumSystem}: A vector of quantum systems.\noperators::AbstractVector{<:AbstractPiccoloOperator}: A vector of target operators.\nT::Int: The number of time steps.\nΔt::Union{Float64, Vector{Float64}}: The time step value or vector of time steps.\n\nKeyword Arguments\n\nsystem_labels::Vector{String} = string.(1:length(systems)): The labels for each system.\nsystem_weights::Vector{Float64} = fill(1.0, length(systems)): The weights for each system.\ninit_trajectory::Union{NamedTrajectory, Nothing} = nothing: The initial trajectory.\nstate_name::Symbol = :Ũ⃗: The name of the state variable.\ncontrol_name::Symbol = :a: The name of the control variable.\ntimestep_name::Symbol = :Δt: The name of the timestep variable.\nconstraints::Vector{<:AbstractConstraint} = AbstractConstraint[]: The constraints.\na_bound::Float64 = 1.0: The bound for the control amplitudes.\na_bounds = fill(a_bound, length(systems[1].G_drives)): The bounds for the control amplitudes.\na_guess::Union{Matrix{Float64}, Nothing} = nothing: The initial guess for the control amplitudes.\nda_bound::Float64 = Inf: The bound for the control first derivatives.\nda_bounds = fill(da_bound, length(systems[1].G_drives)): The bounds for the control first derivatives.\ndda_bound::Float64 = 1.0: The bound for the control second derivatives.\ndda_bounds = fill(dda_bound, length(systems[1].G_drives)): The bounds for the control second derivatives.\nΔt_min::Float64 = 0.5 * Δt: The minimum time step size.\nΔt_max::Float64 = 1.5 * Δt: The maximum time step size.\nQ::Float64 = 100.0: The fidelity weight.\nR::Float64 = 1e-2: The regularization weight.\nR_a::Union{Float64, Vector{Float64}} = R: The regularization weight for the control amplitudes.\nR_da::Union{Float64, Vector{Float64}} = R: The regularization weight for the control first derivatives.\nR_dda::Union{Float64, Vector{Float64}} = R: The regularization weight for the control second derivatives.\npiccolo_options::PiccoloOptions = PiccoloOptions(): The Piccolo options.\n\n\n\n\n\n","category":"method"},{"location":"lib/#QuantumCollocation.ProblemTemplates.UnitarySmoothPulseProblem","page":"Library","title":"QuantumCollocation.ProblemTemplates.UnitarySmoothPulseProblem","text":"UnitarySmoothPulseProblem(system::AbstractQuantumSystem, operator::AbstractPiccoloOperator, T::Int, Δt::Float64; kwargs...)\nUnitarySmoothPulseProblem(H_drift, H_drives, operator, T, Δt; kwargs...)\n\nConstruct a DirectTrajOptProblem for a free-time unitary gate problem with smooth control pulses enforced by constraining the second derivative of the pulse trajectory, i.e.,\n\nbeginaligned\nundersetvectildeU a dota ddota Delta ttextminimize  quad\nQ cdot ellqty(vectildeU_T vectildeU_textgoal) + frac12 sum_t qty(R_a a_t^2 + R_dota dota_t^2 + R_ddota ddota_t^2) \ntext subject to   quad vbP^(n)qty(vectildeU_t+1 vectildeU_t a_t Delta t_t) = 0 \n quad a_t+1 - a_t - dota_t Delta t_t = 0 \n quad dota_t+1 - dota_t - ddota_t Delta t_t = 0 \n quad a_t leq a_textbound \n quad ddota_t leq ddota_textbound \n quad Delta t_textmin leq Delta t_t leq Delta t_textmax \nendaligned\n\nwhere, for U in SU(N),\n\nellqty(vectildeU_T vectildeU_textgoal) =\nabs1 - frac1N abs tr qty(U_textgoal U_T) \n\nis the infidelity objective function, Q is a weight, R_a, R_dota, and R_ddota are weights on the regularization terms, and vbP^(n) is the nth-order Pade integrator.\n\nArguments\n\nsystem::AbstractQuantumSystem: the system to be controlled\n\nor\n\nH_drift::AbstractMatrix{<:Number}: the drift hamiltonian\nH_drives::Vector{<:AbstractMatrix{<:Number}}: the control hamiltonians\n\nwith\n\ngoal::AbstractPiccoloOperator: the target unitary, either in the form of an EmbeddedOperator or a `Matrix{ComplexF64}\nT::Int: the number of timesteps\nΔt::Float64: the (initial) time step size\n\nKeyword Arguments\n\npiccolo_options::PiccoloOptions=PiccoloOptions(): the options for the Piccolo solver\nstate_name::Symbol = :Ũ⃗: the name of the state\ncontrol_name::Symbol = :a: the name of the control\ntimestep_name::Symbol = :Δt: the name of the timestep\ninit_trajectory::Union{NamedTrajectory, Nothing}=nothing: an initial trajectory to use\na_guess::Union{Matrix{Float64}, Nothing}=nothing: an initial guess for the control pulses\na_bound::Float64=1.0: the bound on the control pulse\na_bounds=fill(a_bound, length(system.G_drives)): the bounds on the control pulses, one for each drive\nda_bound::Float64=Inf: the bound on the control pulse derivative\nda_bounds=fill(da_bound, length(system.G_drives)): the bounds on the control pulse derivatives, one for each drive\ndda_bound::Float64=1.0: the bound on the control pulse second derivative\ndda_bounds=fill(dda_bound, length(system.G_drives)): the bounds on the control pulse second derivatives, one for each drive\nΔt_min::Float64=Δt isa Float64 ? 0.5 * Δt : 0.5 * mean(Δt): the minimum time step size\nΔt_max::Float64=Δt isa Float64 ? 1.5 * Δt : 1.5 * mean(Δt): the maximum time step size\nQ::Float64=100.0: the weight on the infidelity objective\nR=1e-2: the weight on the regularization terms\nR_a::Union{Float64, Vector{Float64}}=R: the weight on the regularization term for the control pulses\nR_da::Union{Float64, Vector{Float64}}=R: the weight on the regularization term for the control pulse derivatives\nR_dda::Union{Float64, Vector{Float64}}=R: the weight on the regularization term for the control pulse second derivatives\nconstraints::Vector{<:AbstractConstraint}=AbstractConstraint[]: the constraints to enforce\n\n\n\n\n\n","category":"function"},{"location":"lib/#QuantumCollocation.ProblemTemplates.UnitaryVariationalProblem","page":"Library","title":"QuantumCollocation.ProblemTemplates.UnitaryVariationalProblem","text":"UnitaryVariationalProblem(\n    system::VariationalQuantumSystem,\n    goal::AbstractPiccoloOperator,\n    T::Int,\n    Δt::Union{Float64, <:AbstractVector{Float64}};\n    robust_times::AbstractVector{<:Union{AbstractVector{Int}, Nothing}}=[nothing for s ∈ system.G_vars],\n    sensitive_times::AbstractVector{<:Union{AbstractVector{Int}, Nothing}}=[nothing for s ∈ system.G_vars],\n    kwargs...\n)\n\nConstructs a unitary variational problem for optimizing quantum control trajectories.\n\nArguments\n\nsystem::VariationalQuantumSystem: The quantum system to be controlled, containing variational parameters.\ngoal::AbstractPiccoloOperator: The target operator or state to achieve at the end of the trajectory.\nT::Int: The total number of timesteps in the trajectory.\nΔt::Union{Float64, <:AbstractVector{Float64}}: The timestep duration or a vector of timestep durations.\n\nKeyword Arguments\n\nrobust_times::AbstractVector: Times at which robustness to variations in the trajectory is enforced.\nsensitive_times::AbstractVector: Times at which sensitivity to variations in the trajectory is enhanced.\nunitary_integrator: The integrator used for unitary evolution (default: VariationalUnitaryIntegrator).\nstate_name::Symbol: The name of the state variable in the trajectory (default: :Ũ⃗).\nvariational_state_name::Symbol: The name of the variational state variable (default: :Ũ⃗ₐ).\nvariational_scales::AbstractVector: Scaling factors for the variational state variables (default: 1.0).\ncontrol_name::Symbol: The name of the control variable (default: :a).\ntimestep_name::Symbol: The name of the timestep variable (default: :Δt).\ninit_trajectory::Union{NamedTrajectory, Nothing}: An optional initial trajectory to start optimization.\na_bound::Float64: The bound for the control variable a (default: 1.0).\na_bounds: Bounds for each control variable (default: filled with a_bound).\nda_bound::Float64: The bound for the derivative of the control variable (default: Inf).\nda_bounds: Bounds for each derivative of the control variable.\ndda_bound::Float64: The bound for the second derivative of the control variable (default: 1.0).\ndda_bounds: Bounds for each second derivative of the control variable.\nΔt_min::Float64: Minimum allowed timestep duration.\nΔt_max::Float64: Maximum allowed timestep duration.\nQ::Float64: Weight for the unitary infidelity objective (default: 100.0).\nQ_v::Float64: Weight for sensitivity objectives (default: 1.0).\nR: Regularization weight for control variables (default: 1e-2).\nR_a, R_da, R_dda: Regularization weights for control, its derivative, and second derivative.\nconstraints::Vector: Additional constraints for the optimization problem.\npiccolo_options::PiccoloOptions: Options for configuring the Piccolo optimization framework.\n\nReturns\n\nA DirectTrajOptProblem object representing the optimization problem, including the  trajectory, objective, integrators, and constraints.\n\nNotes\n\nThis function constructs a trajectory optimization problem for quantum control using  variational principles. It supports robust and sensitive trajectory design, regularization,  and optional constraints. The problem is solved using the Piccolo optimization framework.\n\n\n\n\n\n","category":"function"},{"location":"lib/#Options","page":"Library","title":"Options","text":"","category":"section"},{"location":"lib/#QuantumCollocation.Options.PiccoloOptions","page":"Library","title":"QuantumCollocation.Options.PiccoloOptions","text":"PiccoloOptions\n\nOptions for the Piccolo quantum optimal control library.\n\nFields\n\nverbose::Bool = true: Print verbose output\ntimesteps_all_equal::Bool = true: Use equal timesteps\nrollout_integrator::Function = expv: Integrator to use for rollout\ngeodesic = true: Use the geodesic to initialize the optimization.\nzero_initial_and_final_derivative::Bool=false: Zero the initial and final control pulse derivatives.\ncomplex_control_norm_constraint_name::Union{Nothing, Symbol} = nothing: Name of the complex control norm constraint.\ncomplex_control_norm_constraint_radius::Float64 = 1.0: Radius of the complex control norm constraint.\nbound_state::Bool = false: Bound the state variables <= 1.0.\nleakage_constraint::Bool = false: Suppress leakage with constraint and cost.\nleakage_constraint_value::Float64 = 1e-2: Value for the leakage constraint.\nleakage_cost::Float64 = 1e-2: Leakage suppression parameter.\n\n\n\n\n\n","category":"type"},{"location":"lib/#Trajectory-Initialization","page":"Library","title":"Trajectory Initialization","text":"","category":"section"},{"location":"lib/#QuantumCollocation.TrajectoryInitialization.initialize_trajectory-Tuple{AbstractVector{<:AbstractVector{ComplexF64}}, AbstractVector{<:AbstractVector{ComplexF64}}, Int64, Union{Real, AbstractVector{<:Real}}, Vararg{Any}}","page":"Library","title":"QuantumCollocation.TrajectoryInitialization.initialize_trajectory","text":"initialize_trajectory\n\nTrajectory initialization of quantum states.\n\n\n\n\n\n","category":"method"},{"location":"lib/#QuantumCollocation.TrajectoryInitialization.initialize_trajectory-Tuple{Any, Any, Int64, Union{Real, AbstractVecOrMat{<:Real}}, Vararg{Any}}","page":"Library","title":"QuantumCollocation.TrajectoryInitialization.initialize_trajectory","text":"initialize_trajectory\n\nTrajectory initialization of density matrices.\n\n\n\n\n\n","category":"method"},{"location":"lib/#QuantumCollocation.TrajectoryInitialization.initialize_trajectory-Tuple{PiccoloQuantumObjects.EmbeddedOperators.AbstractPiccoloOperator, Int64, Union{Real, AbstractVecOrMat{<:Real}}, Vararg{Any}}","page":"Library","title":"QuantumCollocation.TrajectoryInitialization.initialize_trajectory","text":"initialize_trajectory\n\nTrajectory initialization of unitaries.\n\n\n\n\n\n","category":"method"},{"location":"lib/#QuantumCollocation.TrajectoryInitialization.initialize_trajectory-Tuple{Vector{<:AbstractMatrix{Float64}}, Vector{<:AbstractVector{Float64}}, Vector{<:AbstractVector{Float64}}, AbstractVector{Symbol}, Int64, Union{Float64, AbstractVecOrMat{<:Float64}}, Int64, Tuple{Vararg{Union{Tuple{R⃗, R⃗}, R⃗} where R⃗<:(AbstractVector{<:Real})}}}","page":"Library","title":"QuantumCollocation.TrajectoryInitialization.initialize_trajectory","text":"initialize_trajectory\n\nInitialize a trajectory for a control problem. The trajectory is initialized with data that should be consistently the same type (in this case, Float64).\n\n\n\n\n\n","category":"method"},{"location":"lib/#QuantumCollocation.TrajectoryInitialization.unitary_geodesic","page":"Library","title":"QuantumCollocation.TrajectoryInitialization.unitary_geodesic","text":"unitary_geodesic(U_init, U_goal, times; kwargs...)\n\nCompute the geodesic connecting Uinit and Ugoal at the specified times.\n\nArguments\n\nU_init::AbstractMatrix{<:Number}: The initial unitary operator.\nU_goal::AbstractMatrix{<:Number}: The goal unitary operator.\ntimes::AbstractVector{<:Number}: The times at which to evaluate the geodesic.\n\nKeyword Arguments\n\nreturn_unitary_isos::Bool=true: If true returns a matrix where each column is a unitary    isovec, i.e. vec(vcat(real(U), imag(U))). If false, returns a vector of unitary matrices.\nreturn_generator::Bool=false: If true, returns the effective Hamiltonian generating    the geodesic.\n\n\n\n\n\n","category":"function"},{"location":"lib/#QuantumCollocation.TrajectoryInitialization.unitary_linear_interpolation-Tuple{AbstractMatrix{<:Number}, AbstractMatrix{<:Number}, Int64}","page":"Library","title":"QuantumCollocation.TrajectoryInitialization.unitary_linear_interpolation","text":"unitary_linear_interpolation(\n    U_init::AbstractMatrix,\n    U_goal::AbstractMatrix,\n    samples::Int\n)\n\nCompute a linear interpolation of unitary operators with samples samples.\n\n\n\n\n\n","category":"method"},{"location":"generated/examples/two_qubit_gates/#Two-Qubit-Gates","page":"Two Qubit Gates","title":"Two Qubit Gates","text":"","category":"section"},{"location":"generated/examples/two_qubit_gates/","page":"Two Qubit Gates","title":"Two Qubit Gates","text":"In this example we will solve for a selection of two-qubit gates using a simple two-qubit system. We will use the UnitarySmoothPulseProblem template to solve for the optimal control fields.","category":"page"},{"location":"generated/examples/two_qubit_gates/#Defining-our-Hamiltonian","page":"Two Qubit Gates","title":"Defining our Hamiltonian","text":"","category":"section"},{"location":"generated/examples/two_qubit_gates/","page":"Two Qubit Gates","title":"Two Qubit Gates","text":"In quantum optimal control we work with Hamiltonians of the form","category":"page"},{"location":"generated/examples/two_qubit_gates/","page":"Two Qubit Gates","title":"Two Qubit Gates","text":"H(t) = H_textdrift + sum_j u^j(t) H_textdrive^j","category":"page"},{"location":"generated/examples/two_qubit_gates/","page":"Two Qubit Gates","title":"Two Qubit Gates","text":"Specifically, for a simple two-qubit system in a rotating frame, we have","category":"page"},{"location":"generated/examples/two_qubit_gates/","page":"Two Qubit Gates","title":"Two Qubit Gates","text":"H = J_12 sigma_1^x sigma_2^x + sum_i in 12 a_i^R(t) sigma^x_i over 2 + a_i^I(t) sigma^y_i over 2","category":"page"},{"location":"generated/examples/two_qubit_gates/","page":"Two Qubit Gates","title":"Two Qubit Gates","text":"where","category":"page"},{"location":"generated/examples/two_qubit_gates/","page":"Two Qubit Gates","title":"Two Qubit Gates","text":"beginalign*\nJ_12 = 0001 text GHz \na_i^R(t) leq 01 text GHz \nendalign*","category":"page"},{"location":"generated/examples/two_qubit_gates/","page":"Two Qubit Gates","title":"Two Qubit Gates","text":"And the duration of the gate will be capped at 400  mu s.","category":"page"},{"location":"generated/examples/two_qubit_gates/","page":"Two Qubit Gates","title":"Two Qubit Gates","text":"Let's now set this up using some of the convenience functions available in QuantumCollocation.jl.","category":"page"},{"location":"generated/examples/two_qubit_gates/","page":"Two Qubit Gates","title":"Two Qubit Gates","text":"using QuantumCollocation\nusing PiccoloQuantumObjects\nusing NamedTrajectories\nusing LinearAlgebra","category":"page"},{"location":"generated/examples/two_qubit_gates/","page":"Two Qubit Gates","title":"Two Qubit Gates","text":"using PiccoloPlots using CairoMakie","category":"page"},{"location":"generated/examples/two_qubit_gates/","page":"Two Qubit Gates","title":"Two Qubit Gates","text":"⊗(a, b) = kron(a, b)\n\n# Define our operators\nσx = GATES[:X]\nσy = GATES[:Y]\nId = GATES[:I]\n\n# Lift the operators to the two-qubit Hilbert space\nσx_1 = σx ⊗ Id\nσx_2 = Id ⊗ σx\n\nσy_1 = σy ⊗ Id\nσy_2 = Id ⊗ σy\n\n# Define the parameters of the Hamiltonian\nJ_12 = 0.001 # GHz\na_bound = 0.100 # GHz\n\n# Define the drift (coupling) Hamiltonian\nH_drift = J_12 * (σx ⊗ σx)\n\n# Define the control Hamiltonians\nH_drives = [σx_1 / 2, σy_1 / 2, σx_2 / 2, σy_2 / 2]\n\n# Define control (and higher derivative) bounds\na_bound = 0.1\nda_bound = 0.0005\ndda_bound = 0.0025\n\n# Scale the Hamiltonians by 2π\nH_drift *= 2π\nH_drives .*= 2π\n\n# Define the time parameters\nT = 100 # timesteps\nduration = 100 # μs\nΔt = duration / T\nΔt_max = 400 / T\n\n# Define the system\nsys = QuantumSystem(H_drift, H_drives)","category":"page"},{"location":"generated/examples/two_qubit_gates/#SWAP-gate","page":"Two Qubit Gates","title":"SWAP gate","text":"","category":"section"},{"location":"generated/examples/two_qubit_gates/","page":"Two Qubit Gates","title":"Two Qubit Gates","text":"# Define the goal operation\nU_goal = [\n    1 0 0 0;\n    0 0 1 0;\n    0 1 0 0;\n    0 0 0 1\n] |> Matrix{ComplexF64}\n\n# Set up the problem\nprob = UnitarySmoothPulseProblem(\n    sys,\n    U_goal,\n    T,\n    Δt;\n    a_bound=a_bound,\n    da_bound=da_bound,\n    dda_bound=dda_bound,\n    R_da=0.01,\n    R_dda=0.01,\n    Δt_max=Δt_max,\n    piccolo_options=PiccoloOptions()\n)\nfid_init = unitary_rollout_fidelity(prob.trajectory, sys)\nprintln(fid_init)","category":"page"},{"location":"generated/examples/two_qubit_gates/","page":"Two Qubit Gates","title":"Two Qubit Gates","text":"Solve the problem","category":"page"},{"location":"generated/examples/two_qubit_gates/","page":"Two Qubit Gates","title":"Two Qubit Gates","text":"solve!(prob; max_iter=100)\n\n# Let's take a look at the final fidelity\nfid_final = unitary_rollout_fidelity(prob.trajectory, sys)\nprintln(fid_final)","category":"page"},{"location":"generated/examples/two_qubit_gates/","page":"Two Qubit Gates","title":"Two Qubit Gates","text":"Looks good!","category":"page"},{"location":"generated/examples/two_qubit_gates/","page":"Two Qubit Gates","title":"Two Qubit Gates","text":"Now let's plot the pulse and the population trajectories for the first two columns of the unitary, i.e. initial state of ket00 and ket01. For this we provide the function plot_unitary_populations. plot_unitary_populations(prob.trajectory)","category":"page"},{"location":"generated/examples/two_qubit_gates/","page":"Two Qubit Gates","title":"Two Qubit Gates","text":"For fun, let's look at a minimum time pulse for this problem","category":"page"},{"location":"generated/examples/two_qubit_gates/","page":"Two Qubit Gates","title":"Two Qubit Gates","text":"min_time_prob = UnitaryMinimumTimeProblem(prob, U_goal; final_fidelity=.99)\nsolve!(min_time_prob; max_iter=300)\nfid_final_min_time = unitary_rollout_fidelity(min_time_prob.trajectory, sys)\nprintln(fid_final_min_time)","category":"page"},{"location":"generated/examples/two_qubit_gates/","page":"Two Qubit Gates","title":"Two Qubit Gates","text":"And let's plot this solution plot_unitary_populations(min_time_prob.trajectory)","category":"page"},{"location":"generated/examples/two_qubit_gates/","page":"Two Qubit Gates","title":"Two Qubit Gates","text":"It looks like our pulse derivative bounds are holding back the solution, but regardless, the duration has decreased:","category":"page"},{"location":"generated/examples/two_qubit_gates/","page":"Two Qubit Gates","title":"Two Qubit Gates","text":"duration = get_duration(prob.trajectory)\nmin_time_duration = get_duration(min_time_prob.trajectory)\nprintln(duration, \" - \", min_time_duration, \" = \", duration - min_time_duration)","category":"page"},{"location":"generated/examples/two_qubit_gates/#Mølmer–Sørensen-gate","page":"Two Qubit Gates","title":"Mølmer–Sørensen gate","text":"","category":"section"},{"location":"generated/examples/two_qubit_gates/","page":"Two Qubit Gates","title":"Two Qubit Gates","text":"Here we will solve for a Mølmer–Sørensen gate between two. The gate is generally described, for N qubits, by the unitary matrix","category":"page"},{"location":"generated/examples/two_qubit_gates/","page":"Two Qubit Gates","title":"Two Qubit Gates","text":"U_textMS(vectheta) = expleft(isum_j=1^N-1sum_k=j+1^Ntheta_jksigma_j^xsigma_k^xright)","category":"page"},{"location":"generated/examples/two_qubit_gates/","page":"Two Qubit Gates","title":"Two Qubit Gates","text":"where sigma_j^x is the Pauli-X operator acting on the j-th qubit, and vectheta is a vector of real parameters. The Mølmer–Sørensen gate is a two-qubit gate that is particularly well-suited for trapped-ion qubits, where the interaction between qubits is mediated.","category":"page"},{"location":"generated/examples/two_qubit_gates/","page":"Two Qubit Gates","title":"Two Qubit Gates","text":"Here we will focus on the simplest case of a Mølmer–Sørensen gate between two qubits. The gate is described by the unitary matrix","category":"page"},{"location":"generated/examples/two_qubit_gates/","page":"Two Qubit Gates","title":"Two Qubit Gates","text":"U_textMSleft(pi over 4right) = expleft(ifracpi4sigma_1^xsigma_2^xright)","category":"page"},{"location":"generated/examples/two_qubit_gates/","page":"Two Qubit Gates","title":"Two Qubit Gates","text":"Let's set up the problem.","category":"page"},{"location":"generated/examples/two_qubit_gates/","page":"Two Qubit Gates","title":"Two Qubit Gates","text":"# Define the goal operation\nU_goal = exp(im * π/4 * σx_1 * σx_2)\n\n# Set up and solve the problem\n\nprob = UnitarySmoothPulseProblem(\n    sys,\n    U_goal,\n    T,\n    Δt;\n    a_bound=a_bound,\n    da_bound=da_bound,\n    dda_bound=dda_bound,\n    R_da=0.01,\n    R_dda=0.01,\n    Δt_max=Δt_max,\n    piccolo_options=PiccoloOptions()\n)\nfid_init = unitary_rollout_fidelity(prob.trajectory, sys)\nprintln(fid_init)\n\nsolve!(prob; max_iter=100)\n\n# Let's take a look at the final fidelity\nfid_final = unitary_rollout_fidelity(prob.trajectory, sys)\nprintln(fid_final)","category":"page"},{"location":"generated/examples/two_qubit_gates/","page":"Two Qubit Gates","title":"Two Qubit Gates","text":"Again, looks good!","category":"page"},{"location":"generated/examples/two_qubit_gates/","page":"Two Qubit Gates","title":"Two Qubit Gates","text":"Now let's plot the pulse and the population trajectories for the first two columns of the unitary, i.e. initial state of ket00 and ket01. plot_unitary_populations(prob.trajectory)","category":"page"},{"location":"generated/examples/two_qubit_gates/","page":"Two Qubit Gates","title":"Two Qubit Gates","text":"For fun, let's look at a minimum time pulse for this problem","category":"page"},{"location":"generated/examples/two_qubit_gates/","page":"Two Qubit Gates","title":"Two Qubit Gates","text":"min_time_prob = UnitaryMinimumTimeProblem(prob, U_goal; final_fidelity=.999)\nsolve!(min_time_prob; max_iter=300)\nfid_final_min_time = unitary_rollout_fidelity(min_time_prob.trajectory, sys)\nprintln(fid_final_min_time)","category":"page"},{"location":"generated/examples/two_qubit_gates/","page":"Two Qubit Gates","title":"Two Qubit Gates","text":"And let's plot this solution plot_unitary_populations(min_time_prob.trajectory)","category":"page"},{"location":"generated/examples/two_qubit_gates/","page":"Two Qubit Gates","title":"Two Qubit Gates","text":"It looks like our pulse derivative bounds are holding back the solution, but regardless, the duration has decreased:","category":"page"},{"location":"generated/examples/two_qubit_gates/","page":"Two Qubit Gates","title":"Two Qubit Gates","text":"duration = get_duration(prob.trajectory)\nmin_time_duration = get_duration(min_time_prob.trajectory)\nprintln(duration, \" - \", min_time_duration, \" = \", duration - min_time_duration)","category":"page"},{"location":"generated/examples/two_qubit_gates/","page":"Two Qubit Gates","title":"Two Qubit Gates","text":"","category":"page"},{"location":"generated/examples/two_qubit_gates/","page":"Two Qubit Gates","title":"Two Qubit Gates","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/man/unitary_problem_templates/","page":"Unitary Problem Templates","title":"Unitary Problem Templates","text":"using NamedTrajectories\nusing PiccoloQuantumObjects\nusing QuantumCollocation","category":"page"},{"location":"generated/man/unitary_problem_templates/","page":"Unitary Problem Templates","title":"Unitary Problem Templates","text":"","category":"page"},{"location":"generated/man/unitary_problem_templates/#Unitary-Smooth-Pulse-Problem","page":"Unitary Problem Templates","title":"Unitary Smooth Pulse Problem","text":"","category":"section"},{"location":"generated/man/unitary_problem_templates/#QuantumCollocation.ProblemTemplates.UnitarySmoothPulseProblem-generated-man-unitary_problem_templates","page":"Unitary Problem Templates","title":"QuantumCollocation.ProblemTemplates.UnitarySmoothPulseProblem","text":"UnitarySmoothPulseProblem(system::AbstractQuantumSystem, operator::AbstractPiccoloOperator, T::Int, Δt::Float64; kwargs...)\nUnitarySmoothPulseProblem(H_drift, H_drives, operator, T, Δt; kwargs...)\n\nConstruct a DirectTrajOptProblem for a free-time unitary gate problem with smooth control pulses enforced by constraining the second derivative of the pulse trajectory, i.e.,\n\nbeginaligned\nundersetvectildeU a dota ddota Delta ttextminimize  quad\nQ cdot ellqty(vectildeU_T vectildeU_textgoal) + frac12 sum_t qty(R_a a_t^2 + R_dota dota_t^2 + R_ddota ddota_t^2) \ntext subject to   quad vbP^(n)qty(vectildeU_t+1 vectildeU_t a_t Delta t_t) = 0 \n quad a_t+1 - a_t - dota_t Delta t_t = 0 \n quad dota_t+1 - dota_t - ddota_t Delta t_t = 0 \n quad a_t leq a_textbound \n quad ddota_t leq ddota_textbound \n quad Delta t_textmin leq Delta t_t leq Delta t_textmax \nendaligned\n\nwhere, for U in SU(N),\n\nellqty(vectildeU_T vectildeU_textgoal) =\nabs1 - frac1N abs tr qty(U_textgoal U_T) \n\nis the infidelity objective function, Q is a weight, R_a, R_dota, and R_ddota are weights on the regularization terms, and vbP^(n) is the nth-order Pade integrator.\n\nArguments\n\nsystem::AbstractQuantumSystem: the system to be controlled\n\nor\n\nH_drift::AbstractMatrix{<:Number}: the drift hamiltonian\nH_drives::Vector{<:AbstractMatrix{<:Number}}: the control hamiltonians\n\nwith\n\ngoal::AbstractPiccoloOperator: the target unitary, either in the form of an EmbeddedOperator or a `Matrix{ComplexF64}\nT::Int: the number of timesteps\nΔt::Float64: the (initial) time step size\n\nKeyword Arguments\n\npiccolo_options::PiccoloOptions=PiccoloOptions(): the options for the Piccolo solver\nstate_name::Symbol = :Ũ⃗: the name of the state\ncontrol_name::Symbol = :a: the name of the control\ntimestep_name::Symbol = :Δt: the name of the timestep\ninit_trajectory::Union{NamedTrajectory, Nothing}=nothing: an initial trajectory to use\na_guess::Union{Matrix{Float64}, Nothing}=nothing: an initial guess for the control pulses\na_bound::Float64=1.0: the bound on the control pulse\na_bounds=fill(a_bound, length(system.G_drives)): the bounds on the control pulses, one for each drive\nda_bound::Float64=Inf: the bound on the control pulse derivative\nda_bounds=fill(da_bound, length(system.G_drives)): the bounds on the control pulse derivatives, one for each drive\ndda_bound::Float64=1.0: the bound on the control pulse second derivative\ndda_bounds=fill(dda_bound, length(system.G_drives)): the bounds on the control pulse second derivatives, one for each drive\nΔt_min::Float64=Δt isa Float64 ? 0.5 * Δt : 0.5 * mean(Δt): the minimum time step size\nΔt_max::Float64=Δt isa Float64 ? 1.5 * Δt : 1.5 * mean(Δt): the maximum time step size\nQ::Float64=100.0: the weight on the infidelity objective\nR=1e-2: the weight on the regularization terms\nR_a::Union{Float64, Vector{Float64}}=R: the weight on the regularization term for the control pulses\nR_da::Union{Float64, Vector{Float64}}=R: the weight on the regularization term for the control pulse derivatives\nR_dda::Union{Float64, Vector{Float64}}=R: the weight on the regularization term for the control pulse second derivatives\nconstraints::Vector{<:AbstractConstraint}=AbstractConstraint[]: the constraints to enforce\n\n\n\n\n\n","category":"function"},{"location":"generated/man/unitary_problem_templates/","page":"Unitary Problem Templates","title":"Unitary Problem Templates","text":"The UnitarySmoothPulseProblem is similar to the QuantumStateSmoothPulseProblem, but instead of driving the system to a target state, the goal is to drive the system to a target unitary operator, U_goal.","category":"page"},{"location":"generated/man/unitary_problem_templates/","page":"Unitary Problem Templates","title":"Unitary Problem Templates","text":"system = QuantumSystem(0.1 * PAULIS.Z, [PAULIS.X, PAULIS.Y])\nU_goal = GATES.H\nT = 51\nΔt = 0.2\n\nprob = UnitarySmoothPulseProblem(system, U_goal, T, Δt);\nnothing #hide","category":"page"},{"location":"generated/man/unitary_problem_templates/","page":"Unitary Problem Templates","title":"Unitary Problem Templates","text":"check the fidelity before solving","category":"page"},{"location":"generated/man/unitary_problem_templates/","page":"Unitary Problem Templates","title":"Unitary Problem Templates","text":"println(\"Before: \", unitary_rollout_fidelity(prob.trajectory, system))","category":"page"},{"location":"generated/man/unitary_problem_templates/","page":"Unitary Problem Templates","title":"Unitary Problem Templates","text":"finding an optimal control is as simple as calling solve!","category":"page"},{"location":"generated/man/unitary_problem_templates/","page":"Unitary Problem Templates","title":"Unitary Problem Templates","text":"solve!(prob, max_iter=100, verbose=true, print_level=1);\nnothing #hide","category":"page"},{"location":"generated/man/unitary_problem_templates/","page":"Unitary Problem Templates","title":"Unitary Problem Templates","text":"check the fidelity after solving","category":"page"},{"location":"generated/man/unitary_problem_templates/","page":"Unitary Problem Templates","title":"Unitary Problem Templates","text":"println(\"After: \", unitary_rollout_fidelity(prob.trajectory, system))","category":"page"},{"location":"generated/man/unitary_problem_templates/","page":"Unitary Problem Templates","title":"Unitary Problem Templates","text":"The NamedTrajectory object stores the control pulse, state variables, and the time grid.","category":"page"},{"location":"generated/man/unitary_problem_templates/","page":"Unitary Problem Templates","title":"Unitary Problem Templates","text":"extract the control pulses","category":"page"},{"location":"generated/man/unitary_problem_templates/","page":"Unitary Problem Templates","title":"Unitary Problem Templates","text":"prob.trajectory.a |> size","category":"page"},{"location":"generated/man/unitary_problem_templates/","page":"Unitary Problem Templates","title":"Unitary Problem Templates","text":"","category":"page"},{"location":"generated/man/unitary_problem_templates/#Unitary-Minimum-Time-Problem","page":"Unitary Problem Templates","title":"Unitary Minimum Time Problem","text":"","category":"section"},{"location":"generated/man/unitary_problem_templates/#QuantumCollocation.ProblemTemplates.UnitaryMinimumTimeProblem-generated-man-unitary_problem_templates","page":"Unitary Problem Templates","title":"QuantumCollocation.ProblemTemplates.UnitaryMinimumTimeProblem","text":"UnitaryMinimumTimeProblem(\n    goal::AbstractPiccoloOperator,\n    trajectory::NamedTrajectory,\n    objective::Objective,\n    dynamics::TrajectoryDynamics,\n    constraints::AbstractVector{<:AbstractConstraint};\n    kwargs...\n)\n\nUnitaryMinimumTimeProblem(\n    goal::AbstractPiccoloOperator,\n    prob::DirectTrajOptProblem;\n    kwargs...\n)\n\nCreate a minimum-time problem for unitary control.\n\nbeginaligned\nundersetvectildeU a dota ddota Delta ttextminimize  quad\nJ(vectildeU a dota ddota) + D sum_t Delta t_t \ntext subject to   quad vbP^(n)qty(vectildeU_t+1 vectildeU_t a_t Delta t_t) = 0 \n c(vectildeU a dota ddota) = 0 \n quad Delta t_textmin leq Delta t_t leq Delta t_textmax \nendaligned\n\nKeyword Arguments\n\npiccolo_options::PiccoloOptions=PiccoloOptions(): The Piccolo options.\nunitary_name::Symbol=:Ũ⃗: The name of the unitary for the goal.\nfinal_fidelity::Float64=1.0: The final fidelity constraint.\nD::Float64=1.0: The scaling factor for the minimum-time objective.\n\n\n\n\n\n","category":"function"},{"location":"generated/man/unitary_problem_templates/","page":"Unitary Problem Templates","title":"Unitary Problem Templates","text":"The goal of this problem is to find the shortest time it takes to drive the system to a target unitary operator, U_goal. The problem is solved by minimizing the sum of all of the time steps. It is constructed from prob in the previous example.","category":"page"},{"location":"generated/man/unitary_problem_templates/","page":"Unitary Problem Templates","title":"Unitary Problem Templates","text":"min_prob = UnitaryMinimumTimeProblem(prob, U_goal);\nnothing #hide","category":"page"},{"location":"generated/man/unitary_problem_templates/","page":"Unitary Problem Templates","title":"Unitary Problem Templates","text":"check the previous duration","category":"page"},{"location":"generated/man/unitary_problem_templates/","page":"Unitary Problem Templates","title":"Unitary Problem Templates","text":"println(\"Duration before: \", get_duration(prob.trajectory))","category":"page"},{"location":"generated/man/unitary_problem_templates/","page":"Unitary Problem Templates","title":"Unitary Problem Templates","text":"solve the minimum time problem","category":"page"},{"location":"generated/man/unitary_problem_templates/","page":"Unitary Problem Templates","title":"Unitary Problem Templates","text":"solve!(min_prob, max_iter=100, verbose=true, print_level=1);\nnothing #hide","category":"page"},{"location":"generated/man/unitary_problem_templates/","page":"Unitary Problem Templates","title":"Unitary Problem Templates","text":"check the new duration","category":"page"},{"location":"generated/man/unitary_problem_templates/","page":"Unitary Problem Templates","title":"Unitary Problem Templates","text":"println(\"Duration after: \", get_duration(min_prob.trajectory))","category":"page"},{"location":"generated/man/unitary_problem_templates/","page":"Unitary Problem Templates","title":"Unitary Problem Templates","text":"the fidelity is preserved by a constraint","category":"page"},{"location":"generated/man/unitary_problem_templates/","page":"Unitary Problem Templates","title":"Unitary Problem Templates","text":"println(\"Fidelity after: \", unitary_rollout_fidelity(min_prob.trajectory, system))","category":"page"},{"location":"generated/man/unitary_problem_templates/","page":"Unitary Problem Templates","title":"Unitary Problem Templates","text":"","category":"page"},{"location":"generated/man/unitary_problem_templates/#Unitary-Sampling-Problem","page":"Unitary Problem Templates","title":"Unitary Sampling Problem","text":"","category":"section"},{"location":"generated/man/unitary_problem_templates/#QuantumCollocation.ProblemTemplates.UnitarySamplingProblem-generated-man-unitary_problem_templates","page":"Unitary Problem Templates","title":"QuantumCollocation.ProblemTemplates.UnitarySamplingProblem","text":"UnitarySamplingProblem(systemns, operator, T, Δt; kwargs...)\n\nA UnitarySamplingProblem is a quantum control problem where the goal is to find a control pulse that generates a target unitary operator for a set of quantum systems. The controls are shared among all systems, and the optimization seeks to find the control  pulse that achieves the operator for each system. The idea is to enforce a robust solution by including multiple systems reflecting the problem uncertainty.\n\nArguments\n\nsystems::AbstractVector{<:AbstractQuantumSystem}: A vector of quantum systems.\noperators::AbstractVector{<:AbstractPiccoloOperator}: A vector of target operators.\nT::Int: The number of time steps.\nΔt::Union{Float64, Vector{Float64}}: The time step value or vector of time steps.\n\nKeyword Arguments\n\nsystem_labels::Vector{String} = string.(1:length(systems)): The labels for each system.\nsystem_weights::Vector{Float64} = fill(1.0, length(systems)): The weights for each system.\ninit_trajectory::Union{NamedTrajectory, Nothing} = nothing: The initial trajectory.\nstate_name::Symbol = :Ũ⃗: The name of the state variable.\ncontrol_name::Symbol = :a: The name of the control variable.\ntimestep_name::Symbol = :Δt: The name of the timestep variable.\nconstraints::Vector{<:AbstractConstraint} = AbstractConstraint[]: The constraints.\na_bound::Float64 = 1.0: The bound for the control amplitudes.\na_bounds = fill(a_bound, length(systems[1].G_drives)): The bounds for the control amplitudes.\na_guess::Union{Matrix{Float64}, Nothing} = nothing: The initial guess for the control amplitudes.\nda_bound::Float64 = Inf: The bound for the control first derivatives.\nda_bounds = fill(da_bound, length(systems[1].G_drives)): The bounds for the control first derivatives.\ndda_bound::Float64 = 1.0: The bound for the control second derivatives.\ndda_bounds = fill(dda_bound, length(systems[1].G_drives)): The bounds for the control second derivatives.\nΔt_min::Float64 = 0.5 * Δt: The minimum time step size.\nΔt_max::Float64 = 1.5 * Δt: The maximum time step size.\nQ::Float64 = 100.0: The fidelity weight.\nR::Float64 = 1e-2: The regularization weight.\nR_a::Union{Float64, Vector{Float64}} = R: The regularization weight for the control amplitudes.\nR_da::Union{Float64, Vector{Float64}} = R: The regularization weight for the control first derivatives.\nR_dda::Union{Float64, Vector{Float64}} = R: The regularization weight for the control second derivatives.\npiccolo_options::PiccoloOptions = PiccoloOptions(): The Piccolo options.\n\n\n\n\n\n","category":"function"},{"location":"generated/man/unitary_problem_templates/","page":"Unitary Problem Templates","title":"Unitary Problem Templates","text":"A sampling problem is used to solve over multiple quantum systems with the same control. This can be useful for exploring robustness, for example.","category":"page"},{"location":"generated/man/unitary_problem_templates/","page":"Unitary Problem Templates","title":"Unitary Problem Templates","text":"create a sampling problem","category":"page"},{"location":"generated/man/unitary_problem_templates/","page":"Unitary Problem Templates","title":"Unitary Problem Templates","text":"driftless_system = QuantumSystem([PAULIS.X, PAULIS.Y])\nsampling_prob = UnitarySamplingProblem([system, driftless_system], U_goal, T, Δt);\nnothing #hide","category":"page"},{"location":"generated/man/unitary_problem_templates/","page":"Unitary Problem Templates","title":"Unitary Problem Templates","text":"new keys are addded to the trajectory for the new states","category":"page"},{"location":"generated/man/unitary_problem_templates/","page":"Unitary Problem Templates","title":"Unitary Problem Templates","text":"println(sampling_prob.trajectory.state_names)","category":"page"},{"location":"generated/man/unitary_problem_templates/","page":"Unitary Problem Templates","title":"Unitary Problem Templates","text":"the solve! proceeds as in the Quantum State Sampling Problem]","category":"page"},{"location":"generated/man/unitary_problem_templates/","page":"Unitary Problem Templates","title":"Unitary Problem Templates","text":"","category":"page"},{"location":"generated/man/unitary_problem_templates/#Unitary-Variational-Problem","page":"Unitary Problem Templates","title":"Unitary Variational Problem","text":"","category":"section"},{"location":"generated/man/unitary_problem_templates/#QuantumCollocation.ProblemTemplates.UnitaryVariationalProblem-generated-man-unitary_problem_templates","page":"Unitary Problem Templates","title":"QuantumCollocation.ProblemTemplates.UnitaryVariationalProblem","text":"UnitaryVariationalProblem(\n    system::VariationalQuantumSystem,\n    goal::AbstractPiccoloOperator,\n    T::Int,\n    Δt::Union{Float64, <:AbstractVector{Float64}};\n    robust_times::AbstractVector{<:Union{AbstractVector{Int}, Nothing}}=[nothing for s ∈ system.G_vars],\n    sensitive_times::AbstractVector{<:Union{AbstractVector{Int}, Nothing}}=[nothing for s ∈ system.G_vars],\n    kwargs...\n)\n\nConstructs a unitary variational problem for optimizing quantum control trajectories.\n\nArguments\n\nsystem::VariationalQuantumSystem: The quantum system to be controlled, containing variational parameters.\ngoal::AbstractPiccoloOperator: The target operator or state to achieve at the end of the trajectory.\nT::Int: The total number of timesteps in the trajectory.\nΔt::Union{Float64, <:AbstractVector{Float64}}: The timestep duration or a vector of timestep durations.\n\nKeyword Arguments\n\nrobust_times::AbstractVector: Times at which robustness to variations in the trajectory is enforced.\nsensitive_times::AbstractVector: Times at which sensitivity to variations in the trajectory is enhanced.\nunitary_integrator: The integrator used for unitary evolution (default: VariationalUnitaryIntegrator).\nstate_name::Symbol: The name of the state variable in the trajectory (default: :Ũ⃗).\nvariational_state_name::Symbol: The name of the variational state variable (default: :Ũ⃗ₐ).\nvariational_scales::AbstractVector: Scaling factors for the variational state variables (default: 1.0).\ncontrol_name::Symbol: The name of the control variable (default: :a).\ntimestep_name::Symbol: The name of the timestep variable (default: :Δt).\ninit_trajectory::Union{NamedTrajectory, Nothing}: An optional initial trajectory to start optimization.\na_bound::Float64: The bound for the control variable a (default: 1.0).\na_bounds: Bounds for each control variable (default: filled with a_bound).\nda_bound::Float64: The bound for the derivative of the control variable (default: Inf).\nda_bounds: Bounds for each derivative of the control variable.\ndda_bound::Float64: The bound for the second derivative of the control variable (default: 1.0).\ndda_bounds: Bounds for each second derivative of the control variable.\nΔt_min::Float64: Minimum allowed timestep duration.\nΔt_max::Float64: Maximum allowed timestep duration.\nQ::Float64: Weight for the unitary infidelity objective (default: 100.0).\nQ_v::Float64: Weight for sensitivity objectives (default: 1.0).\nR: Regularization weight for control variables (default: 1e-2).\nR_a, R_da, R_dda: Regularization weights for control, its derivative, and second derivative.\nconstraints::Vector: Additional constraints for the optimization problem.\npiccolo_options::PiccoloOptions: Options for configuring the Piccolo optimization framework.\n\nReturns\n\nA DirectTrajOptProblem object representing the optimization problem, including the  trajectory, objective, integrators, and constraints.\n\nNotes\n\nThis function constructs a trajectory optimization problem for quantum control using  variational principles. It supports robust and sensitive trajectory design, regularization,  and optional constraints. The problem is solved using the Piccolo optimization framework.\n\n\n\n\n\n","category":"function"},{"location":"generated/man/unitary_problem_templates/","page":"Unitary Problem Templates","title":"Unitary Problem Templates","text":"The UnitaryVariationalProblem uses a VariationalQuantumSystem to find a control that is sensitive or robust to terms in the Hamiltonian. See the documentation for the VariationalQuantumSystem in PiccoloQuantumObjects.jl for more details.","category":"page"},{"location":"generated/man/unitary_problem_templates/","page":"Unitary Problem Templates","title":"Unitary Problem Templates","text":"create a variational system, with a variational Hamiltonian, PAULIS.X","category":"page"},{"location":"generated/man/unitary_problem_templates/","page":"Unitary Problem Templates","title":"Unitary Problem Templates","text":"H_var = PAULIS.X\nvarsys = VariationalQuantumSystem([PAULIS.X, PAULIS.Y], [H_var]);\nnothing #hide","category":"page"},{"location":"generated/man/unitary_problem_templates/","page":"Unitary Problem Templates","title":"Unitary Problem Templates","text":"create a variational problem that is robust to PAULIS.X at the end","category":"page"},{"location":"generated/man/unitary_problem_templates/","page":"Unitary Problem Templates","title":"Unitary Problem Templates","text":"robprob = UnitaryVariationalProblem(varsys, U_goal, T, Δt, robust_times=[[T]]);\nnothing #hide","category":"page"},{"location":"generated/man/unitary_problem_templates/","page":"Unitary Problem Templates","title":"Unitary Problem Templates","text":"","category":"page"},{"location":"generated/man/unitary_problem_templates/","page":"Unitary Problem Templates","title":"Unitary Problem Templates","text":"","category":"page"},{"location":"generated/man/unitary_problem_templates/","page":"Unitary Problem Templates","title":"Unitary Problem Templates","text":"This page was generated using Literate.jl.","category":"page"},{"location":"#QuantumCollocation.jl","page":"Home","title":"QuantumCollocation.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"QuantumCollocation.jl sets up and solves quantum control problems as nonlinear programs (NLPs). In this context, a generic quantum control problem looks like","category":"page"},{"location":"","page":"Home","title":"Home","text":"beginaligned\n    arg min_mathbfZquad  J(mathbfZ) \n    nonumber textstqquad  mathbff(mathbfZ) = 0 \n    nonumber  mathbfg(mathbfZ) le 0  \nendaligned","category":"page"},{"location":"","page":"Home","title":"Home","text":"where mathbfZ is a trajectory  containing states and controls, from NamedTrajectories.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"We provide a number of problem templates for making it simple and easy to set up and solve  certain types of quantum optimal control problems. These templates all construct a  DirectTrajOptProblem object from DirectTrajOpt.jl, which stores all the parts of the optimal control problem.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#Get-started","page":"Home","title":"Get started","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The problem templates are broken down by the state variable of the problem being solved.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Ket Problem Templates:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Quantum State Smooth Pulse Problem\nQuantum State Minimum Time Problem\nQuantum State Sampling Problem","category":"page"},{"location":"","page":"Home","title":"Home","text":"Unitary Problem Templates:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Unitary Smooth Pulse Problem\nUnitary Minimum Time Problem\nUnitary Sampling Problem","category":"page"},{"location":"#Background","page":"Home","title":"Background","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Problem Templates are reusable design patterns for setting up and solving common quantum control problems. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"For example, a UnitarySmoothPulseProblem is tasked with generating a pulse sequence a_1T-1 in orderd to minimize infidelity, subject to constraints from the Schroedinger equation,","category":"page"},{"location":"","page":"Home","title":"Home","text":"    beginaligned\n        arg min_mathbfZquad  1 - mathcalF(U_T U_textgoal)  \n        nonumber textst\n        qquad  U_t+1 = exp- i H(a_t) Delta t_t  U_t quad forall t \n    endaligned","category":"page"},{"location":"","page":"Home","title":"Home","text":"while a UnitaryMinimumTimeProblem minimizes time and constrains fidelity,","category":"page"},{"location":"","page":"Home","title":"Home","text":"    beginaligned\n        arg min_mathbfZquad  sum_t=1^T Delta t_t \n        qquad  U_t+1 = exp- i H(a_t) Delta t_t  U_t quad forall t \n        nonumber  mathcalF(U_T U_textgoal) ge 09999\n    endaligned","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"In each case, the dynamics between knot points (U_t a_t) and (U_t+1 a_t+1) are enforced as constraints on the states, which are free variables in the solver; this optimization framework is called direct trajectory optimization. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Problem templates give the user the ability to add other constraints and objective functions to this problem and solve it efficiently using Ipopt.jl and MathOptInterface.jl under the hood.","category":"page"},{"location":"generated/man/ket_problem_templates/","page":"Ket Problem Templates","title":"Ket Problem Templates","text":"using NamedTrajectories\nusing PiccoloQuantumObjects\nusing QuantumCollocation","category":"page"},{"location":"generated/man/ket_problem_templates/","page":"Ket Problem Templates","title":"Ket Problem Templates","text":"","category":"page"},{"location":"generated/man/ket_problem_templates/#Quantum-State-Smooth-Pulse-Problem","page":"Ket Problem Templates","title":"Quantum State Smooth Pulse Problem","text":"","category":"section"},{"location":"generated/man/ket_problem_templates/#QuantumCollocation.ProblemTemplates.QuantumStateSmoothPulseProblem-generated-man-ket_problem_templates","page":"Ket Problem Templates","title":"QuantumCollocation.ProblemTemplates.QuantumStateSmoothPulseProblem","text":"QuantumStateSmoothPulseProblem(system, ψ_inits, ψ_goals, T, Δt; kwargs...)\nQuantumStateSmoothPulseProblem(system, ψ_init, ψ_goal, T, Δt; kwargs...)\nQuantumStateSmoothPulseProblem(H_drift, H_drives, args...; kwargs...)\n\nCreate a quantum state smooth pulse problem. The goal is to find a control pulse a(t)  that drives all of the initial states ψ_inits to the corresponding target states  ψ_goals using T timesteps of size Δt. This problem also controls the  first and  second derivatives of the control pulse, da(t) and dda(t), to ensure smoothness.\n\nArguments\n\nsystem::AbstractQuantumSystem: The quantum system.\n\nor\n\nH_drift::AbstractMatrix{<:Number}: The drift Hamiltonian.\nH_drives::Vector{<:AbstractMatrix{<:Number}}: The control Hamiltonians.\n\nwith\n\nψ_inits::Vector{<:AbstractVector{<:ComplexF64}}: The initial states.\nψ_goals::Vector{<:AbstractVector{<:ComplexF64}}: The target states.\n\nor\n\nψ_init::AbstractVector{<:ComplexF64}: The initial state.\nψ_goal::AbstractVector{<:ComplexF64}: The target state.\n\nwith\n\nT::Int: The number of timesteps.\nΔt::Float64: The timestep size.\n\nKeyword Arguments\n\nstate_name::Symbol=:ψ̃: The name of the state variable.\ncontrol_name::Symbol=:a: The name of the control variable.\ntimestep_name::Symbol=:Δt: The name of the timestep variable.\ninit_trajectory::Union{NamedTrajectory, Nothing}=nothing: The initial trajectory.\na_bound::Float64=1.0: The bound on the control pulse.\na_bounds=fill(a_bound, length(system.G_drives)): The bounds on the control pulse.\na_guess::Union{Matrix{Float64}, Nothing}=nothing: The initial guess for the control pulse.\nda_bound::Float64=Inf: The bound on the first derivative of the control pulse.\nda_bounds=fill(da_bound, length(system.G_drives)): The bounds on the first derivative of the control pulse.\ndda_bound::Float64=1.0: The bound on the second derivative of the control pulse.\ndda_bounds=fill(dda_bound, length(system.G_drives)): The bounds on the second derivative of the control pulse.\nΔt_min::Float64=0.5 * Δt: The minimum timestep size.\nΔt_max::Float64=1.5 * Δt: The maximum timestep size.\ndrive_derivative_σ::Float64=0.01: The standard deviation of the drive derivative random initialization.\nQ::Float64=100.0: The weight on the state objective.\nR=1e-2: The weight on the control pulse and its derivatives.\nR_a::Union{Float64, Vector{Float64}}=R: The weight on the control pulse.\nR_da::Union{Float64, Vector{Float64}}=R: The weight on the first derivative of the control pulse.\nR_dda::Union{Float64, Vector{Float64}}=R: The weight on the second derivative of the control pulse.\nconstraints::Vector{<:AbstractConstraint}=AbstractConstraint[]: The constraints.\npiccolo_options::PiccoloOptions=PiccoloOptions(): The Piccolo options.\n\n\n\n\n\n","category":"function"},{"location":"generated/man/ket_problem_templates/","page":"Ket Problem Templates","title":"Ket Problem Templates","text":"Each problem starts with a QuantumSystem object, which is used to define the system's Hamiltonian and control operators. The goal is to find a control pulse that drives the intial state, ψ_init, to a target state, ψ_goal.","category":"page"},{"location":"generated/man/ket_problem_templates/","page":"Ket Problem Templates","title":"Ket Problem Templates","text":"define the quantum system","category":"page"},{"location":"generated/man/ket_problem_templates/","page":"Ket Problem Templates","title":"Ket Problem Templates","text":"system = QuantumSystem(0.1 * PAULIS.Z, [PAULIS.X, PAULIS.Y])\nψ_init = Vector{ComplexF64}([1.0, 0.0])\nψ_goal = Vector{ComplexF64}([0.0, 1.0])\nT = 51\nΔt = 0.2","category":"page"},{"location":"generated/man/ket_problem_templates/","page":"Ket Problem Templates","title":"Ket Problem Templates","text":"create the smooth pulse problem","category":"page"},{"location":"generated/man/ket_problem_templates/","page":"Ket Problem Templates","title":"Ket Problem Templates","text":"state_prob = QuantumStateSmoothPulseProblem(system, ψ_init, ψ_goal, T, Δt);\nnothing #hide","category":"page"},{"location":"generated/man/ket_problem_templates/","page":"Ket Problem Templates","title":"Ket Problem Templates","text":"check the fidelity before solving","category":"page"},{"location":"generated/man/ket_problem_templates/","page":"Ket Problem Templates","title":"Ket Problem Templates","text":"println(\"Before: \", rollout_fidelity(state_prob.trajectory, system))","category":"page"},{"location":"generated/man/ket_problem_templates/","page":"Ket Problem Templates","title":"Ket Problem Templates","text":"solve the problem","category":"page"},{"location":"generated/man/ket_problem_templates/","page":"Ket Problem Templates","title":"Ket Problem Templates","text":"solve!(state_prob, max_iter=100, verbose=true, print_level=1);\nnothing #hide","category":"page"},{"location":"generated/man/ket_problem_templates/","page":"Ket Problem Templates","title":"Ket Problem Templates","text":"check the fidelity after solving","category":"page"},{"location":"generated/man/ket_problem_templates/","page":"Ket Problem Templates","title":"Ket Problem Templates","text":"println(\"After: \", rollout_fidelity(state_prob.trajectory, system))","category":"page"},{"location":"generated/man/ket_problem_templates/","page":"Ket Problem Templates","title":"Ket Problem Templates","text":"extract the control pulses","category":"page"},{"location":"generated/man/ket_problem_templates/","page":"Ket Problem Templates","title":"Ket Problem Templates","text":"state_prob.trajectory.a |> size","category":"page"},{"location":"generated/man/ket_problem_templates/","page":"Ket Problem Templates","title":"Ket Problem Templates","text":"","category":"page"},{"location":"generated/man/ket_problem_templates/#Quantum-State-Minimum-Time-Problem","page":"Ket Problem Templates","title":"Quantum State Minimum Time Problem","text":"","category":"section"},{"location":"generated/man/ket_problem_templates/#QuantumCollocation.ProblemTemplates.QuantumStateMinimumTimeProblem-generated-man-ket_problem_templates","page":"Ket Problem Templates","title":"QuantumCollocation.ProblemTemplates.QuantumStateMinimumTimeProblem","text":"QuantumStateMinimumTimeProblem(traj, sys, obj, integrators, constraints; kwargs...)\nQuantumStateMinimumTimeProblem(prob; kwargs...)\n\nConstruct a DirectTrajOptProblem for the minimum time problem of reaching a target state.\n\nKeyword Arguments\n\nstate_name::Symbol=:ψ̃: The symbol for the state variables.\nfinal_fidelity::Union{Real, Nothing}=nothing: The final fidelity.\nD=1.0: The cost weight on the time.\npiccolo_options::PiccoloOptions=PiccoloOptions(): The Piccolo options.\n\n\n\n\n\n","category":"function"},{"location":"generated/man/ket_problem_templates/","page":"Ket Problem Templates","title":"Ket Problem Templates","text":"create the minimum time problem","category":"page"},{"location":"generated/man/ket_problem_templates/","page":"Ket Problem Templates","title":"Ket Problem Templates","text":"min_state_prob = QuantumStateMinimumTimeProblem(state_prob, ψ_goal);\nnothing #hide","category":"page"},{"location":"generated/man/ket_problem_templates/","page":"Ket Problem Templates","title":"Ket Problem Templates","text":"check the previous duration","category":"page"},{"location":"generated/man/ket_problem_templates/","page":"Ket Problem Templates","title":"Ket Problem Templates","text":"println(\"Duration before: \", get_duration(state_prob.trajectory))","category":"page"},{"location":"generated/man/ket_problem_templates/","page":"Ket Problem Templates","title":"Ket Problem Templates","text":"solve the minimum time problem","category":"page"},{"location":"generated/man/ket_problem_templates/","page":"Ket Problem Templates","title":"Ket Problem Templates","text":"solve!(min_state_prob, max_iter=100, verbose=true, print_level=1);\nnothing #hide","category":"page"},{"location":"generated/man/ket_problem_templates/","page":"Ket Problem Templates","title":"Ket Problem Templates","text":"check the new duration","category":"page"},{"location":"generated/man/ket_problem_templates/","page":"Ket Problem Templates","title":"Ket Problem Templates","text":"println(\"Duration after: \", get_duration(min_state_prob.trajectory))","category":"page"},{"location":"generated/man/ket_problem_templates/","page":"Ket Problem Templates","title":"Ket Problem Templates","text":"the fidelity is preserved by a constraint","category":"page"},{"location":"generated/man/ket_problem_templates/","page":"Ket Problem Templates","title":"Ket Problem Templates","text":"println(\"Fidelity after: \", rollout_fidelity(min_state_prob.trajectory, system))","category":"page"},{"location":"generated/man/ket_problem_templates/","page":"Ket Problem Templates","title":"Ket Problem Templates","text":"","category":"page"},{"location":"generated/man/ket_problem_templates/#Quantum-State-Sampling-Problem","page":"Ket Problem Templates","title":"Quantum State Sampling Problem","text":"","category":"section"},{"location":"generated/man/ket_problem_templates/#QuantumCollocation.ProblemTemplates.QuantumStateSamplingProblem-generated-man-ket_problem_templates","page":"Ket Problem Templates","title":"QuantumCollocation.ProblemTemplates.QuantumStateSamplingProblem","text":"\n\n\n\n","category":"function"},{"location":"generated/man/ket_problem_templates/","page":"Ket Problem Templates","title":"Ket Problem Templates","text":"create a sampling problem","category":"page"},{"location":"generated/man/ket_problem_templates/","page":"Ket Problem Templates","title":"Ket Problem Templates","text":"driftless_system = QuantumSystem([PAULIS.X, PAULIS.Y])\nsampling_state_prob = QuantumStateSamplingProblem([system, driftless_system], ψ_init, ψ_goal, T, Δt);\nnothing #hide","category":"page"},{"location":"generated/man/ket_problem_templates/","page":"Ket Problem Templates","title":"Ket Problem Templates","text":"new keys are added to the trajectory for the new states","category":"page"},{"location":"generated/man/ket_problem_templates/","page":"Ket Problem Templates","title":"Ket Problem Templates","text":"println(sampling_state_prob.trajectory.state_names)","category":"page"},{"location":"generated/man/ket_problem_templates/","page":"Ket Problem Templates","title":"Ket Problem Templates","text":"solve the sampling problem for a few iterations","category":"page"},{"location":"generated/man/ket_problem_templates/","page":"Ket Problem Templates","title":"Ket Problem Templates","text":"solve!(sampling_state_prob, max_iter=25, verbose=true, print_level=1);\nnothing #hide","category":"page"},{"location":"generated/man/ket_problem_templates/","page":"Ket Problem Templates","title":"Ket Problem Templates","text":"check the fidelity of the sampling problem (use the updated key to get the initial and goal)","category":"page"},{"location":"generated/man/ket_problem_templates/","page":"Ket Problem Templates","title":"Ket Problem Templates","text":"println(\"After (original system): \", rollout_fidelity(sampling_state_prob.trajectory, system, state_name=:ψ̃1_system_1))\nprintln(\"After (new system): \", rollout_fidelity(sampling_state_prob.trajectory, driftless_system, state_name=:ψ̃1_system_1))","category":"page"},{"location":"generated/man/ket_problem_templates/","page":"Ket Problem Templates","title":"Ket Problem Templates","text":"compare this to using the original problem on the new system","category":"page"},{"location":"generated/man/ket_problem_templates/","page":"Ket Problem Templates","title":"Ket Problem Templates","text":"println(\"After (new system, original `prob`): \", rollout_fidelity(state_prob.trajectory, driftless_system))","category":"page"},{"location":"generated/man/ket_problem_templates/","page":"Ket Problem Templates","title":"Ket Problem Templates","text":"","category":"page"},{"location":"generated/man/ket_problem_templates/","page":"Ket Problem Templates","title":"Ket Problem Templates","text":"","category":"page"},{"location":"generated/man/ket_problem_templates/","page":"Ket Problem Templates","title":"Ket Problem Templates","text":"This page was generated using Literate.jl.","category":"page"}]
}
