var documenterSearchIndex = {"docs":
[{"location":"lib/#Library","page":"Library","title":"Library","text":"","category":"section"},{"location":"lib/#Problem-Templates","page":"Library","title":"Problem Templates","text":"","category":"section"},{"location":"lib/#QuantumCollocation.ProblemTemplates.QuantumStateMinimumTimeProblem","page":"Library","title":"QuantumCollocation.ProblemTemplates.QuantumStateMinimumTimeProblem","text":"QuantumStateMinimumTimeProblem(traj, sys, obj, integrators, constraints; kwargs...)\nQuantumStateMinimumTimeProblem(prob; kwargs...)\n\nConstruct a DirectTrajOptProblem for the minimum time problem of reaching a target state.\n\nKeyword Arguments\n\nstate_name::Symbol=:ψ̃: The symbol for the state variables.\nfinal_fidelity::Union{Real, Nothing}=nothing: The final fidelity.\nD=1.0: The cost weight on the time.\npiccolo_options::PiccoloOptions=PiccoloOptions(): The Piccolo options.\n\n\n\n\n\n","category":"function"},{"location":"lib/#QuantumCollocation.ProblemTemplates.QuantumStateSamplingProblem","page":"Library","title":"QuantumCollocation.ProblemTemplates.QuantumStateSamplingProblem","text":"\n\n\n\n","category":"function"},{"location":"lib/#QuantumCollocation.ProblemTemplates.QuantumStateSmoothPulseProblem","page":"Library","title":"QuantumCollocation.ProblemTemplates.QuantumStateSmoothPulseProblem","text":"QuantumStateSmoothPulseProblem(system, ψ_inits, ψ_goals, T, Δt; kwargs...)\nQuantumStateSmoothPulseProblem(system, ψ_init, ψ_goal, T, Δt; kwargs...)\nQuantumStateSmoothPulseProblem(H_drift, H_drives, args...; kwargs...)\n\nCreate a quantum state smooth pulse problem. The goal is to find a control pulse u(t) that drives all of the initial states ψ_inits to the corresponding target states ψ_goals using T timesteps of size Δt. This problem also controls the  first and second derivatives of the control pulse, du(t) and ddu(t), to ensure smoothness.\n\nArguments\n\nsystem::AbstractQuantumSystem: The quantum system.\n\nor\n\nH_drift::AbstractMatrix{<:Number}: The drift Hamiltonian.\nH_drives::Vector{<:AbstractMatrix{<:Number}}: The control Hamiltonians.\n\nwith\n\nψ_inits::Vector{<:AbstractVector{<:ComplexF64}}: The initial states.\nψ_goals::Vector{<:AbstractVector{<:ComplexF64}}: The target states.\n\nor\n\nψ_init::AbstractVector{<:ComplexF64}: The initial state.\nψ_goal::AbstractVector{<:ComplexF64}: The target state.\n\nwith\n\nT::Int: The number of timesteps.\nΔt::Float64: The timestep size.\n\nKeyword Arguments\n\nstate_name::Symbol=:ψ̃: The name of the state variable.\ncontrol_name::Symbol=:u: The name of the control variable.\ntimestep_name::Symbol=:Δt: The name of the timestep variable.\ninit_trajectory::Union{NamedTrajectory, Nothing}=nothing: The initial trajectory.\nu_bound::Float64=1.0: The bound on the control pulse.\nu_bounds=fill(u_bound, length(system.G_drives)): The bounds on the control pulse.\nu_guess::Union{Matrix{Float64}, Nothing}=nothing: The initial guess for the control pulse.\ndu_bound::Float64=Inf: The bound on the first derivative of the control pulse.\ndu_bounds=fill(du_bound, length(system.G_drives)): The bounds on the first derivative of the control pulse.\nddu_bound::Float64=1.0: The bound on the second derivative of the control pulse.\nddu_bounds=fill(ddu_bound, length(system.G_drives)): The bounds on the second derivative of the control pulse.\nΔt_min::Float64=0.5 * Δt: The minimum timestep size.\nΔt_max::Float64=1.5 * Δt: The maximum timestep size.\ndrive_derivative_σ::Float64=0.01: The standard deviation of the drive derivative random initialization.\nQ::Float64=100.0: The weight on the state objective.\nR=1e-2: The weight on the control pulse and its derivatives.\nR_u::Union{Float64, Vector{Float64}}=R: The weight on the control pulse.\nR_du::Union{Float64, Vector{Float64}}=R: The weight on the first derivative of the control pulse.\nR_ddu::Union{Float64, Vector{Float64}}=R: The weight on the second derivative of the control pulse.\nconstraints::Vector{<:AbstractConstraint}=AbstractConstraint[]: The constraints.\npiccolo_options::PiccoloOptions=PiccoloOptions(): The Piccolo options.\n\n\n\n\n\n","category":"function"},{"location":"lib/#QuantumCollocation.ProblemTemplates.UnitaryFreePhaseProblem-Tuple{PiccoloQuantumObjects.QuantumSystems.AbstractQuantumSystem, Function, Int64, Union{Float64, AbstractVector{Float64}}}","page":"Library","title":"QuantumCollocation.ProblemTemplates.UnitaryFreePhaseProblem","text":"UnitaryFreePhaseProblem(system::AbstractQuantumSystem, goal::Function, T, Δt; kwargs...)\n\nConstruct a DirectTrajOptProblem for a free-time unitary gate problem with smooth control pulses enforced by constraining the second derivative of the pulse trajectory. The problem follows the same structure as UnitarySmoothPulseProblem, but allows for free global phases on the goal unitary, via cosines and sines parameterizing phase variables.\n\nThe goal function should accept a vector of global phases [cos(θ); sin(θ)] and return an AbstractPiccoloOperator.\n\n\n\n\n\n","category":"method"},{"location":"lib/#QuantumCollocation.ProblemTemplates.UnitaryMinimumTimeProblem","page":"Library","title":"QuantumCollocation.ProblemTemplates.UnitaryMinimumTimeProblem","text":"UnitaryMinimumTimeProblem(\n    goal::AbstractPiccoloOperator,\n    trajectory::NamedTrajectory,\n    objective::Objective,\n    dynamics::TrajectoryDynamics,\n    constraints::AbstractVector{<:AbstractConstraint};\n    kwargs...\n)\n\nUnitaryMinimumTimeProblem(\n    goal::AbstractPiccoloOperator,\n    prob::DirectTrajOptProblem;\n    kwargs...\n)\n\nCreate a minimum-time problem for unitary control.\n\nbeginaligned\nundersetvectildeU u dotu ddotu Delta ttextminimize  quad\nJ(vectildeU u dotu ddotu) + D sum_t Delta t_t \ntext subject to   quad vbP^(n)qty(vectildeU_t+1 vectildeU_t u_t Delta t_t) = 0 \n c(vectildeU u dotu ddotu) = 0 \n quad Delta t_textmin leq Delta t_t leq Delta t_textmax \nendaligned\n\nKeyword Arguments\n\npiccolo_options::PiccoloOptions=PiccoloOptions(): The Piccolo options.\nunitary_name::Symbol=:Ũ⃗: The name of the unitary for the goal.\nfinal_fidelity::Float64=1.0: The final fidelity constraint.\nD::Float64=1.0: The scaling factor for the minimum-time objective.\n\n\n\n\n\n","category":"function"},{"location":"lib/#QuantumCollocation.ProblemTemplates.UnitarySamplingProblem-Tuple{AbstractVector{<:PiccoloQuantumObjects.QuantumSystems.AbstractQuantumSystem}, AbstractVector{<:PiccoloQuantumObjects.EmbeddedOperators.AbstractPiccoloOperator}, Int64, Union{Float64, Vector{Float64}}}","page":"Library","title":"QuantumCollocation.ProblemTemplates.UnitarySamplingProblem","text":"UnitarySamplingProblem(systemns, operator, T, Δt; kwargs...)\n\nA UnitarySamplingProblem is a quantum control problem where the goal is to find a control pulse that generates a target unitary operator for a set of quantum systems. The controls are shared among all systems, and the optimization seeks to find the control pulse that achieves the operator for each system. The idea is to enforce a robust solution by including multiple systems reflecting the problem uncertainty.\n\nArguments\n\nsystems::AbstractVector{<:AbstractQuantumSystem}: A vector of quantum systems.\noperators::AbstractVector{<:AbstractPiccoloOperator}: A vector of target operators.\nT::Int: The number of time steps.\nΔt::Union{Float64, Vector{Float64}}: The time step value or vector of time steps.\n\nKeyword Arguments\n\nsystem_labels::Vector{String} = string.(1:length(systems)): The labels for each system.\nsystem_weights::Vector{Float64} = fill(1.0, length(systems)): The weights for each system.\ninit_trajectory::Union{NamedTrajectory, Nothing} = nothing: The initial trajectory.\nstate_name::Symbol = :Ũ⃗: The name of the state variable.\ncontrol_name::Symbol = :u: The name of the control variable.\ntimestep_name::Symbol = :Δt: The name of the timestep variable.\nconstraints::Vector{<:AbstractConstraint} = AbstractConstraint[]: The constraints.\nu_bound::Float64 = 1.0: The bound for the control amplitudes.\nu_bounds = fill(u_bound, length(systems[1].G_drives)): The bounds for the control amplitudes.\nu_guess::Union{Matrix{Float64}, Nothing} = nothing: The initial guess for the control amplitudes.\ndu_bound::Float64 = Inf: The bound for the control first derivatives.\ndu_bounds = fill(du_bound, length(systems[1].G_drives)): The bounds for the control first derivatives.\nddu_bound::Float64 = 1.0: The bound for the control second derivatives.\nddu_bounds = fill(ddu_bound, length(systems[1].G_drives)): The bounds for the control second derivatives.\nΔt_min::Float64 = 0.5 * Δt: The minimum time step size.\nΔt_max::Float64 = 1.5 * Δt: The maximum time step size.\nQ::Float64 = 100.0: The fidelity weight.\nR::Float64 = 1e-2: The regularization weight.\nR_u::Union{Float64, Vector{Float64}} = R: The regularization weight for the control amplitudes.\nR_du::Union{Float64, Vector{Float64}} = R: The regularization weight for the control first derivatives.\nR_ddu::Union{Float64, Vector{Float64}} = R: The regularization weight for the control second derivatives.\npiccolo_options::PiccoloOptions = PiccoloOptions(): The Piccolo options.\n\n\n\n\n\n","category":"method"},{"location":"lib/#QuantumCollocation.ProblemTemplates.UnitarySmoothPulseProblem","page":"Library","title":"QuantumCollocation.ProblemTemplates.UnitarySmoothPulseProblem","text":"UnitarySmoothPulseProblem(system::AbstractQuantumSystem, operator::AbstractPiccoloOperator, T::Int, Δt::Float64; kwargs...)\nUnitarySmoothPulseProblem(H_drift, H_drives, operator, T, Δt; kwargs...)\n\nConstruct a DirectTrajOptProblem for a free-time unitary gate problem with smooth control pulses enforced by constraining the second derivative of the pulse trajectory, i.e.,\n\nbeginaligned\nundersetvectildeU u dotu ddotu Delta ttextminimize  quad\nQ cdot ellqty(vectildeU_T vectildeU_textgoal) + frac12 sum_t qty(R_u u_t^2 + R_dotu dotu_t^2 + R_ddotu ddotu_t^2) \ntext subject to   quad vbP^(n)qty(vectildeU_t+1 vectildeU_t u_t Delta t_t) = 0 \n quad u_t+1 - u_t - dotu_t Delta t_t = 0 \n quad dotu_t+1 - dotu_t - ddotu_t Delta t_t = 0 \n quad u_t leq u_textbound \n quad ddotu_t leq ddotu_textbound \n quad Delta t_textmin leq Delta t_t leq Delta t_textmax \nendaligned\n\nwhere, for U in SU(N),\n\nellqty(vectildeU_T vectildeU_textgoal) =\nabs1 - frac1N abs tr qty(U_textgoal U_T) \n\nis the infidelity objective function, Q is a weight, R_u, R_dotu, and R_ddotu are weights on the regularization terms, and vbP^(n) is the nth-order Pade integrator.\n\nArguments\n\nsystem::AbstractQuantumSystem: the system to be controlled\n\nor\n\nH_drift::AbstractMatrix{<:Number}: the drift hamiltonian\nH_drives::Vector{<:AbstractMatrix{<:Number}}: the control hamiltonians\n\nwith\n\ngoal::AbstractPiccoloOperator: the target unitary, either in the form of an EmbeddedOperator or a `Matrix{ComplexF64}\nT::Int: the number of timesteps\nΔt::Float64: the (initial) time step size\n\nKeyword Arguments\n\npiccolo_options::PiccoloOptions=PiccoloOptions(): the options for the Piccolo solver\nstate_name::Symbol = :Ũ⃗: the name of the state\ncontrol_name::Symbol = :u: the name of the control\ntimestep_name::Symbol = :Δt: the name of the timestep\ninit_trajectory::Union{NamedTrajectory, Nothing}=nothing: an initial trajectory to use\nu_guess::Union{Matrix{Float64}, Nothing}=nothing: an initial guess for the control pulses\nu_bound::Float64=1.0: the bound on the control pulse\nu_bounds=fill(u_bound, length(system.G_drives)): the bounds on the control pulses, one for each drive\ndu_bound::Float64=Inf: the bound on the control pulse derivative\ndu_bounds=fill(du_bound, length(system.G_drives)): the bounds on the control pulse derivatives, one for each drive\nddu_bound::Float64=1.0: the bound on the control pulse second derivative\nddu_bounds=fill(ddu_bound, length(system.G_drives)): the bounds on the control pulse second derivatives, one for each drive\nΔt_min::Float64=Δt isa Float64 ? 0.5 * Δt : 0.5 * mean(Δt): the minimum time step size\nΔt_max::Float64=Δt isa Float64 ? 1.5 * Δt : 1.5 * mean(Δt): the maximum time step size\nQ::Float64=100.0: the weight on the infidelity objective\nR=1e-2: the weight on the regularization terms\nR_u::Union{Float64, Vector{Float64}}=R: the weight on the regularization term for the control pulses\nR_du::Union{Float64, Vector{Float64}}=R: the weight on the regularization term for the control pulse derivatives\nR_ddu::Union{Float64, Vector{Float64}}=R: the weight on the regularization term for the control pulse second derivatives\nconstraints::Vector{<:AbstractConstraint}=AbstractConstraint[]: the constraints to enforce\n\n\n\n\n\n","category":"function"},{"location":"lib/#QuantumCollocation.ProblemTemplates.UnitaryVariationalProblem","page":"Library","title":"QuantumCollocation.ProblemTemplates.UnitaryVariationalProblem","text":"UnitaryVariationalProblem(\n    system::VariationalQuantumSystem,\n    goal::AbstractPiccoloOperator,\n    T::Int,\n    Δt::Union{Float64, <:AbstractVector{Float64}};\n    robust_times::AbstractVector{<:Union{AbstractVector{Int}, Nothing}}=[nothing for s ∈ system.G_vars],\n    sensitive_times::AbstractVector{<:Union{AbstractVector{Int}, Nothing}}=[nothing for s ∈ system.G_vars],\n    kwargs...\n)\n\nConstructs a unitary variational problem for optimizing quantum control trajectories.\n\nArguments\n\nsystem::VariationalQuantumSystem: The quantum system to be controlled, containing variational parameters.\ngoal::AbstractPiccoloOperator: The target operator or state to achieve at the end of the trajectory.\nT::Int: The total number of timesteps in the trajectory.\nΔt::Union{Float64, <:AbstractVector{Float64}}: The timestep duration or a vector of timestep durations.\n\nKeyword Arguments\n\nrobust_times::AbstractVector: Times at which robustness to variations in the trajectory is enforced.\nsensitive_times::AbstractVector: Times at which sensitivity to variations in the trajectory is enhanced.\nunitary_integrator: The integrator used for unitary evolution (default: VariationalUnitaryIntegrator).\nstate_name::Symbol: The name of the state variable in the trajectory (default: :Ũ⃗).\nvariational_state_name::Symbol: The name of the variational state variable (default: :Ũ⃗ᵥ).\nvariational_scales::AbstractVector: Scaling factors for the variational state variables (default: 1.0).\ncontrol_name::Symbol: The name of the control variable (default: :u).\ntimestep_name::Symbol: The name of the timestep variable (default: :Δt).\ninit_trajectory::Union{NamedTrajectory, Nothing}: An optional initial trajectory to start optimization.\nu_bound::Float64: The bound for the control variable u (default: 1.0).\nu_bounds: Bounds for each control variable (default: filled with u_bound).\ndu_bound::Float64: The bound for the derivative of the control variable (default: Inf).\ndu_bounds: Bounds for each derivative of the control variable.\nddu_bound::Float64: The bound for the second derivative of the control variable (default: 1.0).\nddu_bounds: Bounds for each second derivative of the control variable.\nΔt_min::Float64: Minimum allowed timestep duration.\nΔt_max::Float64: Maximum allowed timestep duration.\nQ::Float64: Weight for the unitary infidelity objective (default: 100.0).\nQ_v::Float64: Weight for sensitivity objectives (default: 1.0).\nR: Regularization weight for control variables (default: 1e-2).\nR_u, R_du, R_ddu: Regularization weights for control, its derivative, and second derivative.\nconstraints::Vector: Additional constraints for the optimization problem.\npiccolo_options::PiccoloOptions: Options for configuring the Piccolo optimization framework.\n\nReturns\n\nA DirectTrajOptProblem object representing the optimization problem, including the trajectory, objective, integrators, and constraints.\n\nNotes\n\nThis function constructs a trajectory optimization problem for quantum control using variational principles. It supports robust and sensitive trajectory design, regularization, and optional constraints. The problem is solved using the Piccolo optimization framework.\n\n\n\n\n\n","category":"function"},{"location":"lib/#Quantum-System-Templates","page":"Library","title":"Quantum System Templates","text":"","category":"section"},{"location":"lib/#QuantumCollocation.QuantumSystemTemplates.CatSystem-Tuple{}","page":"Library","title":"QuantumCollocation.QuantumSystemTemplates.CatSystem","text":"CatSystem(;\n    g2::Real=0.36,\n    χ_aa::Real=-7e-3,\n    χ_bb::Real=-32,\n    χ_ab::Real=0.79,\n    κa::Real=53e-3,\n    κb::Real=13,\n    cat_levels::Int=13,\n    buffer_levels::Int=3,\n    prefactor::Real=1,\n)::OpenQuantumSystem\n\nReturns an OpenQuantumSystem for a quantum cat.\n\n\n\n\n\n","category":"method"},{"location":"lib/#QuantumCollocation.QuantumSystemTemplates.MultiTransmonSystem-Tuple{AbstractVector{Float64}, AbstractVector{Float64}, AbstractMatrix{Float64}}","page":"Library","title":"QuantumCollocation.QuantumSystemTemplates.MultiTransmonSystem","text":"MultiTransmonSystem(\n    ωs::AbstractVector{Float64},\n    δs::AbstractVector{Float64},\n    gs::AbstractMatrix{Float64};\n    levels_per_transmon::Int = 3,\n    subsystem_levels::AbstractVector{Int} = fill(levels_per_transmon, length(ωs)),\n    lab_frame=false,\n    subsystems::AbstractVector{Int} = 1:length(ωs),\n    subsystem_drive_indices::AbstractVector{Int} = 1:length(ωs),\n    kwargs...\n) -> CompositeQuantumSystem\n\nReturns a CompositeQuantumSystem object for a multi-transmon system.\n\n\n\n\n\n","category":"method"},{"location":"lib/#QuantumCollocation.QuantumSystemTemplates.RydbergChainSystem-Tuple{}","page":"Library","title":"QuantumCollocation.QuantumSystemTemplates.RydbergChainSystem","text":"RydbergChainSystem(;\n    N::Int=3, # number of atoms\n    C::Float64=862690*2π,\n    distance::Float64=10.0, # μm\n    cutoff_order::Int=2, # 1 is nearest neighbor, 2 is next-nearest neighbor, etc.\n    local_detune::Bool=false, # If true, include one local detuning pattern.\n    all2all::Bool=true, # If true, include all-to-all interactions.\n    ignore_Y_drive::Bool=false, # If true, ignore the Y drive. (In the experiments, X&Y drives are implemented by Rabi amplitude and its phase.)\n)::QuantumSystem\n\nReturns a QuantumSystem object for the Rydberg atom chain in the spin basis     |g⟩ = |0⟩ = [1, 0], |r⟩ = |1⟩ = [0, 1].\n\nH = sum_i 05*Omega_i(t)cos(phi_i(t)) sigma_i^x - 05*Omega_i(t)sin(phi_i(t)) sigma_i^y - sum_i Delta_i(t)n_i + sum_ij fracCi-j^6 n_i n_j\n\nKeyword Arguments\n\nN: Number of atoms.\nC: The Rydberg interaction strength in MHz*μm^6.\ndistance: The distance between atoms in μm.\ncutoff_order: Interaction range cutoff, 1 is nearest neighbor, 2 is next nearest neighbor.\nlocal_detune: If true, include one local detuning pattern.\nall2all: If true, include all-to-all interactions.\nignore_Y_drive: If true, ignore the Y drive. (In the experiments, X&Y drives are implemented by Rabi amplitude and its phase.)\n\n\n\n\n\n","category":"method"},{"location":"lib/#QuantumCollocation.QuantumSystemTemplates.TransmonDipoleCoupling","page":"Library","title":"QuantumCollocation.QuantumSystemTemplates.TransmonDipoleCoupling","text":"TransmonDipoleCoupling(\n    g_ij::Float64,\n    pair::Tuple{Int, Int},\n    subsystem_levels::Vector{Int};\n    lab_frame::Bool=false,\n) -> QuantumSystemCoupling\n\nTransmonDipoleCoupling(\n    g_ij::Float64,\n    pair::Tuple{Int, Int},\n    sub_systems::Vector{QuantumSystem};\n    kwargs...\n) -> QuantumSystemCoupling\n\nReturns a QuantumSystemCoupling object for a transmon qubit. In the lab frame, the Hamiltonian coupling term is\n\nH = g_ij (a_i + a_i^dagger) (a_j + a_j^dagger)\n\nIn the rotating frame, the Hamiltonian coupling term is\n\nH = g_ij (a_i a_j^dagger + a_i^dagger a_j)\n\nwhere a_i is the annihilation operator for the ith transmon.\n\n\n\n\n\n","category":"function"},{"location":"lib/#QuantumCollocation.QuantumSystemTemplates.TransmonSystem-Tuple{}","page":"Library","title":"QuantumCollocation.QuantumSystemTemplates.TransmonSystem","text":"TransmonSystem(;\n    ω::Float64=4.4153,  # GHz\n    δ::Float64=0.17215, # GHz\n    levels::Int=3,\n    lab_frame::Bool=false,\n    frame_ω::Float64=ω,\n) -> QuantumSystem\n\nReturns a QuantumSystem object for a transmon qubit, with the Hamiltonian\n\nH = omega a^dagger a - fracdelta2 a^dagger a^dagger a a\n\nwhere a is the annihilation operator.\n\nKeyword Arguments\n\nω: The frequency of the transmon, in GHz.\nδ: The anharmonicity of the transmon, in GHz.\nlevels: The number of levels in the transmon.\nlab_frame: Whether to use the lab frame Hamiltonian, or an ω-rotating frame.\nframe_ω: The frequency of the rotating frame, in GHz.\nmutiply_by_2π: Whether to multiply the Hamiltonian by 2π, set to true by default because the frequency is in GHz.\nlab_frame_type: The type of lab frame Hamiltonian to use, one of (:duffing, :quartic, :cosine).\ndrives: Whether to include drives in the Hamiltonian.\n\n\n\n\n\n","category":"method"},{"location":"lib/#QuantumCollocation.QuantumSystemTemplates.lift-Tuple{Char, Int64, Int64}","page":"Library","title":"QuantumCollocation.QuantumSystemTemplates.lift","text":"lift(x::Char, i::Int, N::Int)::String\n\nEmbed a character into a string of the form 'I' * N at a specific position (meant for use with PiccoloQuantumObjects.QuantumObjectUtils.operator_from_string).\n\n\n\n\n\n","category":"method"},{"location":"lib/#Quantum-Objectives","page":"Library","title":"Quantum Objectives","text":"","category":"section"},{"location":"lib/#QuantumCollocation.QuantumObjectives.LeakageObjective-Tuple{AbstractVector{Int64}, Symbol, NamedTrajectories.StructNamedTrajectory.NamedTrajectory}","page":"Library","title":"QuantumCollocation.QuantumObjectives.LeakageObjective","text":"LeakageObjective(indices, name, traj::NamedTrajectory)\n\nConstruct a KnotPointObjective that penalizes leakage of name at the knot points specified by times at any indices that are outside the computational subspace.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Quantum-Constraints","page":"Library","title":"Quantum Constraints","text":"","category":"section"},{"location":"lib/#Quantum-Integrators","page":"Library","title":"Quantum Integrators","text":"","category":"section"},{"location":"lib/#Options","page":"Library","title":"Options","text":"","category":"section"},{"location":"lib/#QuantumCollocation.Options.PiccoloOptions","page":"Library","title":"QuantumCollocation.Options.PiccoloOptions","text":"PiccoloOptions\n\nOptions for the Piccolo quantum optimal control library.\n\nFields\n\nverbose::Bool = true: Print verbose output\ntimesteps_all_equal::Bool = true: Use equal timesteps\nrollout_integrator::Function = expv: Integrator to use for rollout\ngeodesic = true: Use the geodesic to initialize the optimization.\nzero_initial_and_final_derivative::Bool=false: Zero the initial and final control pulse derivatives.\ncomplex_control_norm_constraint_name::Union{Nothing, Symbol} = nothing: Name of the complex control norm constraint.\ncomplex_control_norm_constraint_radius::Float64 = 1.0: Radius of the complex control norm constraint.\nbound_state::Bool = false: Bound the state variables <= 1.0.\nleakage_constraint::Bool = false: Suppress leakage with constraint and cost.\nleakage_constraint_value::Float64 = 1e-2: Value for the leakage constraint.\nleakage_cost::Float64 = 1e-2: Leakage suppression parameter.\n\n\n\n\n\n","category":"type"},{"location":"lib/#Trajectory-Initialization","page":"Library","title":"Trajectory Initialization","text":"","category":"section"},{"location":"lib/#QuantumCollocation.TrajectoryInitialization.initialize_trajectory-Tuple{AbstractVector{<:AbstractVector{ComplexF64}}, AbstractVector{<:AbstractVector{ComplexF64}}, Int64, Union{Real, AbstractVector{<:Real}}, Vararg{Any}}","page":"Library","title":"QuantumCollocation.TrajectoryInitialization.initialize_trajectory","text":"initialize_trajectory\n\nTrajectory initialization of quantum states.\n\n\n\n\n\n","category":"method"},{"location":"lib/#QuantumCollocation.TrajectoryInitialization.initialize_trajectory-Tuple{Any, Any, Int64, Union{Real, AbstractVecOrMat{<:Real}}, Vararg{Any}}","page":"Library","title":"QuantumCollocation.TrajectoryInitialization.initialize_trajectory","text":"initialize_trajectory\n\nTrajectory initialization of density matrices.\n\n\n\n\n\n","category":"method"},{"location":"lib/#QuantumCollocation.TrajectoryInitialization.initialize_trajectory-Tuple{PiccoloQuantumObjects.EmbeddedOperators.AbstractPiccoloOperator, Int64, Union{Real, AbstractVecOrMat{<:Real}}, Vararg{Any}}","page":"Library","title":"QuantumCollocation.TrajectoryInitialization.initialize_trajectory","text":"initialize_trajectory\n\nTrajectory initialization of unitaries.\n\n\n\n\n\n","category":"method"},{"location":"lib/#QuantumCollocation.TrajectoryInitialization.initialize_trajectory-Tuple{Vector{<:AbstractMatrix{Float64}}, Vector{<:AbstractVector{Float64}}, Vector{<:AbstractVector{Float64}}, AbstractVector{Symbol}, Int64, Union{Float64, AbstractVecOrMat{<:Float64}}, Int64, Tuple}","page":"Library","title":"QuantumCollocation.TrajectoryInitialization.initialize_trajectory","text":"initialize_trajectory\n\nInitialize a trajectory for a control problem. The trajectory is initialized with data that should be consistently the same type (in this case, Float64).\n\n\n\n\n\n","category":"method"},{"location":"lib/#QuantumCollocation.TrajectoryInitialization.unitary_geodesic","page":"Library","title":"QuantumCollocation.TrajectoryInitialization.unitary_geodesic","text":"unitary_geodesic(U_init, U_goal, times; kwargs...)\n\nCompute the geodesic connecting Uinit and Ugoal at the specified times.\n\nArguments\n\nU_init::AbstractMatrix{<:Number}: The initial unitary operator.\nU_goal::AbstractMatrix{<:Number}: The goal unitary operator.\ntimes::AbstractVector{<:Number}: The times at which to evaluate the geodesic.\n\nKeyword Arguments\n\nreturn_unitary_isos::Bool=true: If true returns a matrix where each column is a unitary   isovec, i.e. vec(vcat(real(U), imag(U))). If false, returns a vector of unitary matrices.\nreturn_generator::Bool=false: If true, returns the effective Hamiltonian generating   the geodesic.\n\n\n\n\n\n","category":"function"},{"location":"lib/#QuantumCollocation.TrajectoryInitialization.unitary_linear_interpolation-Tuple{AbstractMatrix{<:Number}, AbstractMatrix{<:Number}, Int64}","page":"Library","title":"QuantumCollocation.TrajectoryInitialization.unitary_linear_interpolation","text":"unitary_linear_interpolation(\n    U_init::AbstractMatrix,\n    U_goal::AbstractMatrix,\n    samples::Int\n)\n\nCompute a linear interpolation of unitary operators with samples samples.\n\n\n\n\n\n","category":"method"},{"location":"generated/examples/two_qubit_gates/#Two-Qubit-Gates","page":"Two Qubit Gates","title":"Two Qubit Gates","text":"","category":"section"},{"location":"generated/examples/two_qubit_gates/","page":"Two Qubit Gates","title":"Two Qubit Gates","text":"In this example we will solve for a selection of two-qubit gates using a simple two-qubit system. We will use the UnitarySmoothPulseProblem template to solve for the optimal control fields.","category":"page"},{"location":"generated/examples/two_qubit_gates/#Defining-our-Hamiltonian","page":"Two Qubit Gates","title":"Defining our Hamiltonian","text":"","category":"section"},{"location":"generated/examples/two_qubit_gates/","page":"Two Qubit Gates","title":"Two Qubit Gates","text":"In quantum optimal control we work with Hamiltonians of the form","category":"page"},{"location":"generated/examples/two_qubit_gates/","page":"Two Qubit Gates","title":"Two Qubit Gates","text":"H(t) = H_textdrift + sum_j u^j(t) H_textdrive^j","category":"page"},{"location":"generated/examples/two_qubit_gates/","page":"Two Qubit Gates","title":"Two Qubit Gates","text":"Specifically, for a simple two-qubit system in a rotating frame, we have","category":"page"},{"location":"generated/examples/two_qubit_gates/","page":"Two Qubit Gates","title":"Two Qubit Gates","text":"H = J_12 sigma_1^x sigma_2^x + sum_i in 12 a_i^R(t) sigma^x_i over 2 + a_i^I(t) sigma^y_i over 2","category":"page"},{"location":"generated/examples/two_qubit_gates/","page":"Two Qubit Gates","title":"Two Qubit Gates","text":"where","category":"page"},{"location":"generated/examples/two_qubit_gates/","page":"Two Qubit Gates","title":"Two Qubit Gates","text":"beginalign*\nJ_12 = 0001 text GHz \na_i^R(t) leq 01 text GHz \nendalign*","category":"page"},{"location":"generated/examples/two_qubit_gates/","page":"Two Qubit Gates","title":"Two Qubit Gates","text":"And the duration of the gate will be capped at 400  mu s.","category":"page"},{"location":"generated/examples/two_qubit_gates/","page":"Two Qubit Gates","title":"Two Qubit Gates","text":"Let's now set this up using some of the convenience functions available in QuantumCollocation.jl.","category":"page"},{"location":"generated/examples/two_qubit_gates/","page":"Two Qubit Gates","title":"Two Qubit Gates","text":"using QuantumCollocation\nusing PiccoloQuantumObjects\nusing NamedTrajectories\nusing LinearAlgebra\n\nusing PiccoloPlots\nusing CairoMakie\n\n⊗(a, b) = kron(a, b)\n\n# Define our operators\nσx = GATES[:X]\nσy = GATES[:Y]\nId = GATES[:I]\n\n# Lift the operators to the two-qubit Hilbert space\nσx_1 = σx ⊗ Id\nσx_2 = Id ⊗ σx\n\nσy_1 = σy ⊗ Id\nσy_2 = Id ⊗ σy\n\n# Define the parameters of the Hamiltonian\nJ_12 = 0.001 # GHz\nu_bound = 0.100 # GHz\n\n# Define the drift (coupling) Hamiltonian\nH_drift = J_12 * (σx ⊗ σx)\n\n# Define the control Hamiltonians\nH_drives = [σx_1 / 2, σy_1 / 2, σx_2 / 2, σy_2 / 2]\n\n# Define higher derivative bounds\ndu_bound = 0.0005\nddu_bound = 0.0025\n\n# Scale the Hamiltonians by 2π\nH_drift *= 2π\nH_drives .*= 2π\n\n# Define the time parameters\nN = 100 # timesteps\nT_max = 1.0 # max evolution time\nu_bounds = fill((-u_bound, u_bound), length(H_drives))\nduration = 100 # μs\nΔt = duration / N\nΔt_max = 400 / N\n\n# Define the system\nsys = QuantumSystem(H_drift, H_drives, T_max, u_bounds)","category":"page"},{"location":"generated/examples/two_qubit_gates/#SWAP-gate","page":"Two Qubit Gates","title":"SWAP gate","text":"","category":"section"},{"location":"generated/examples/two_qubit_gates/","page":"Two Qubit Gates","title":"Two Qubit Gates","text":"# Define the goal operation\nU_goal = [\n    1 0 0 0;\n    0 0 1 0;\n    0 1 0 0;\n    0 0 0 1\n] |> Matrix{ComplexF64}\n\n# Set up the problem\nprob = UnitarySmoothPulseProblem(\n    sys,\n    U_goal,\n    N,\n    Δt;\n    du_bound=du_bound,\n    ddu_bound=ddu_bound,\n    R_du=0.01,\n    R_ddu=0.01,\n    Δt_max=Δt_max,\n    piccolo_options=PiccoloOptions(bound_state=true),\n)\nfid_init = unitary_rollout_fidelity(prob.trajectory, sys)\nprintln(fid_init)","category":"page"},{"location":"generated/examples/two_qubit_gates/","page":"Two Qubit Gates","title":"Two Qubit Gates","text":"Solve the problem","category":"page"},{"location":"generated/examples/two_qubit_gates/","page":"Two Qubit Gates","title":"Two Qubit Gates","text":"load_path = joinpath(dirname(Base.active_project()), \"data/two_qubit_gates_89ee72.jld2\") # hide\nprob.trajectory = load_traj(load_path) # hide\nnothing # hide","category":"page"},{"location":"generated/examples/two_qubit_gates/","page":"Two Qubit Gates","title":"Two Qubit Gates","text":"solve!(prob; max_iter=100)","category":"page"},{"location":"generated/examples/two_qubit_gates/","page":"Two Qubit Gates","title":"Two Qubit Gates","text":"<pre class=\"documenter-example-output\"><code class=\"nohighlight hljs ansi\">    initializing optimizer...\n        applying constraint: timesteps all equal constraint\n        applying constraint: initial value of Ũ⃗\n        applying constraint: initial value of u\n        applying constraint: final value of u\n        applying constraint: bounds on u\n        applying constraint: bounds on du\n        applying constraint: bounds on ddu\n        applying constraint: bounds on Δt\n        applying constraint: bounds on Ũ⃗\n\n******************************************************************************\nThis program contains Ipopt, a library for large-scale nonlinear optimization.\n Ipopt is released as open source code under the Eclipse Public License (EPL).\n         For more information visit https://github.com/coin-or/Ipopt\n******************************************************************************\n\nThis is Ipopt version 3.14.19, running with linear solver MUMPS 5.8.1.\n\nNumber of nonzeros in equality constraint Jacobian...:   122590\nNumber of nonzeros in inequality constraint Jacobian.:        0\nNumber of nonzeros in Lagrangian Hessian.............:    22843\n\nTotal number of variables............................:     4460\n                     variables with only lower bounds:        0\n                variables with lower and upper bounds:     4460\n                     variables with only upper bounds:        0\nTotal number of equality constraints.................:     4059\nTotal number of inequality constraints...............:        0\n        inequality constraints with only lower bounds:        0\n   inequality constraints with lower and upper bounds:        0\n        inequality constraints with only upper bounds:        0\n\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n   0  1.9966690e+00 4.09e-01 1.50e+01   0.0 0.00e+00    -  0.00e+00 0.00e+00   0\n   1  1.8868533e+00 4.08e-01 1.49e+01  -2.2 7.79e-01    -  2.56e-03 2.67e-03f  1\n   2  1.5589426e+00 4.05e-01 1.49e+01  -2.2 7.02e-01    -  2.93e-03 7.80e-03f  1\n   3  1.2080227e+00 4.00e-01 1.48e+01  -2.2 6.76e-01    -  6.93e-03 1.10e-02f  1\n   4  1.0979090e+00 3.98e-01 1.90e+01  -2.0 6.91e-01    -  3.70e-02 5.96e-03f  1\n\n<...snip...>\n\n  95  5.0246578e-04 8.45e-07 1.60e-03  -5.4 3.00e-03  -0.5 1.00e+00 1.00e+00h  1\n  96  4.1531633e-04 6.13e-07 7.07e+01  -5.4 3.03e-03  -0.9 1.00e+00 1.00e+00h  1\n  97  3.3533437e-04 5.91e-06 4.93e+01  -4.0 9.44e-03  -1.4 1.00e+00 3.03e-01h  2\n  98  3.9456259e-04 5.21e-06 2.76e+01  -4.0 9.13e-03  -1.9 1.00e+00 1.25e-01h  4\n  99  3.3591342e-04 4.60e-06 4.66e+01  -4.0 1.34e-02  -2.4 1.00e+00 1.25e-01h  4\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n 100  3.3633429e-04 4.46e-06 2.56e+01  -4.1 2.62e-02  -2.8 1.00e+00 3.12e-02h  6\n\nNumber of Iterations....: 100\n\n                                   (scaled)                 (unscaled)\nObjective...............:   3.3633429041403043e-04    3.3633429041403043e-04\nDual infeasibility......:   2.5590761688032366e+01    2.5590761688032366e+01\nConstraint violation....:   4.4603128525290609e-06    4.4603128525290609e-06\nVariable bound violation:   0.0000000000000000e+00    0.0000000000000000e+00\nComplementarity.........:   1.1727909811733182e-04    1.1727909811733182e-04\nOverall NLP error.......:   2.5590761688032366e+01    2.5590761688032366e+01\n\n\nNumber of objective function evaluations             = 216\nNumber of objective gradient evaluations             = 101\nNumber of equality constraint evaluations            = 216\nNumber of inequality constraint evaluations          = 0\nNumber of equality constraint Jacobian evaluations   = 101\nNumber of inequality constraint Jacobian evaluations = 0\nNumber of Lagrangian Hessian evaluations             = 100\nTotal seconds in IPOPT                               = 470.209\n\nEXIT: Maximum Number of Iterations Exceeded.\n</code><button class=\"copy-button fa-solid fa-copy\" aria-label=\"Copy this code block\" title=\"Copy\"></button></pre>","category":"page"},{"location":"generated/examples/two_qubit_gates/","page":"Two Qubit Gates","title":"Two Qubit Gates","text":"# Let's take a look at the final fidelity\nfid_final = unitary_rollout_fidelity(prob.trajectory, sys)\nprintln(fid_final)\n@assert fid_final > 0.99","category":"page"},{"location":"generated/examples/two_qubit_gates/","page":"Two Qubit Gates","title":"Two Qubit Gates","text":"Looks good!","category":"page"},{"location":"generated/examples/two_qubit_gates/","page":"Two Qubit Gates","title":"Two Qubit Gates","text":"Now let's plot the pulse and the population trajectories for the first two columns of the unitary, i.e. initial state of ket00 and ket01. For this we provide the function plot_unitary_populations.","category":"page"},{"location":"generated/examples/two_qubit_gates/","page":"Two Qubit Gates","title":"Two Qubit Gates","text":"plot_unitary_populations(prob.trajectory)","category":"page"},{"location":"generated/examples/two_qubit_gates/","page":"Two Qubit Gates","title":"Two Qubit Gates","text":"For fun, let's look at a minimum time pulse for this problem","category":"page"},{"location":"generated/examples/two_qubit_gates/","page":"Two Qubit Gates","title":"Two Qubit Gates","text":"min_time_prob = UnitaryMinimumTimeProblem(prob, U_goal; final_fidelity=.995)","category":"page"},{"location":"generated/examples/two_qubit_gates/","page":"Two Qubit Gates","title":"Two Qubit Gates","text":"and solve the problem","category":"page"},{"location":"generated/examples/two_qubit_gates/","page":"Two Qubit Gates","title":"Two Qubit Gates","text":"load_path = joinpath(dirname(Base.active_project()), \"data/two_qubit_gates_min_time_89ee72.jld2\") # hide\nmin_time_prob.trajectory = load_traj(load_path) # hide\nnothing # hide","category":"page"},{"location":"generated/examples/two_qubit_gates/","page":"Two Qubit Gates","title":"Two Qubit Gates","text":"solve!(min_time_prob; max_iter=300)","category":"page"},{"location":"generated/examples/two_qubit_gates/","page":"Two Qubit Gates","title":"Two Qubit Gates","text":"        applying constraint: timesteps all equal constraint\n        applying constraint: initial value of Ũ⃗\n        applying constraint: initial value of u\n        applying constraint: final value of u\n        applying constraint: bounds on u\n        applying constraint: bounds on du\n        applying constraint: bounds on ddu\n        applying constraint: bounds on Δt\n        applying constraint: bounds on Ũ⃗\nThis is Ipopt version 3.14.19, running with linear solver MUMPS 5.8.1.\n\nNumber of nonzeros in equality constraint Jacobian...:    47302\nNumber of nonzeros in inequality constraint Jacobian.:       32\nNumber of nonzeros in Lagrangian Hessian.............:    23371\n\nTotal number of variables............................:     4460\n                     variables with only lower bounds:        0\n                variables with lower and upper bounds:     4460\n                     variables with only upper bounds:        0\nTotal number of equality constraints.................:     4059\nTotal number of inequality constraints...............:        1\n        inequality constraints with only lower bounds:        0\n   inequality constraints with lower and upper bounds:        0\n        inequality constraints with only upper bounds:        1\n\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n   0  3.7646707e+04 9.71e-03 1.00e+02   0.0 0.00e+00    -  0.00e+00 0.00e+00   0\n   1  3.7636990e+04 9.71e-03 8.01e+03   1.4 7.82e+01    -  1.83e-02 2.83e-05f  2\n   2  2.9334248e+04 9.65e-03 4.89e+04   1.4 1.49e+02    -  2.82e-02 5.65e-03f  1\n   3  2.7936295e+04 9.48e-03 7.07e+05   1.4 8.45e+00    -  1.00e+00 1.67e-02f  1\n   4  2.8403697e+04 5.00e-03 2.63e+05   1.2 3.73e-01    -  6.91e-01 6.10e-01H  1\n\n<...snip...>\n\n 295r 1.2144904e+04 2.29e-05 2.13e-04  -6.6 1.16e-02    -  1.00e+00 1.00e+00h  1\n 296r 1.2173826e+04 5.43e-07 1.50e-05  -6.6 2.92e-03    -  1.00e+00 1.00e+00h  1\n 297r 1.2174235e+04 2.15e-08 5.74e-07  -6.6 1.97e-04    -  1.00e+00 1.00e+00h  1\n 298r 1.2153605e+04 1.35e-07 6.46e-06  -9.0 2.08e-03    -  1.00e+00 1.00e+00f  1\n 299r 1.2259756e+04 2.02e-05 1.34e-02  -4.0 2.55e+00    -  1.75e-03 4.21e-03f  1\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n 300r 1.2144896e+04 2.28e-05 2.08e-04  -6.6 1.16e-02    -  1.00e+00 1.00e+00h  1\n\nNumber of Iterations....: 300\n\n                                   (scaled)                 (unscaled)\nObjective...............:   1.2144895589604916e+04    1.2144895939586029e+04\nDual infeasibility......:   9.9999997700262952e+01    1.0000000058197654e+02\nConstraint violation....:   2.2776062152680965e-05    2.2776062152680965e-05\nVariable bound violation:   0.0000000000000000e+00    0.0000000000000000e+00\nComplementarity.........:   3.9668426222216936e-07    3.9668427365347392e-07\nOverall NLP error.......:   9.9999997700262952e+01    1.0000000058197654e+02\n\n\nNumber of objective function evaluations             = 409\nNumber of objective gradient evaluations             = 118\nNumber of equality constraint evaluations            = 409\nNumber of inequality constraint evaluations          = 409\nNumber of equality constraint Jacobian evaluations   = 302\nNumber of inequality constraint Jacobian evaluations = 302\nNumber of Lagrangian Hessian evaluations             = 300\nTotal seconds in IPOPT                               = 909.544\n\nEXIT: Maximum Number of Iterations Exceeded.\n</code><button class=\"copy-button fa-solid fa-copy\" aria-label=\"Copy this code block\" title=\"Copy\"></button></pre>","category":"page"},{"location":"generated/examples/two_qubit_gates/","page":"Two Qubit Gates","title":"Two Qubit Gates","text":"fid_final_min_time = unitary_rollout_fidelity(min_time_prob.trajectory, sys)\nprintln(fid_final_min_time)\n@assert fid_final_min_time > 0.99","category":"page"},{"location":"generated/examples/two_qubit_gates/","page":"Two Qubit Gates","title":"Two Qubit Gates","text":"And let's plot this solution","category":"page"},{"location":"generated/examples/two_qubit_gates/","page":"Two Qubit Gates","title":"Two Qubit Gates","text":"plot_unitary_populations(min_time_prob.trajectory)","category":"page"},{"location":"generated/examples/two_qubit_gates/","page":"Two Qubit Gates","title":"Two Qubit Gates","text":"It looks like our pulse derivative bounds are holding back the solution, but regardless, the duration has decreased:","category":"page"},{"location":"generated/examples/two_qubit_gates/","page":"Two Qubit Gates","title":"Two Qubit Gates","text":"duration = get_duration(prob.trajectory)\nmin_time_duration = get_duration(min_time_prob.trajectory)\nprintln(duration, \" - \", min_time_duration, \" = \", duration - min_time_duration)","category":"page"},{"location":"generated/examples/two_qubit_gates/#Mølmer–Sørensen-gate","page":"Two Qubit Gates","title":"Mølmer–Sørensen gate","text":"","category":"section"},{"location":"generated/examples/two_qubit_gates/","page":"Two Qubit Gates","title":"Two Qubit Gates","text":"Here we will solve for a Mølmer–Sørensen gate between two. The gate is generally described, for N qubits, by the unitary matrix","category":"page"},{"location":"generated/examples/two_qubit_gates/","page":"Two Qubit Gates","title":"Two Qubit Gates","text":"U_textMS(vectheta) = expleft(isum_j=1^N-1sum_k=j+1^Ntheta_jksigma_j^xsigma_k^xright)","category":"page"},{"location":"generated/examples/two_qubit_gates/","page":"Two Qubit Gates","title":"Two Qubit Gates","text":"where sigma_j^x is the Pauli-X operator acting on the j-th qubit, and vectheta is a vector of real parameters. The Mølmer–Sørensen gate is a two-qubit gate that is particularly well-suited for trapped-ion qubits, where the interaction between qubits is mediated.","category":"page"},{"location":"generated/examples/two_qubit_gates/","page":"Two Qubit Gates","title":"Two Qubit Gates","text":"Here we will focus on the simplest case of a Mølmer–Sørensen gate between two qubits. The gate is described by the unitary matrix","category":"page"},{"location":"generated/examples/two_qubit_gates/","page":"Two Qubit Gates","title":"Two Qubit Gates","text":"U_textMSleft(pi over 4right) = expleft(ifracpi4sigma_1^xsigma_2^xright)","category":"page"},{"location":"generated/examples/two_qubit_gates/","page":"Two Qubit Gates","title":"Two Qubit Gates","text":"# Define the goal operation\nU_goal_ms = exp(im * π/4 * σx_1 * σx_2)\n\n# Set up and solve the problem\n\nprob_ms = UnitarySmoothPulseProblem(\n    sys,\n    U_goal_ms,\n    N,\n    Δt;\n    du_bound=du_bound,\n    ddu_bound=ddu_bound,\n    R_du=0.01,\n    R_ddu=0.01,\n    Δt_max=Δt_max,\n    piccolo_options=PiccoloOptions(bound_state=true),\n)\nfid_init = unitary_rollout_fidelity(prob_ms.trajectory, sys)\nprintln(fid_init)","category":"page"},{"location":"generated/examples/two_qubit_gates/","page":"Two Qubit Gates","title":"Two Qubit Gates","text":"Solve the problem","category":"page"},{"location":"generated/examples/two_qubit_gates/","page":"Two Qubit Gates","title":"Two Qubit Gates","text":"load_path = joinpath(dirname(Base.active_project()), \"data/two_qubit_gates_molmer_89ee72.jld2\") # hide\nprob_ms.trajectory = load_traj(load_path) # hide\nnothing # hide","category":"page"},{"location":"generated/examples/two_qubit_gates/","page":"Two Qubit Gates","title":"Two Qubit Gates","text":"solve!(prob; max_iter=300)","category":"page"},{"location":"generated/examples/two_qubit_gates/","page":"Two Qubit Gates","title":"Two Qubit Gates","text":"        applying constraint: timesteps all equal constraint\n        applying constraint: initial value of Ũ⃗\n        applying constraint: initial value of u\n        applying constraint: final value of u\n        applying constraint: bounds on u\n        applying constraint: bounds on du\n        applying constraint: bounds on ddu\n        applying constraint: bounds on Δt\n        applying constraint: bounds on Ũ⃗\nThis is Ipopt version 3.14.19, running with linear solver MUMPS 5.8.1.\n\nNumber of nonzeros in equality constraint Jacobian...:   122590\nNumber of nonzeros in inequality constraint Jacobian.:        0\nNumber of nonzeros in Lagrangian Hessian.............:    22843\n\nTotal number of variables............................:     4460\n                     variables with only lower bounds:        0\n                variables with lower and upper bounds:     4460\n                     variables with only upper bounds:        0\nTotal number of equality constraints.................:     4059\nTotal number of inequality constraints...............:        0\n        inequality constraints with only lower bounds:        0\n   inequality constraints with lower and upper bounds:        0\n        inequality constraints with only upper bounds:        0\n\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n   0  1.9968551e+00 4.24e-01 1.10e+01   0.0 0.00e+00    -  0.00e+00 0.00e+00   0\n   1  1.8636183e+00 4.22e-01 1.09e+01  -2.2 1.04e+00    -  2.50e-03 6.41e-03f  1\n   2  1.7504526e+00 4.20e-01 1.08e+01  -2.2 9.82e-01    -  5.03e-03 5.03e-03f  1\n   3  1.5169129e+00 4.15e-01 1.07e+01  -2.0 9.83e-01    -  1.21e-02 1.17e-02f  1\n   4  1.4313680e+00 4.11e-01 4.89e+01  -1.8 9.87e-01    -  4.43e-02 7.94e-03f  1\n\n<...snip...>\n\n 295  2.0649662e-04 8.04e-10 7.07e+01  -6.1 1.48e-04  -0.9 1.00e+00 1.00e+00h  1\n 296  2.0699118e-04 9.41e-11 7.07e+01  -6.1 1.05e-04  -1.4 1.00e+00 1.00e+00H  1\n 297  2.0698519e-04 2.70e-12 1.07e-02  -6.1 1.85e-06   1.8 1.00e+00 1.00e+00h  1\n 298  2.0696914e-04 1.76e-12 4.14e-05  -6.1 2.20e-06   1.3 1.00e+00 1.00e+00h  1\n 299  2.0692500e-04 8.75e-13 4.19e-05  -6.1 6.38e-06   0.8 1.00e+00 1.00e+00h  1\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n 300  2.0681635e-04 8.07e-12 7.24e-05  -6.1 1.73e-05   0.3 1.00e+00 1.00e+00h  1\n\nNumber of Iterations....: 300\n\n                                   (scaled)                 (unscaled)\nObjective...............:   2.0681635138132748e-04    2.0681635138132748e-04\nDual infeasibility......:   7.2391829384785262e-05    7.2391829384785262e-05\nConstraint violation....:   8.0724482325300042e-12    8.0724482325300042e-12\nVariable bound violation:   0.0000000000000000e+00    0.0000000000000000e+00\nComplementarity.........:   7.1554229772280104e-07    7.1554229772280104e-07\nOverall NLP error.......:   9.9284457729729384e-05    9.9284457729729384e-05\n\n\nNumber of objective function evaluations             = 765\nNumber of objective gradient evaluations             = 301\nNumber of equality constraint evaluations            = 765\nNumber of inequality constraint evaluations          = 0\nNumber of equality constraint Jacobian evaluations   = 301\nNumber of inequality constraint Jacobian evaluations = 0\nNumber of Lagrangian Hessian evaluations             = 300\nTotal seconds in IPOPT                               = 1178.223\n\nEXIT: Maximum Number of Iterations Exceeded.","category":"page"},{"location":"generated/examples/two_qubit_gates/","page":"Two Qubit Gates","title":"Two Qubit Gates","text":"# Let's take a look at the final fidelity\nfid_final = unitary_rollout_fidelity(prob_ms.trajectory, sys)\nprintln(fid_final)\n@assert fid_final > 0.999","category":"page"},{"location":"generated/examples/two_qubit_gates/","page":"Two Qubit Gates","title":"Two Qubit Gates","text":"Again, looks good!","category":"page"},{"location":"generated/examples/two_qubit_gates/","page":"Two Qubit Gates","title":"Two Qubit Gates","text":"Now let's plot the pulse and the population trajectories for the first two columns of the unitary, i.e. initial state of ket00 and ket01.","category":"page"},{"location":"generated/examples/two_qubit_gates/","page":"Two Qubit Gates","title":"Two Qubit Gates","text":"plot_unitary_populations(prob_ms.trajectory)","category":"page"},{"location":"generated/examples/two_qubit_gates/","page":"Two Qubit Gates","title":"Two Qubit Gates","text":"For fun, let's look at a minimum time pulse for this problem","category":"page"},{"location":"generated/examples/two_qubit_gates/","page":"Two Qubit Gates","title":"Two Qubit Gates","text":"min_time_prob_ms = UnitaryMinimumTimeProblem(prob_ms, U_goal_ms; final_fidelity=.9995)","category":"page"},{"location":"generated/examples/two_qubit_gates/","page":"Two Qubit Gates","title":"Two Qubit Gates","text":"and solve the problem","category":"page"},{"location":"generated/examples/two_qubit_gates/","page":"Two Qubit Gates","title":"Two Qubit Gates","text":"load_path = joinpath(dirname(Base.active_project()), \"data/two_qubit_gates_molmer_min_time_89ee72.jld2\") # hide\nmin_time_prob_ms.trajectory = load_traj(load_path) # hide\nnothing # hide","category":"page"},{"location":"generated/examples/two_qubit_gates/","page":"Two Qubit Gates","title":"Two Qubit Gates","text":"solve!(min_time_prob; max_iter=300)","category":"page"},{"location":"generated/examples/two_qubit_gates/","page":"Two Qubit Gates","title":"Two Qubit Gates","text":"        applying constraint: timesteps all equal constraint\n        applying constraint: initial value of Ũ⃗\n        applying constraint: initial value of u\n        applying constraint: final value of u\n        applying constraint: bounds on u\n        applying constraint: bounds on du\n        applying constraint: bounds on ddu\n        applying constraint: bounds on Δt\n        applying constraint: bounds on Ũ⃗\nThis is Ipopt version 3.14.19, running with linear solver MUMPS 5.8.1.\n\nNumber of nonzeros in equality constraint Jacobian...:    47302\nNumber of nonzeros in inequality constraint Jacobian.:       16\nNumber of nonzeros in Lagrangian Hessian.............:    23371\n\nTotal number of variables............................:     4460\n                     variables with only lower bounds:        0\n                variables with lower and upper bounds:     4460\n                     variables with only upper bounds:        0\nTotal number of equality constraints.................:     4059\nTotal number of inequality constraints...............:        1\n        inequality constraints with only lower bounds:        0\n   inequality constraints with lower and upper bounds:        0\n        inequality constraints with only upper bounds:        1\n\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n   0  1.2144896e+04 9.97e-03 1.00e+02   0.0 0.00e+00    -  0.00e+00 0.00e+00   0\n   1  1.2126203e+04 9.97e-03 1.76e+04   0.9 2.03e+01    -  1.18e-01 9.28e-05f  2\n   2  9.1682433e+03 9.31e-03 2.71e+05   0.8 4.52e+00    -  1.00e+00 6.62e-02f  1\n   3  8.2020717e+03 2.88e-03 6.37e+04   0.7 1.78e-01    -  1.00e+00 6.90e-01f  1\n   4  9.0133627e+03 1.38e-03 2.70e+04   0.9 1.57e-01    -  1.00e+00 5.21e-01h  1\n\n   <...snip...>\n 295r 1.3500591e+04 9.06e-04 3.82e+00  -4.0 7.41e-01    -  1.00e+00 1.80e-01f  1\n 296r 1.2434231e+04 4.55e-04 1.93e-01  -4.3 1.08e-01    -  9.02e-01 1.00e+00f  1\n 297r 1.2393849e+04 1.07e-04 1.45e-02  -4.3 2.66e-02    -  1.00e+00 1.00e+00h  1\n 298r 1.2391589e+04 9.61e-06 1.68e-03  -4.3 9.68e-03    -  1.00e+00 1.00e+00h  1\n 299r 1.2173834e+04 1.42e-05 7.36e-02  -6.5 2.20e-02    -  9.67e-01 1.00e+00f  1\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n 300r 1.2196795e+04 4.35e-07 1.15e-04  -6.5 2.32e-03    -  1.00e+00 1.00e+00h  1\n\nNumber of Iterations....: 300\n\n                                   (scaled)                 (unscaled)\nObjective...............:   1.2196794676744477e+04    1.2196794796608538e+04\nDual infeasibility......:   9.9999997730845053e+01    9.9999998713595531e+01\nConstraint violation....:   4.3514023147228631e-07    4.3514023147228631e-07\nVariable bound violation:   0.0000000000000000e+00    0.0000000000000000e+00\nComplementarity.........:   1.3299987986006171e-06    1.3299988116711870e-06\nOverall NLP error.......:   9.9999997730845053e+01    9.9999998713595531e+01\n\n\nNumber of objective function evaluations             = 343\nNumber of objective gradient evaluations             = 30\nNumber of equality constraint evaluations            = 343\nNumber of inequality constraint evaluations          = 343\nNumber of equality constraint Jacobian evaluations   = 302\nNumber of inequality constraint Jacobian evaluations = 302\nNumber of Lagrangian Hessian evaluations             = 300\nTotal seconds in IPOPT                               = 936.607\n\nEXIT: Maximum Number of Iterations Exceeded.\n</code><button class=\"copy-button fa-solid fa-copy\" aria-label=\"Copy this code block\" title=\"Copy\"></button></pre>","category":"page"},{"location":"generated/examples/two_qubit_gates/","page":"Two Qubit Gates","title":"Two Qubit Gates","text":"fid_final_min_time = unitary_rollout_fidelity(min_time_prob_ms.trajectory, sys)\nprintln(fid_final_min_time)\n@assert fid_final_min_time > 0.999","category":"page"},{"location":"generated/examples/two_qubit_gates/","page":"Two Qubit Gates","title":"Two Qubit Gates","text":"And let's plot this solution","category":"page"},{"location":"generated/examples/two_qubit_gates/","page":"Two Qubit Gates","title":"Two Qubit Gates","text":"plot_unitary_populations(min_time_prob_ms.trajectory)","category":"page"},{"location":"generated/examples/two_qubit_gates/","page":"Two Qubit Gates","title":"Two Qubit Gates","text":"It looks like our pulse derivative bounds are holding back the solution, but regardless, the duration has decreased:","category":"page"},{"location":"generated/examples/two_qubit_gates/","page":"Two Qubit Gates","title":"Two Qubit Gates","text":"duration = get_duration(prob_ms.trajectory)\nmin_time_duration = get_duration(min_time_prob_ms.trajectory)\nprintln(duration, \" - \", min_time_duration, \" = \", duration - min_time_duration)","category":"page"},{"location":"generated/examples/two_qubit_gates/","page":"Two Qubit Gates","title":"Two Qubit Gates","text":"","category":"page"},{"location":"generated/examples/two_qubit_gates/","page":"Two Qubit Gates","title":"Two Qubit Gates","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/examples/multilevel_transmon/#Multilevel-Transmon","page":"Multilevel Transmon","title":"Multilevel Transmon","text":"","category":"section"},{"location":"generated/examples/multilevel_transmon/","page":"Multilevel Transmon","title":"Multilevel Transmon","text":"In this example we will look at a multilevel transmon qubit with a Hamiltonian given by","category":"page"},{"location":"generated/examples/multilevel_transmon/","page":"Multilevel Transmon","title":"Multilevel Transmon","text":"hatH(t) = -fracdelta2 hatn(hatn - 1) + u_1(t) (hata + hata^dagger) + u_2(t) i (hata - hata^dagger)","category":"page"},{"location":"generated/examples/multilevel_transmon/","page":"Multilevel Transmon","title":"Multilevel Transmon","text":"where hatn = hata^dagger hata is the number operator, hata is the annihilation operator, delta is the anharmonicity, and u_1(t) and u_2(t) are control fields.","category":"page"},{"location":"generated/examples/multilevel_transmon/","page":"Multilevel Transmon","title":"Multilevel Transmon","text":"We will use the following parameter values:","category":"page"},{"location":"generated/examples/multilevel_transmon/","page":"Multilevel Transmon","title":"Multilevel Transmon","text":"beginaligned\ndelta = 02 text GHz\nabsu_i(t) leq 02 text GHz\nT_0 = 10 text ns\nendaligned","category":"page"},{"location":"generated/examples/multilevel_transmon/","page":"Multilevel Transmon","title":"Multilevel Transmon","text":"For convenience, we have defined the TransmonSystem function in the QuantumSystemTemplates module, which returns a QuantumSystem object for a transmon qubit. We will use this function to define the system.","category":"page"},{"location":"generated/examples/multilevel_transmon/#Setting-up-the-problem","page":"Multilevel Transmon","title":"Setting up the problem","text":"","category":"section"},{"location":"generated/examples/multilevel_transmon/","page":"Multilevel Transmon","title":"Multilevel Transmon","text":"To begin, let's load the necessary packages, define the system parameters, and create a a QuantumSystem object using the TransmonSystem function.","category":"page"},{"location":"generated/examples/multilevel_transmon/","page":"Multilevel Transmon","title":"Multilevel Transmon","text":"using QuantumCollocation\nusing PiccoloQuantumObjects\nusing NamedTrajectories\nusing LinearAlgebra\nusing SparseArrays\nusing Random; Random.seed!(123)\n\nusing PiccoloPlots\nusing CairoMakie\n\n# define the time parameters\n\nT₀ = 10.0   # total time in ns\nN = 50      # number of time steps\nΔt = T₀ / N # time step\n\n# define the system parameters\nlevels = 5\nδ = 0.2\n\n# add a bound to the controls\nu_bounds = [0.2, 0.2]\n\n# create the system\nsys = TransmonSystem(levels=levels, δ=δ, T_max=T₀, u_bounds=u_bounds)\n\n# let's look at a drive\nget_drives(sys)[1] |> sparse","category":"page"},{"location":"generated/examples/multilevel_transmon/","page":"Multilevel Transmon","title":"Multilevel Transmon","text":"Since this is a multilevel transmon and we want to implement an, let's say, X gate on the qubit subspace, i.e., the first two levels we can utilize the EmbeddedOperator type to define the target operator.","category":"page"},{"location":"generated/examples/multilevel_transmon/","page":"Multilevel Transmon","title":"Multilevel Transmon","text":"# define the target operator\nop = EmbeddedOperator(:X, sys)\n\n# show the full operator\nop.operator |> sparse","category":"page"},{"location":"generated/examples/multilevel_transmon/","page":"Multilevel Transmon","title":"Multilevel Transmon","text":"In this formulation, we also use a subspace identity as the initial state, which looks like","category":"page"},{"location":"generated/examples/multilevel_transmon/","page":"Multilevel Transmon","title":"Multilevel Transmon","text":"function get_subspace_identity(op::EmbeddedOperator)\n    return embed(\n        Matrix{ComplexF64}(I(length(op.subspace))),\n        op.subspace,\n        size(op)[1]\n    )\nend\nget_subspace_identity(op) |> sparse","category":"page"},{"location":"generated/examples/multilevel_transmon/","page":"Multilevel Transmon","title":"Multilevel Transmon","text":"We can then pass this embedded operator to the UnitarySmoothPulseProblem template to create the problem","category":"page"},{"location":"generated/examples/multilevel_transmon/","page":"Multilevel Transmon","title":"Multilevel Transmon","text":"# create the problem\nprob = UnitarySmoothPulseProblem(sys, op, N, Δt)\n\n# solve the problem\nload_path = joinpath(dirname(Base.active_project()), \"data/multilevel_transmon_example_89ee72.jld2\") # hide\nprob.trajectory = load_traj(load_path) # hide\nnothing # hide","category":"page"},{"location":"generated/examples/multilevel_transmon/","page":"Multilevel Transmon","title":"Multilevel Transmon","text":"solve!(prob; max_iter=50)","category":"page"},{"location":"generated/examples/multilevel_transmon/","page":"Multilevel Transmon","title":"Multilevel Transmon","text":"<pre class=\"documenter-example-output\"><code class=\"nohighlight hljs ansi\">    initializing optimizer...\n        applying constraint: timesteps all equal constraint\n        applying constraint: initial value of Ũ⃗\n        applying constraint: initial value of u\n        applying constraint: final value of u\n        applying constraint: bounds on u\n        applying constraint: bounds on du\n        applying constraint: bounds on ddu\n        applying constraint: bounds on Δt\n\n******************************************************************************\nThis program contains Ipopt, a library for large-scale nonlinear optimization.\n Ipopt is released as open source code under the Eclipse Public License (EPL).\n         For more information visit https://github.com/coin-or/Ipopt\n******************************************************************************\n\nThis is Ipopt version 3.14.19, running with linear solver MUMPS 5.8.1.\n\nNumber of nonzeros in equality constraint Jacobian...:   130578\nNumber of nonzeros in inequality constraint Jacobian.:        0\nNumber of nonzeros in Lagrangian Hessian.............:    11223\n\nTotal number of variables............................:     2796\n                     variables with only lower bounds:        0\n                variables with lower and upper bounds:      246\n                     variables with only upper bounds:        0\nTotal number of equality constraints.................:     2695\nTotal number of inequality constraints...............:        0\n        inequality constraints with only lower bounds:        0\n   inequality constraints with lower and upper bounds:        0\n        inequality constraints with only upper bounds:        0\n\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n   0  6.3299435e-04 9.98e-01 1.21e+01   0.0 0.00e+00    -  0.00e+00 0.00e+00   0\n   1  1.7461331e+01 4.87e-01 3.66e+03  -0.6 1.02e+00   2.0 6.32e-01 5.00e-01h  2\n   2  1.1690187e+01 1.94e-01 6.11e+03   0.0 9.75e-01   2.4 1.00e+00 6.00e-01h  1\n   3  1.0956380e+00 1.36e-01 4.05e+03  -0.3 6.45e-01   2.9 1.00e+00 3.00e-01f  1\n   4  3.9110348e+00 1.13e-01 3.98e+03  -1.0 5.07e-01   3.3 1.00e+00 1.68e-01h  1\n\n< ...snip... >\n\n  45  3.3045607e-01 3.45e-06 9.48e-02  -4.0 4.85e-03   0.9 1.00e+00 1.00e+00f  1\n  46  2.9815119e-01 2.50e-05 8.55e-02  -4.0 1.35e-02   0.4 1.00e+00 1.00e+00h  1\n  47  2.8948071e-01 3.32e-06 3.25e-02  -4.1 4.88e-03   0.8 1.00e+00 1.00e+00h  1\n  48  2.5998426e-01 2.55e-05 6.31e-02  -4.0 1.35e-02   0.3 1.00e+00 1.00e+00h  1\n  49  2.5126499e-01 3.58e-06 2.93e-02  -4.1 4.94e-03   0.8 1.00e+00 1.00e+00h  1\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n  50  2.2337171e-01 2.87e-05 8.86e-02  -4.0 1.34e-02   0.3 1.00e+00 1.00e+00h  1\n\nNumber of Iterations....: 50\n\n                                   (scaled)                 (unscaled)\nObjective...............:   2.2337171204275508e-01    2.2337171204275508e-01\nDual infeasibility......:   8.8610846418504252e-02    8.8610846418504252e-02\nConstraint violation....:   2.8712906816219519e-05    2.8712906816219519e-05\nVariable bound violation:   0.0000000000000000e+00    0.0000000000000000e+00\nComplementarity.........:   1.0048178594192366e-04    1.0048178594192366e-04\nOverall NLP error.......:   8.8610846418504252e-02    8.8610846418504252e-02\n\n\nNumber of objective function evaluations             = 55\nNumber of objective gradient evaluations             = 51\nNumber of equality constraint evaluations            = 55\nNumber of inequality constraint evaluations          = 0\nNumber of equality constraint Jacobian evaluations   = 51\nNumber of inequality constraint Jacobian evaluations = 0\nNumber of Lagrangian Hessian evaluations             = 50\nTotal seconds in IPOPT                               = 330.056\n\nEXIT: Maximum Number of Iterations Exceeded.\n</code><button class=\"copy-button fa-solid fa-copy\" aria-label=\"Copy this code block\" title=\"Copy\"></button></pre>","category":"page"},{"location":"generated/examples/multilevel_transmon/","page":"Multilevel Transmon","title":"Multilevel Transmon","text":"Let's look at the fidelity in the subspace","category":"page"},{"location":"generated/examples/multilevel_transmon/","page":"Multilevel Transmon","title":"Multilevel Transmon","text":"fid = unitary_rollout_fidelity(prob.trajectory, sys; subspace=op.subspace)\nprintln(\"Fidelity: \", fid)\n@assert fid > 0.99","category":"page"},{"location":"generated/examples/multilevel_transmon/","page":"Multilevel Transmon","title":"Multilevel Transmon","text":"and plot the result using the plot_unitary_populations function.","category":"page"},{"location":"generated/examples/multilevel_transmon/","page":"Multilevel Transmon","title":"Multilevel Transmon","text":"plot_unitary_populations(prob.trajectory; fig_size=(900, 700))","category":"page"},{"location":"generated/examples/multilevel_transmon/#Leakage-suppresion","page":"Multilevel Transmon","title":"Leakage suppresion","text":"","category":"section"},{"location":"generated/examples/multilevel_transmon/","page":"Multilevel Transmon","title":"Multilevel Transmon","text":"As can be seen from the above plot, there is a substantial amount of leakage into the higher levels during the evolution. To mitigate this, we have implemented a constraint to avoid populating the leakage levels, which should ideally drive those leakage populations down to zero. To implement this, pass leakage_constraint=true and set leakage_constraint_value={value} and leakage_cost={value} to the PiccoloOptions instance passed to the UnitarySmoothPulseProblem template.","category":"page"},{"location":"generated/examples/multilevel_transmon/","page":"Multilevel Transmon","title":"Multilevel Transmon","text":"# create the a leakage suppression problem, initializing with the previous solution\n\nprob_leakage = UnitarySmoothPulseProblem(sys, op, N, Δt;\n    u_guess=prob.trajectory.u[:, :],\n    piccolo_options=PiccoloOptions(\n        leakage_constraint=true,\n        leakage_constraint_value=1e-2,\n        leakage_cost=1e-2,\n    ),\n)\n\n# solve the problem\nload_path = joinpath(dirname(Base.active_project()), \"data/multilevel_transmon_example_leakage_89ee72.jld2\") # hide\nprob_leakage.trajectory = load_traj(load_path) # hide\nnothing # hide","category":"page"},{"location":"generated/examples/multilevel_transmon/","page":"Multilevel Transmon","title":"Multilevel Transmon","text":"solve!(prob_leakage; max_iter=250)","category":"page"},{"location":"generated/examples/multilevel_transmon/","page":"Multilevel Transmon","title":"Multilevel Transmon","text":"<pre class=\"documenter-example-output\"><code class=\"nohighlight hljs ansi\">    initializing optimizer...\n        applying constraint: timesteps all equal constraint\n        applying constraint: initial value of Ũ⃗\n        applying constraint: initial value of u\n        applying constraint: final value of u\n        applying constraint: bounds on u\n        applying constraint: bounds on du\n        applying constraint: bounds on ddu\n        applying constraint: bounds on Δt\nThis is Ipopt version 3.14.19, running with linear solver MUMPS 5.8.1.\n\nNumber of nonzeros in equality constraint Jacobian...:   130578\nNumber of nonzeros in inequality constraint Jacobian.:    58800\nNumber of nonzeros in Lagrangian Hessian.............:   196198\n\nTotal number of variables............................:     2796\n                     variables with only lower bounds:        0\n                variables with lower and upper bounds:      246\n                     variables with only upper bounds:        0\nTotal number of equality constraints.................:     2695\nTotal number of inequality constraints...............:     1200\n        inequality constraints with only lower bounds:        0\n   inequality constraints with lower and upper bounds:        0\n        inequality constraints with only upper bounds:     1200\n\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n   0  2.2434810e-01 1.80e-01 2.30e-01   0.0 0.00e+00    -  0.00e+00 0.00e+00   0\n   1  5.1360583e-01 1.65e-01 1.95e+02  -1.4 7.80e-01   0.0 3.96e-01 1.19e-01h  1\n   2  3.3978388e-01 1.50e-01 1.74e+02  -2.6 9.24e-01    -  1.15e-01 1.04e-01h  1\n   3  1.5298834e-01 1.41e-01 1.63e+02  -1.4 1.88e+00    -  1.06e-01 6.31e-02f  1\n   4  1.7494458e-01 1.29e-01 4.47e+01  -2.1 1.72e+00    -  9.03e-02 8.41e-02h  1\n\n<...snip...>\n\n 245  1.7381917e-03 3.01e-05 1.70e-02  -4.0 1.37e-02  -2.4 1.00e+00 1.00e+00h  1\n 246  1.7355438e-03 1.21e-05 1.17e-02  -4.0 1.11e-02  -2.0 1.00e+00 1.00e+00h  1\n 247  1.7084108e-03 5.16e-05 2.32e-02  -4.0 1.95e-02  -2.4 1.00e+00 1.00e+00h  1\n 248  1.7080428e-03 2.11e-05 1.73e-02  -4.0 1.68e-02  -2.0 1.00e+00 1.00e+00h  1\n\n 250  1.6487637e-03 4.14e-05 2.81e-02  -4.0 2.77e-02  -2.1 1.00e+00 1.00e+00h  1\n\nNumber of Iterations....: 250\n\n                                   (scaled)                 (unscaled)\nObjective...............:   1.6487637480209457e-03    1.6487637480209457e-03\nDual infeasibility......:   2.8069428563796350e-02    2.8069428563796350e-02\nConstraint violation....:   4.1350575226820063e-05    4.1350575226820063e-05\nVariable bound violation:   0.0000000000000000e+00    0.0000000000000000e+00\nComplementarity.........:   1.0000000000000002e-04    1.0000000000000002e-04\nOverall NLP error.......:   2.8069428563796350e-02    2.8069428563796350e-02\n\n\nNumber of objective function evaluations             = 270\nNumber of objective gradient evaluations             = 251\nNumber of equality constraint evaluations            = 270\nNumber of inequality constraint evaluations          = 270\nNumber of equality constraint Jacobian evaluations   = 251\nNumber of inequality constraint Jacobian evaluations = 251\nNumber of Lagrangian Hessian evaluations             = 250\nTotal seconds in IPOPT                               = 1864.901\n\nEXIT: Maximum Number of Iterations Exceeded.\n</code><button class=\"copy-button fa-solid fa-copy\" aria-label=\"Copy this code block\" title=\"Copy\"></button></pre>","category":"page"},{"location":"generated/examples/multilevel_transmon/","page":"Multilevel Transmon","title":"Multilevel Transmon","text":"Let's look at the fidelity in the subspace","category":"page"},{"location":"generated/examples/multilevel_transmon/","page":"Multilevel Transmon","title":"Multilevel Transmon","text":"fid_leakage = unitary_rollout_fidelity(prob_leakage.trajectory, sys; subspace=op.subspace)\nprintln(\"Fidelity: \", fid_leakage)\n@assert fid_leakage > 0.99","category":"page"},{"location":"generated/examples/multilevel_transmon/","page":"Multilevel Transmon","title":"Multilevel Transmon","text":"and plot the result using the plot_unitary_populations function.","category":"page"},{"location":"generated/examples/multilevel_transmon/","page":"Multilevel Transmon","title":"Multilevel Transmon","text":"plot_unitary_populations(prob_leakage.trajectory; fig_size=(900, 700))","category":"page"},{"location":"generated/examples/multilevel_transmon/","page":"Multilevel Transmon","title":"Multilevel Transmon","text":"Here we can see that the leakage populations have been driven substantially down.","category":"page"},{"location":"generated/examples/multilevel_transmon/","page":"Multilevel Transmon","title":"Multilevel Transmon","text":"","category":"page"},{"location":"generated/examples/multilevel_transmon/","page":"Multilevel Transmon","title":"Multilevel Transmon","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/man/unitary_problem_templates/","page":"Unitary Problem Templates","title":"Unitary Problem Templates","text":"using NamedTrajectories\nusing PiccoloQuantumObjects\nusing QuantumCollocation","category":"page"},{"location":"generated/man/unitary_problem_templates/","page":"Unitary Problem Templates","title":"Unitary Problem Templates","text":"","category":"page"},{"location":"generated/man/unitary_problem_templates/#Unitary-Smooth-Pulse-Problem","page":"Unitary Problem Templates","title":"Unitary Smooth Pulse Problem","text":"","category":"section"},{"location":"generated/man/unitary_problem_templates/#QuantumCollocation.ProblemTemplates.UnitarySmoothPulseProblem-generated-man-unitary_problem_templates","page":"Unitary Problem Templates","title":"QuantumCollocation.ProblemTemplates.UnitarySmoothPulseProblem","text":"UnitarySmoothPulseProblem(system::AbstractQuantumSystem, operator::AbstractPiccoloOperator, T::Int, Δt::Float64; kwargs...)\nUnitarySmoothPulseProblem(H_drift, H_drives, operator, T, Δt; kwargs...)\n\nConstruct a DirectTrajOptProblem for a free-time unitary gate problem with smooth control pulses enforced by constraining the second derivative of the pulse trajectory, i.e.,\n\nbeginaligned\nundersetvectildeU u dotu ddotu Delta ttextminimize  quad\nQ cdot ellqty(vectildeU_T vectildeU_textgoal) + frac12 sum_t qty(R_u u_t^2 + R_dotu dotu_t^2 + R_ddotu ddotu_t^2) \ntext subject to   quad vbP^(n)qty(vectildeU_t+1 vectildeU_t u_t Delta t_t) = 0 \n quad u_t+1 - u_t - dotu_t Delta t_t = 0 \n quad dotu_t+1 - dotu_t - ddotu_t Delta t_t = 0 \n quad u_t leq u_textbound \n quad ddotu_t leq ddotu_textbound \n quad Delta t_textmin leq Delta t_t leq Delta t_textmax \nendaligned\n\nwhere, for U in SU(N),\n\nellqty(vectildeU_T vectildeU_textgoal) =\nabs1 - frac1N abs tr qty(U_textgoal U_T) \n\nis the infidelity objective function, Q is a weight, R_u, R_dotu, and R_ddotu are weights on the regularization terms, and vbP^(n) is the nth-order Pade integrator.\n\nArguments\n\nsystem::AbstractQuantumSystem: the system to be controlled\n\nor\n\nH_drift::AbstractMatrix{<:Number}: the drift hamiltonian\nH_drives::Vector{<:AbstractMatrix{<:Number}}: the control hamiltonians\n\nwith\n\ngoal::AbstractPiccoloOperator: the target unitary, either in the form of an EmbeddedOperator or a `Matrix{ComplexF64}\nT::Int: the number of timesteps\nΔt::Float64: the (initial) time step size\n\nKeyword Arguments\n\npiccolo_options::PiccoloOptions=PiccoloOptions(): the options for the Piccolo solver\nstate_name::Symbol = :Ũ⃗: the name of the state\ncontrol_name::Symbol = :u: the name of the control\ntimestep_name::Symbol = :Δt: the name of the timestep\ninit_trajectory::Union{NamedTrajectory, Nothing}=nothing: an initial trajectory to use\nu_guess::Union{Matrix{Float64}, Nothing}=nothing: an initial guess for the control pulses\nu_bound::Float64=1.0: the bound on the control pulse\nu_bounds=fill(u_bound, length(system.G_drives)): the bounds on the control pulses, one for each drive\ndu_bound::Float64=Inf: the bound on the control pulse derivative\ndu_bounds=fill(du_bound, length(system.G_drives)): the bounds on the control pulse derivatives, one for each drive\nddu_bound::Float64=1.0: the bound on the control pulse second derivative\nddu_bounds=fill(ddu_bound, length(system.G_drives)): the bounds on the control pulse second derivatives, one for each drive\nΔt_min::Float64=Δt isa Float64 ? 0.5 * Δt : 0.5 * mean(Δt): the minimum time step size\nΔt_max::Float64=Δt isa Float64 ? 1.5 * Δt : 1.5 * mean(Δt): the maximum time step size\nQ::Float64=100.0: the weight on the infidelity objective\nR=1e-2: the weight on the regularization terms\nR_u::Union{Float64, Vector{Float64}}=R: the weight on the regularization term for the control pulses\nR_du::Union{Float64, Vector{Float64}}=R: the weight on the regularization term for the control pulse derivatives\nR_ddu::Union{Float64, Vector{Float64}}=R: the weight on the regularization term for the control pulse second derivatives\nconstraints::Vector{<:AbstractConstraint}=AbstractConstraint[]: the constraints to enforce\n\n\n\n\n\n","category":"function"},{"location":"generated/man/unitary_problem_templates/","page":"Unitary Problem Templates","title":"Unitary Problem Templates","text":"The UnitarySmoothPulseProblem is similar to the QuantumStateSmoothPulseProblem, but instead of driving the system to a target state, the goal is to drive the system to a target unitary operator, U_goal.","category":"page"},{"location":"generated/man/unitary_problem_templates/","page":"Unitary Problem Templates","title":"Unitary Problem Templates","text":"T_max = 1.0\nu_bounds = [(-1.0, 1.0), (-1.0, 1.0)]\nsystem = QuantumSystem(0.1 * PAULIS.Z, [PAULIS.X, PAULIS.Y], T_max, u_bounds)\nU_goal = GATES.H\nN = 51\nΔt = 0.2\n\nprob = UnitarySmoothPulseProblem(system, U_goal, N, Δt);\nnothing #hide","category":"page"},{"location":"generated/man/unitary_problem_templates/","page":"Unitary Problem Templates","title":"Unitary Problem Templates","text":"check the fidelity before solving","category":"page"},{"location":"generated/man/unitary_problem_templates/","page":"Unitary Problem Templates","title":"Unitary Problem Templates","text":"println(\"Before: \", unitary_rollout_fidelity(prob.trajectory, system))","category":"page"},{"location":"generated/man/unitary_problem_templates/","page":"Unitary Problem Templates","title":"Unitary Problem Templates","text":"finding an optimal control is as simple as calling solve!","category":"page"},{"location":"generated/man/unitary_problem_templates/","page":"Unitary Problem Templates","title":"Unitary Problem Templates","text":"load_path = joinpath(dirname(Base.active_project()), \"data/unitary_problem_templates_89ee72.jld2\") # hide\nprob.trajectory = load_traj(load_path) # hide\nnothing # hide","category":"page"},{"location":"generated/man/unitary_problem_templates/","page":"Unitary Problem Templates","title":"Unitary Problem Templates","text":"solve!(prob, max_iter=100, verbose=true, print_level=1);","category":"page"},{"location":"generated/man/unitary_problem_templates/","page":"Unitary Problem Templates","title":"Unitary Problem Templates","text":"<pre class=\"documenter-example-output\"><code class=\"nohighlight hljs ansi\">    initializing optimizer...\n        applying constraint: timesteps all equal constraint\n        applying constraint: initial value of Ũ⃗\n        applying constraint: initial value of u\n        applying constraint: final value of u\n        applying constraint: bounds on u\n        applying constraint: bounds on du\n        applying constraint: bounds on ddu\n        applying constraint: bounds on Δt\n\n******************************************************************************\nThis program contains Ipopt, a library for large-scale nonlinear optimization.\n Ipopt is released as open source code under the Eclipse Public License (EPL).\n         For more information visit https://github.com/coin-or/Ipopt\n******************************************************************************\n</code><button class=\"copy-button fa-solid fa-copy\" aria-label=\"Copy this code block\" title=\"Copy\"></button></pre>","category":"page"},{"location":"generated/man/unitary_problem_templates/","page":"Unitary Problem Templates","title":"Unitary Problem Templates","text":"check the fidelity after solving","category":"page"},{"location":"generated/man/unitary_problem_templates/","page":"Unitary Problem Templates","title":"Unitary Problem Templates","text":"println(\"After: \", unitary_rollout_fidelity(prob.trajectory, system))","category":"page"},{"location":"generated/man/unitary_problem_templates/","page":"Unitary Problem Templates","title":"Unitary Problem Templates","text":"The NamedTrajectory object stores the control pulse, state variables, and the time grid.","category":"page"},{"location":"generated/man/unitary_problem_templates/","page":"Unitary Problem Templates","title":"Unitary Problem Templates","text":"extract the control pulses","category":"page"},{"location":"generated/man/unitary_problem_templates/","page":"Unitary Problem Templates","title":"Unitary Problem Templates","text":"prob.trajectory.u |> size","category":"page"},{"location":"generated/man/unitary_problem_templates/","page":"Unitary Problem Templates","title":"Unitary Problem Templates","text":"","category":"page"},{"location":"generated/man/unitary_problem_templates/#Unitary-Minimum-Time-Problem","page":"Unitary Problem Templates","title":"Unitary Minimum Time Problem","text":"","category":"section"},{"location":"generated/man/unitary_problem_templates/#QuantumCollocation.ProblemTemplates.UnitaryMinimumTimeProblem-generated-man-unitary_problem_templates","page":"Unitary Problem Templates","title":"QuantumCollocation.ProblemTemplates.UnitaryMinimumTimeProblem","text":"UnitaryMinimumTimeProblem(\n    goal::AbstractPiccoloOperator,\n    trajectory::NamedTrajectory,\n    objective::Objective,\n    dynamics::TrajectoryDynamics,\n    constraints::AbstractVector{<:AbstractConstraint};\n    kwargs...\n)\n\nUnitaryMinimumTimeProblem(\n    goal::AbstractPiccoloOperator,\n    prob::DirectTrajOptProblem;\n    kwargs...\n)\n\nCreate a minimum-time problem for unitary control.\n\nbeginaligned\nundersetvectildeU u dotu ddotu Delta ttextminimize  quad\nJ(vectildeU u dotu ddotu) + D sum_t Delta t_t \ntext subject to   quad vbP^(n)qty(vectildeU_t+1 vectildeU_t u_t Delta t_t) = 0 \n c(vectildeU u dotu ddotu) = 0 \n quad Delta t_textmin leq Delta t_t leq Delta t_textmax \nendaligned\n\nKeyword Arguments\n\npiccolo_options::PiccoloOptions=PiccoloOptions(): The Piccolo options.\nunitary_name::Symbol=:Ũ⃗: The name of the unitary for the goal.\nfinal_fidelity::Float64=1.0: The final fidelity constraint.\nD::Float64=1.0: The scaling factor for the minimum-time objective.\n\n\n\n\n\n","category":"function"},{"location":"generated/man/unitary_problem_templates/","page":"Unitary Problem Templates","title":"Unitary Problem Templates","text":"The goal of this problem is to find the shortest time it takes to drive the system to a target unitary operator, U_goal. The problem is solved by minimizing the sum of all of the time steps. It is constructed from prob in the previous example.","category":"page"},{"location":"generated/man/unitary_problem_templates/","page":"Unitary Problem Templates","title":"Unitary Problem Templates","text":"min_prob = UnitaryMinimumTimeProblem(prob, U_goal);\nnothing #hide","category":"page"},{"location":"generated/man/unitary_problem_templates/","page":"Unitary Problem Templates","title":"Unitary Problem Templates","text":"check the previous duration","category":"page"},{"location":"generated/man/unitary_problem_templates/","page":"Unitary Problem Templates","title":"Unitary Problem Templates","text":"println(\"Duration before: \", get_duration(prob.trajectory))","category":"page"},{"location":"generated/man/unitary_problem_templates/","page":"Unitary Problem Templates","title":"Unitary Problem Templates","text":"solve the minimum time problem","category":"page"},{"location":"generated/man/unitary_problem_templates/","page":"Unitary Problem Templates","title":"Unitary Problem Templates","text":"load_path = joinpath(dirname(Base.active_project()), \"data/unitary_problem_templates_min_time_89ee72.jld2\") # hide\nmin_prob.trajectory = load_traj(load_path) # hide\nnothing # hide","category":"page"},{"location":"generated/man/unitary_problem_templates/","page":"Unitary Problem Templates","title":"Unitary Problem Templates","text":"solve!(min_prob, max_iter=100, verbose=true, print_level=1);","category":"page"},{"location":"generated/man/unitary_problem_templates/","page":"Unitary Problem Templates","title":"Unitary Problem Templates","text":"<pre class=\"documenter-example-output\"><code class=\"nohighlight hljs ansi\">    initializing optimizer...\n        applying constraint: timesteps all equal constraint\n        applying constraint: initial value of Ũ⃗\n        applying constraint: initial value of u\n        applying constraint: final value of u\n        applying constraint: bounds on u\n        applying constraint: bounds on du\n        applying constraint: bounds on ddu\n        applying constraint: bounds on Δt\n</code><button class=\"copy-button fa-solid fa-copy\" aria-label=\"Copy this code block\" title=\"Copy\"></button></pre>","category":"page"},{"location":"generated/man/unitary_problem_templates/","page":"Unitary Problem Templates","title":"Unitary Problem Templates","text":"check the new duration","category":"page"},{"location":"generated/man/unitary_problem_templates/","page":"Unitary Problem Templates","title":"Unitary Problem Templates","text":"println(\"Duration after: \", get_duration(min_prob.trajectory))","category":"page"},{"location":"generated/man/unitary_problem_templates/","page":"Unitary Problem Templates","title":"Unitary Problem Templates","text":"the fidelity is preserved by a constraint","category":"page"},{"location":"generated/man/unitary_problem_templates/","page":"Unitary Problem Templates","title":"Unitary Problem Templates","text":"println(\"Fidelity after: \", unitary_rollout_fidelity(min_prob.trajectory, system))","category":"page"},{"location":"generated/man/unitary_problem_templates/","page":"Unitary Problem Templates","title":"Unitary Problem Templates","text":"","category":"page"},{"location":"generated/man/unitary_problem_templates/#Unitary-Sampling-Problem","page":"Unitary Problem Templates","title":"Unitary Sampling Problem","text":"","category":"section"},{"location":"generated/man/unitary_problem_templates/#QuantumCollocation.ProblemTemplates.UnitarySamplingProblem-generated-man-unitary_problem_templates","page":"Unitary Problem Templates","title":"QuantumCollocation.ProblemTemplates.UnitarySamplingProblem","text":"UnitarySamplingProblem(systemns, operator, T, Δt; kwargs...)\n\nA UnitarySamplingProblem is a quantum control problem where the goal is to find a control pulse that generates a target unitary operator for a set of quantum systems. The controls are shared among all systems, and the optimization seeks to find the control pulse that achieves the operator for each system. The idea is to enforce a robust solution by including multiple systems reflecting the problem uncertainty.\n\nArguments\n\nsystems::AbstractVector{<:AbstractQuantumSystem}: A vector of quantum systems.\noperators::AbstractVector{<:AbstractPiccoloOperator}: A vector of target operators.\nT::Int: The number of time steps.\nΔt::Union{Float64, Vector{Float64}}: The time step value or vector of time steps.\n\nKeyword Arguments\n\nsystem_labels::Vector{String} = string.(1:length(systems)): The labels for each system.\nsystem_weights::Vector{Float64} = fill(1.0, length(systems)): The weights for each system.\ninit_trajectory::Union{NamedTrajectory, Nothing} = nothing: The initial trajectory.\nstate_name::Symbol = :Ũ⃗: The name of the state variable.\ncontrol_name::Symbol = :u: The name of the control variable.\ntimestep_name::Symbol = :Δt: The name of the timestep variable.\nconstraints::Vector{<:AbstractConstraint} = AbstractConstraint[]: The constraints.\nu_bound::Float64 = 1.0: The bound for the control amplitudes.\nu_bounds = fill(u_bound, length(systems[1].G_drives)): The bounds for the control amplitudes.\nu_guess::Union{Matrix{Float64}, Nothing} = nothing: The initial guess for the control amplitudes.\ndu_bound::Float64 = Inf: The bound for the control first derivatives.\ndu_bounds = fill(du_bound, length(systems[1].G_drives)): The bounds for the control first derivatives.\nddu_bound::Float64 = 1.0: The bound for the control second derivatives.\nddu_bounds = fill(ddu_bound, length(systems[1].G_drives)): The bounds for the control second derivatives.\nΔt_min::Float64 = 0.5 * Δt: The minimum time step size.\nΔt_max::Float64 = 1.5 * Δt: The maximum time step size.\nQ::Float64 = 100.0: The fidelity weight.\nR::Float64 = 1e-2: The regularization weight.\nR_u::Union{Float64, Vector{Float64}} = R: The regularization weight for the control amplitudes.\nR_du::Union{Float64, Vector{Float64}} = R: The regularization weight for the control first derivatives.\nR_ddu::Union{Float64, Vector{Float64}} = R: The regularization weight for the control second derivatives.\npiccolo_options::PiccoloOptions = PiccoloOptions(): The Piccolo options.\n\n\n\n\n\n","category":"function"},{"location":"generated/man/unitary_problem_templates/","page":"Unitary Problem Templates","title":"Unitary Problem Templates","text":"A sampling problem is used to solve over multiple quantum systems with the same control. This can be useful for exploring robustness, for example.","category":"page"},{"location":"generated/man/unitary_problem_templates/","page":"Unitary Problem Templates","title":"Unitary Problem Templates","text":"create a sampling problem","category":"page"},{"location":"generated/man/unitary_problem_templates/","page":"Unitary Problem Templates","title":"Unitary Problem Templates","text":"T_max = 1.0\nu_bounds = [(-1.0, 1.0), (-1.0, 1.0)]\ndriftless_system = QuantumSystem([PAULIS.X, PAULIS.Y], T_max, u_bounds)\nsampling_prob = UnitarySamplingProblem([system, driftless_system], U_goal, N, Δt);\nnothing #hide","category":"page"},{"location":"generated/man/unitary_problem_templates/","page":"Unitary Problem Templates","title":"Unitary Problem Templates","text":"new keys are addded to the trajectory for the new states","category":"page"},{"location":"generated/man/unitary_problem_templates/","page":"Unitary Problem Templates","title":"Unitary Problem Templates","text":"println(sampling_prob.trajectory.state_names)","category":"page"},{"location":"generated/man/unitary_problem_templates/","page":"Unitary Problem Templates","title":"Unitary Problem Templates","text":"the solve! proceeds as in the Quantum State Sampling Problem]","category":"page"},{"location":"generated/man/unitary_problem_templates/","page":"Unitary Problem Templates","title":"Unitary Problem Templates","text":"","category":"page"},{"location":"generated/man/unitary_problem_templates/#Unitary-Variational-Problem","page":"Unitary Problem Templates","title":"Unitary Variational Problem","text":"","category":"section"},{"location":"generated/man/unitary_problem_templates/#QuantumCollocation.ProblemTemplates.UnitaryVariationalProblem-generated-man-unitary_problem_templates","page":"Unitary Problem Templates","title":"QuantumCollocation.ProblemTemplates.UnitaryVariationalProblem","text":"UnitaryVariationalProblem(\n    system::VariationalQuantumSystem,\n    goal::AbstractPiccoloOperator,\n    T::Int,\n    Δt::Union{Float64, <:AbstractVector{Float64}};\n    robust_times::AbstractVector{<:Union{AbstractVector{Int}, Nothing}}=[nothing for s ∈ system.G_vars],\n    sensitive_times::AbstractVector{<:Union{AbstractVector{Int}, Nothing}}=[nothing for s ∈ system.G_vars],\n    kwargs...\n)\n\nConstructs a unitary variational problem for optimizing quantum control trajectories.\n\nArguments\n\nsystem::VariationalQuantumSystem: The quantum system to be controlled, containing variational parameters.\ngoal::AbstractPiccoloOperator: The target operator or state to achieve at the end of the trajectory.\nT::Int: The total number of timesteps in the trajectory.\nΔt::Union{Float64, <:AbstractVector{Float64}}: The timestep duration or a vector of timestep durations.\n\nKeyword Arguments\n\nrobust_times::AbstractVector: Times at which robustness to variations in the trajectory is enforced.\nsensitive_times::AbstractVector: Times at which sensitivity to variations in the trajectory is enhanced.\nunitary_integrator: The integrator used for unitary evolution (default: VariationalUnitaryIntegrator).\nstate_name::Symbol: The name of the state variable in the trajectory (default: :Ũ⃗).\nvariational_state_name::Symbol: The name of the variational state variable (default: :Ũ⃗ᵥ).\nvariational_scales::AbstractVector: Scaling factors for the variational state variables (default: 1.0).\ncontrol_name::Symbol: The name of the control variable (default: :u).\ntimestep_name::Symbol: The name of the timestep variable (default: :Δt).\ninit_trajectory::Union{NamedTrajectory, Nothing}: An optional initial trajectory to start optimization.\nu_bound::Float64: The bound for the control variable u (default: 1.0).\nu_bounds: Bounds for each control variable (default: filled with u_bound).\ndu_bound::Float64: The bound for the derivative of the control variable (default: Inf).\ndu_bounds: Bounds for each derivative of the control variable.\nddu_bound::Float64: The bound for the second derivative of the control variable (default: 1.0).\nddu_bounds: Bounds for each second derivative of the control variable.\nΔt_min::Float64: Minimum allowed timestep duration.\nΔt_max::Float64: Maximum allowed timestep duration.\nQ::Float64: Weight for the unitary infidelity objective (default: 100.0).\nQ_v::Float64: Weight for sensitivity objectives (default: 1.0).\nR: Regularization weight for control variables (default: 1e-2).\nR_u, R_du, R_ddu: Regularization weights for control, its derivative, and second derivative.\nconstraints::Vector: Additional constraints for the optimization problem.\npiccolo_options::PiccoloOptions: Options for configuring the Piccolo optimization framework.\n\nReturns\n\nA DirectTrajOptProblem object representing the optimization problem, including the trajectory, objective, integrators, and constraints.\n\nNotes\n\nThis function constructs a trajectory optimization problem for quantum control using variational principles. It supports robust and sensitive trajectory design, regularization, and optional constraints. The problem is solved using the Piccolo optimization framework.\n\n\n\n\n\n","category":"function"},{"location":"generated/man/unitary_problem_templates/","page":"Unitary Problem Templates","title":"Unitary Problem Templates","text":"The UnitaryVariationalProblem uses a VariationalQuantumSystem to find a control that is sensitive or robust to terms in the Hamiltonian. See the documentation for the VariationalQuantumSystem in PiccoloQuantumObjects.jl for more details.","category":"page"},{"location":"generated/man/unitary_problem_templates/","page":"Unitary Problem Templates","title":"Unitary Problem Templates","text":"create a variational system, with a variational Hamiltonian, PAULIS.X","category":"page"},{"location":"generated/man/unitary_problem_templates/","page":"Unitary Problem Templates","title":"Unitary Problem Templates","text":"T_max = 1.0\nu_bounds = [(-1.0, 1.0), (-1.0, 1.0)]\nH_var = PAULIS.X\nvarsys = VariationalQuantumSystem([PAULIS.X, PAULIS.Y], [H_var], T_max, u_bounds);\nnothing #hide","category":"page"},{"location":"generated/man/unitary_problem_templates/","page":"Unitary Problem Templates","title":"Unitary Problem Templates","text":"create a variational problem that is robust to PAULIS.X at the end","category":"page"},{"location":"generated/man/unitary_problem_templates/","page":"Unitary Problem Templates","title":"Unitary Problem Templates","text":"robprob = UnitaryVariationalProblem(varsys, U_goal, N, Δt, robust_times=[[N]]);\nnothing #hide","category":"page"},{"location":"generated/man/unitary_problem_templates/","page":"Unitary Problem Templates","title":"Unitary Problem Templates","text":"","category":"page"},{"location":"generated/man/unitary_problem_templates/","page":"Unitary Problem Templates","title":"Unitary Problem Templates","text":"","category":"page"},{"location":"generated/man/unitary_problem_templates/","page":"Unitary Problem Templates","title":"Unitary Problem Templates","text":"This page was generated using Literate.jl.","category":"page"},{"location":"#QuantumCollocation.jl","page":"Home","title":"QuantumCollocation.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"QuantumCollocation.jl sets up and solves quantum control problems as nonlinear programs (NLPs). In this context, a generic quantum control problem looks like","category":"page"},{"location":"","page":"Home","title":"Home","text":"beginaligned\n    arg min_mathbfZquad  J(mathbfZ) \n    nonumber textstqquad  mathbff(mathbfZ) = 0 \n    nonumber  mathbfg(mathbfZ) le 0  \nendaligned","category":"page"},{"location":"","page":"Home","title":"Home","text":"where mathbfZ is a trajectory  containing states and controls, from NamedTrajectories.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"We provide a number of problem templates for making it simple and easy to set up and solve  certain types of quantum optimal control problems. These templates all construct a  DirectTrajOptProblem object from DirectTrajOpt.jl, which stores all the parts of the optimal control problem.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#Get-started","page":"Home","title":"Get started","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The problem templates are broken down by the state variable of the problem being solved.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Ket Problem Templates:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Quantum State Smooth Pulse Problem\nQuantum State Minimum Time Problem\nQuantum State Sampling Problem","category":"page"},{"location":"","page":"Home","title":"Home","text":"Unitary Problem Templates:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Unitary Smooth Pulse Problem\nUnitary Minimum Time Problem\nUnitary Sampling Problem","category":"page"},{"location":"#Background","page":"Home","title":"Background","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Problem Templates are reusable design patterns for setting up and solving common quantum control problems. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"For example, a UnitarySmoothPulseProblem is tasked with generating a pulse sequence a_1T-1 in orderd to minimize infidelity, subject to constraints from the Schroedinger equation,","category":"page"},{"location":"","page":"Home","title":"Home","text":"    beginaligned\n        arg min_mathbfZquad  1 - mathcalF(U_T U_textgoal)  \n        nonumber textst\n        qquad  U_t+1 = exp- i H(a_t) Delta t_t  U_t quad forall t \n    endaligned","category":"page"},{"location":"","page":"Home","title":"Home","text":"while a UnitaryMinimumTimeProblem minimizes time and constrains fidelity,","category":"page"},{"location":"","page":"Home","title":"Home","text":"    beginaligned\n        arg min_mathbfZquad  sum_t=1^T Delta t_t \n        qquad  U_t+1 = exp- i H(a_t) Delta t_t  U_t quad forall t \n        nonumber  mathcalF(U_T U_textgoal) ge 09999\n    endaligned","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"In each case, the dynamics between knot points (U_t a_t) and (U_t+1 a_t+1) are enforced as constraints on the states, which are free variables in the solver; this optimization framework is called direct trajectory optimization. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Problem templates give the user the ability to add other constraints and objective functions to this problem and solve it efficiently using Ipopt.jl and MathOptInterface.jl under the hood (support for additional backends coming soon!).","category":"page"},{"location":"generated/man/ket_problem_templates/","page":"Ket Problem Templates","title":"Ket Problem Templates","text":"using NamedTrajectories\nusing PiccoloQuantumObjects\nusing QuantumCollocation","category":"page"},{"location":"generated/man/ket_problem_templates/","page":"Ket Problem Templates","title":"Ket Problem Templates","text":"","category":"page"},{"location":"generated/man/ket_problem_templates/#Quantum-State-Smooth-Pulse-Problem","page":"Ket Problem Templates","title":"Quantum State Smooth Pulse Problem","text":"","category":"section"},{"location":"generated/man/ket_problem_templates/#QuantumCollocation.ProblemTemplates.QuantumStateSmoothPulseProblem-generated-man-ket_problem_templates","page":"Ket Problem Templates","title":"QuantumCollocation.ProblemTemplates.QuantumStateSmoothPulseProblem","text":"QuantumStateSmoothPulseProblem(system, ψ_inits, ψ_goals, T, Δt; kwargs...)\nQuantumStateSmoothPulseProblem(system, ψ_init, ψ_goal, T, Δt; kwargs...)\nQuantumStateSmoothPulseProblem(H_drift, H_drives, args...; kwargs...)\n\nCreate a quantum state smooth pulse problem. The goal is to find a control pulse u(t) that drives all of the initial states ψ_inits to the corresponding target states ψ_goals using T timesteps of size Δt. This problem also controls the  first and second derivatives of the control pulse, du(t) and ddu(t), to ensure smoothness.\n\nArguments\n\nsystem::AbstractQuantumSystem: The quantum system.\n\nor\n\nH_drift::AbstractMatrix{<:Number}: The drift Hamiltonian.\nH_drives::Vector{<:AbstractMatrix{<:Number}}: The control Hamiltonians.\n\nwith\n\nψ_inits::Vector{<:AbstractVector{<:ComplexF64}}: The initial states.\nψ_goals::Vector{<:AbstractVector{<:ComplexF64}}: The target states.\n\nor\n\nψ_init::AbstractVector{<:ComplexF64}: The initial state.\nψ_goal::AbstractVector{<:ComplexF64}: The target state.\n\nwith\n\nT::Int: The number of timesteps.\nΔt::Float64: The timestep size.\n\nKeyword Arguments\n\nstate_name::Symbol=:ψ̃: The name of the state variable.\ncontrol_name::Symbol=:u: The name of the control variable.\ntimestep_name::Symbol=:Δt: The name of the timestep variable.\ninit_trajectory::Union{NamedTrajectory, Nothing}=nothing: The initial trajectory.\nu_bound::Float64=1.0: The bound on the control pulse.\nu_bounds=fill(u_bound, length(system.G_drives)): The bounds on the control pulse.\nu_guess::Union{Matrix{Float64}, Nothing}=nothing: The initial guess for the control pulse.\ndu_bound::Float64=Inf: The bound on the first derivative of the control pulse.\ndu_bounds=fill(du_bound, length(system.G_drives)): The bounds on the first derivative of the control pulse.\nddu_bound::Float64=1.0: The bound on the second derivative of the control pulse.\nddu_bounds=fill(ddu_bound, length(system.G_drives)): The bounds on the second derivative of the control pulse.\nΔt_min::Float64=0.5 * Δt: The minimum timestep size.\nΔt_max::Float64=1.5 * Δt: The maximum timestep size.\ndrive_derivative_σ::Float64=0.01: The standard deviation of the drive derivative random initialization.\nQ::Float64=100.0: The weight on the state objective.\nR=1e-2: The weight on the control pulse and its derivatives.\nR_u::Union{Float64, Vector{Float64}}=R: The weight on the control pulse.\nR_du::Union{Float64, Vector{Float64}}=R: The weight on the first derivative of the control pulse.\nR_ddu::Union{Float64, Vector{Float64}}=R: The weight on the second derivative of the control pulse.\nconstraints::Vector{<:AbstractConstraint}=AbstractConstraint[]: The constraints.\npiccolo_options::PiccoloOptions=PiccoloOptions(): The Piccolo options.\n\n\n\n\n\n","category":"function"},{"location":"generated/man/ket_problem_templates/","page":"Ket Problem Templates","title":"Ket Problem Templates","text":"Each problem starts with a QuantumSystem object, which is used to define the system's Hamiltonian and control operators. The goal is to find a control pulse that drives the intial state, ψ_init, to a target state, ψ_goal.","category":"page"},{"location":"generated/man/ket_problem_templates/","page":"Ket Problem Templates","title":"Ket Problem Templates","text":"define the quantum system","category":"page"},{"location":"generated/man/ket_problem_templates/","page":"Ket Problem Templates","title":"Ket Problem Templates","text":"T_max = 1.0\nu_bounds = [(-1.0, 1.0), (-1.0, 1.0)]\nsystem = QuantumSystem(0.1 * PAULIS.Z, [PAULIS.X, PAULIS.Y], T_max, u_bounds)\nψ_init = Vector{ComplexF64}([1.0, 0.0])\nψ_goal = Vector{ComplexF64}([0.0, 1.0])\nN = 51\nΔt = 0.2","category":"page"},{"location":"generated/man/ket_problem_templates/","page":"Ket Problem Templates","title":"Ket Problem Templates","text":"create the smooth pulse problem","category":"page"},{"location":"generated/man/ket_problem_templates/","page":"Ket Problem Templates","title":"Ket Problem Templates","text":"state_prob = QuantumStateSmoothPulseProblem(system, ψ_init, ψ_goal, N, Δt);\nnothing #hide","category":"page"},{"location":"generated/man/ket_problem_templates/","page":"Ket Problem Templates","title":"Ket Problem Templates","text":"check the fidelity before solving","category":"page"},{"location":"generated/man/ket_problem_templates/","page":"Ket Problem Templates","title":"Ket Problem Templates","text":"println(\"Before: \", rollout_fidelity(state_prob.trajectory, system))","category":"page"},{"location":"generated/man/ket_problem_templates/","page":"Ket Problem Templates","title":"Ket Problem Templates","text":"solve the problem","category":"page"},{"location":"generated/man/ket_problem_templates/","page":"Ket Problem Templates","title":"Ket Problem Templates","text":"load_path = joinpath(dirname(Base.active_project()), \"data/ket_problem_templates_state_prob_89ee72.jld2\") # hide\nstate_prob.trajectory = load_traj(load_path) # hide\nnothing # hide","category":"page"},{"location":"generated/man/ket_problem_templates/","page":"Ket Problem Templates","title":"Ket Problem Templates","text":"solve!(state_prob, max_iter=100, verbose=true, print_level=1);","category":"page"},{"location":"generated/man/ket_problem_templates/","page":"Ket Problem Templates","title":"Ket Problem Templates","text":"<pre class=\"documenter-example-output\"><code class=\"nohighlight hljs ansi\">    initializing optimizer...\n        applying constraint: timesteps all equal constraint\n        applying constraint: initial value of ψ̃\n        applying constraint: initial value of u\n        applying constraint: final value of u\n        applying constraint: bounds on u\n        applying constraint: bounds on du\n        applying constraint: bounds on ddu\n        applying constraint: bounds on Δt\n</code><button class=\"copy-button fa-solid fa-copy\" aria-label=\"Copy this code block\" title=\"Copy\"></button></pre>","category":"page"},{"location":"generated/man/ket_problem_templates/","page":"Ket Problem Templates","title":"Ket Problem Templates","text":"check the fidelity after solving","category":"page"},{"location":"generated/man/ket_problem_templates/","page":"Ket Problem Templates","title":"Ket Problem Templates","text":"println(\"After: \", rollout_fidelity(state_prob.trajectory, system, control_name=:u))","category":"page"},{"location":"generated/man/ket_problem_templates/","page":"Ket Problem Templates","title":"Ket Problem Templates","text":"extract the control pulses","category":"page"},{"location":"generated/man/ket_problem_templates/","page":"Ket Problem Templates","title":"Ket Problem Templates","text":"state_prob.trajectory.u |> size","category":"page"},{"location":"generated/man/ket_problem_templates/","page":"Ket Problem Templates","title":"Ket Problem Templates","text":"","category":"page"},{"location":"generated/man/ket_problem_templates/#Quantum-State-Minimum-Time-Problem","page":"Ket Problem Templates","title":"Quantum State Minimum Time Problem","text":"","category":"section"},{"location":"generated/man/ket_problem_templates/#QuantumCollocation.ProblemTemplates.QuantumStateMinimumTimeProblem-generated-man-ket_problem_templates","page":"Ket Problem Templates","title":"QuantumCollocation.ProblemTemplates.QuantumStateMinimumTimeProblem","text":"QuantumStateMinimumTimeProblem(traj, sys, obj, integrators, constraints; kwargs...)\nQuantumStateMinimumTimeProblem(prob; kwargs...)\n\nConstruct a DirectTrajOptProblem for the minimum time problem of reaching a target state.\n\nKeyword Arguments\n\nstate_name::Symbol=:ψ̃: The symbol for the state variables.\nfinal_fidelity::Union{Real, Nothing}=nothing: The final fidelity.\nD=1.0: The cost weight on the time.\npiccolo_options::PiccoloOptions=PiccoloOptions(): The Piccolo options.\n\n\n\n\n\n","category":"function"},{"location":"generated/man/ket_problem_templates/","page":"Ket Problem Templates","title":"Ket Problem Templates","text":"create the minimum time problem","category":"page"},{"location":"generated/man/ket_problem_templates/","page":"Ket Problem Templates","title":"Ket Problem Templates","text":"min_state_prob = QuantumStateMinimumTimeProblem(state_prob, ψ_goal);\nnothing #hide","category":"page"},{"location":"generated/man/ket_problem_templates/","page":"Ket Problem Templates","title":"Ket Problem Templates","text":"check the previous duration","category":"page"},{"location":"generated/man/ket_problem_templates/","page":"Ket Problem Templates","title":"Ket Problem Templates","text":"println(\"Duration before: \", get_duration(state_prob.trajectory))","category":"page"},{"location":"generated/man/ket_problem_templates/","page":"Ket Problem Templates","title":"Ket Problem Templates","text":"solve the minimum time problem","category":"page"},{"location":"generated/man/ket_problem_templates/","page":"Ket Problem Templates","title":"Ket Problem Templates","text":"load_path = joinpath(dirname(Base.active_project()), \"data/ket_problem_templates_state_prob_min_time_89ee72.jld2\") # hide\nmin_state_prob.trajectory = load_traj(load_path) # hide\nnothing # hide","category":"page"},{"location":"generated/man/ket_problem_templates/","page":"Ket Problem Templates","title":"Ket Problem Templates","text":"solve!(min_state_prob, max_iter=100, verbose=true, print_level=1);","category":"page"},{"location":"generated/man/ket_problem_templates/","page":"Ket Problem Templates","title":"Ket Problem Templates","text":"<pre class=\"documenter-example-output\"><code class=\"nohighlight hljs ansi\">    initializing optimizer...\n        applying constraint: timesteps all equal constraint\n        applying constraint: initial value of ψ̃\n        applying constraint: initial value of u\n        applying constraint: final value of u\n        applying constraint: bounds on u\n        applying constraint: bounds on du\n        applying constraint: bounds on ddu\n        applying constraint: bounds on Δt\n</code><button class=\"copy-button fa-solid fa-copy\" aria-label=\"Copy this code block\" title=\"Copy\"></button></pre>","category":"page"},{"location":"generated/man/ket_problem_templates/","page":"Ket Problem Templates","title":"Ket Problem Templates","text":"check the new duration","category":"page"},{"location":"generated/man/ket_problem_templates/","page":"Ket Problem Templates","title":"Ket Problem Templates","text":"println(\"Duration after: \", get_duration(min_state_prob.trajectory))","category":"page"},{"location":"generated/man/ket_problem_templates/","page":"Ket Problem Templates","title":"Ket Problem Templates","text":"the fidelity is preserved by a constraint","category":"page"},{"location":"generated/man/ket_problem_templates/","page":"Ket Problem Templates","title":"Ket Problem Templates","text":"println(\"Fidelity after: \", rollout_fidelity(min_state_prob.trajectory, system))","category":"page"},{"location":"generated/man/ket_problem_templates/","page":"Ket Problem Templates","title":"Ket Problem Templates","text":"","category":"page"},{"location":"generated/man/ket_problem_templates/#Quantum-State-Sampling-Problem","page":"Ket Problem Templates","title":"Quantum State Sampling Problem","text":"","category":"section"},{"location":"generated/man/ket_problem_templates/#QuantumCollocation.ProblemTemplates.QuantumStateSamplingProblem-generated-man-ket_problem_templates","page":"Ket Problem Templates","title":"QuantumCollocation.ProblemTemplates.QuantumStateSamplingProblem","text":"\n\n\n\n","category":"function"},{"location":"generated/man/ket_problem_templates/","page":"Ket Problem Templates","title":"Ket Problem Templates","text":"create a sampling problem","category":"page"},{"location":"generated/man/ket_problem_templates/","page":"Ket Problem Templates","title":"Ket Problem Templates","text":"T_max = 1.0\nu_bounds = [(-1.0, 1.0), (-1.0, 1.0)]\ndriftless_system = QuantumSystem([PAULIS.X, PAULIS.Y], T_max, u_bounds)\nsampling_state_prob = QuantumStateSamplingProblem([system, driftless_system], ψ_init, ψ_goal, N, Δt);\nnothing #hide","category":"page"},{"location":"generated/man/ket_problem_templates/","page":"Ket Problem Templates","title":"Ket Problem Templates","text":"new keys are added to the trajectory for the new states","category":"page"},{"location":"generated/man/ket_problem_templates/","page":"Ket Problem Templates","title":"Ket Problem Templates","text":"println(sampling_state_prob.trajectory.state_names)","category":"page"},{"location":"generated/man/ket_problem_templates/","page":"Ket Problem Templates","title":"Ket Problem Templates","text":"solve the sampling problem for a few iterations","category":"page"},{"location":"generated/man/ket_problem_templates/","page":"Ket Problem Templates","title":"Ket Problem Templates","text":"load_path = joinpath(dirname(Base.active_project()), \"data/ket_problem_templates_sampling_state_89ee72.jld2\") # hide\nsampling_state_prob.trajectory = load_traj(load_path) # hide\nnothing # hide","category":"page"},{"location":"generated/man/ket_problem_templates/","page":"Ket Problem Templates","title":"Ket Problem Templates","text":"solve!(sampling_state_prob, max_iter=25, verbose=true, print_level=1);","category":"page"},{"location":"generated/man/ket_problem_templates/","page":"Ket Problem Templates","title":"Ket Problem Templates","text":"<pre class=\"documenter-example-output\"><code class=\"nohighlight hljs ansi\">    initializing optimizer...\n        applying constraint: timesteps all equal constraint\n        applying constraint: initial value of ψ̃1_system_1\n        applying constraint: initial value of u\n        applying constraint: initial value of ψ̃1_system_2\n        applying constraint: final value of u\n        applying constraint: bounds on u\n        applying constraint: bounds on du\n        applying constraint: bounds on ddu\n        applying constraint: bounds on Δt\n</code><button class=\"copy-button fa-solid fa-copy\" aria-label=\"Copy this code block\" title=\"Copy\"></button></pre>","category":"page"},{"location":"generated/man/ket_problem_templates/","page":"Ket Problem Templates","title":"Ket Problem Templates","text":"check the fidelity of the sampling problem (use the updated key to get the initial and goal)","category":"page"},{"location":"generated/man/ket_problem_templates/","page":"Ket Problem Templates","title":"Ket Problem Templates","text":"println(\"After (original system): \", rollout_fidelity(sampling_state_prob.trajectory, system, state_name=:ψ̃1_system_1))\nprintln(\"After (new system): \", rollout_fidelity(sampling_state_prob.trajectory, driftless_system, state_name=:ψ̃1_system_1))","category":"page"},{"location":"generated/man/ket_problem_templates/","page":"Ket Problem Templates","title":"Ket Problem Templates","text":"compare this to using the original problem on the new system","category":"page"},{"location":"generated/man/ket_problem_templates/","page":"Ket Problem Templates","title":"Ket Problem Templates","text":"println(\"After (new system, original `prob`): \", rollout_fidelity(state_prob.trajectory, driftless_system))","category":"page"},{"location":"generated/man/ket_problem_templates/","page":"Ket Problem Templates","title":"Ket Problem Templates","text":"","category":"page"},{"location":"generated/man/ket_problem_templates/","page":"Ket Problem Templates","title":"Ket Problem Templates","text":"","category":"page"},{"location":"generated/man/ket_problem_templates/","page":"Ket Problem Templates","title":"Ket Problem Templates","text":"This page was generated using Literate.jl.","category":"page"}]
}
