var documenterSearchIndex = {"docs":
[{"location":"generated/man/losses/","page":"Losses","title":"Losses","text":"EditURL = \"../../../literate/man/losses.jl\"","category":"page"},{"location":"generated/man/losses/#Losses","page":"Losses","title":"Losses","text":"","category":"section"},{"location":"generated/man/losses/#Unitary-Losses","page":"Losses","title":"Unitary Losses","text":"","category":"section"},{"location":"generated/man/losses/","page":"Losses","title":"Losses","text":"Losses.isovec_unitary_fidelity","category":"page"},{"location":"generated/man/losses/","page":"Losses","title":"Losses","text":"","category":"page"},{"location":"generated/man/losses/","page":"Losses","title":"Losses","text":"This page was generated using Literate.jl.","category":"page"},{"location":"lib/#Library","page":"Library","title":"Library","text":"","category":"section"},{"location":"lib/#Problem-Templates","page":"Library","title":"Problem Templates","text":"","category":"section"},{"location":"lib/","page":"Library","title":"Library","text":"Modules = [QuantumCollocation.ProblemTemplates]","category":"page"},{"location":"lib/#QuantumCollocation.ProblemTemplates.QuantumStateMinimumTimeProblem","page":"Library","title":"QuantumCollocation.ProblemTemplates.QuantumStateMinimumTimeProblem","text":"QuantumStateMinimumTimeProblem(traj, sys, obj, integrators, constraints; kwargs...)\nQuantumStateMinimumTimeProblem(prob; kwargs...)\n\nConstruct a QuantumControlProblem for the minimum time problem of reaching a target state.\n\nArguments\n\ntraj::NamedTrajectory: The initial trajectory.\nsys::QuantumSystem: The quantum system.\nobj::Objective: The objective function.\nintegrators::Vector{<:AbstractIntegrator}: The integrators.\nconstraints::Vector{<:AbstractConstraint}: The constraints.\n\nor\n\nprob::QuantumControlProblem: The quantum control problem.\n\nKeyword Arguments\n\nstate_name::Symbol=:ψ̃: The symbol for the state variables.\nfinal_fidelity::Union{Real, Nothing}=nothing: The final fidelity.\nD=1.0: The cost weight on the time.\nipopt_options::IpoptOptions=IpoptOptions(): The Ipopt options.\npiccolo_options::PiccoloOptions=PiccoloOptions(): The Piccolo options.\nkwargs...: Additional keyword arguments, passed to QuantumControlProblem.\n\n\n\n\n\n","category":"function"},{"location":"lib/#QuantumCollocation.ProblemTemplates.QuantumStateSmoothPulseProblem-Tuple{AbstractQuantumSystem, Vector{<:AbstractVector{<:ComplexF64}}, Vector{<:AbstractVector{<:ComplexF64}}, Int64, Float64}","page":"Library","title":"QuantumCollocation.ProblemTemplates.QuantumStateSmoothPulseProblem","text":"QuantumStateSmoothPulseProblem(system, ψ_inits, ψ_goals, T, Δt; kwargs...)\n\nCreate a quantum state smooth pulse problem. The goal is to find a control pulse a(t) that drives all of the initial states ψ_inits to the corresponding target states ψ_goals using T timesteps of size Δt. This problem also controls the first and second derivatives of the control pulse, da(t) and dda(t), to ensure smoothness.\n\nArguments\n\nsystem::AbstractQuantumSystem: The quantum system.\nψ_inits::Vector{<:AbstractVector{<:ComplexF64}}: The initial states.\nψ_goals::Vector{<:AbstractVector{<:ComplexF64}}: The target states.\nT::Int: The number of timesteps.\nΔt::Float64: The timestep size.\n\nKeyword Arguments\n\nipopt_options::IpoptOptions=IpoptOptions(): The IPOPT options.\npiccolo_options::PiccoloOptions=PiccoloOptions(): The Piccolo options.\nstate_name::Symbol=:ψ̃: The name of the state variable.\ncontrol_name::Symbol=:a: The name of the control variable.\ntimestep_name::Symbol=:Δt: The name of the timestep variable.\ninit_trajectory::Union{NamedTrajectory, Nothing}=nothing: The initial trajectory.\na_bound::Float64=1.0: The bound on the control pulse.\na_bounds::Vector{Float64}=fill(a_bound, length(system.G_drives)): The bounds on the control pulse.\na_guess::Union{Matrix{Float64}, Nothing}=nothing: The initial guess for the control pulse.\nda_bound::Float64=Inf: The bound on the first derivative of the control pulse.\nda_bounds::Vector{Float64}=fill(da_bound, length(system.G_drives)): The bounds on the first derivative of the control pulse.\ndda_bound::Float64=1.0: The bound on the second derivative of the control pulse.\ndda_bounds::Vector{Float64}=fill(dda_bound, length(system.G_drives)): The bounds on the second derivative of the control pulse.\nΔt_min::Float64=0.5 * Δt: The minimum timestep size.\nΔt_max::Float64=1.5 * Δt: The maximum timestep size.\ndrive_derivative_σ::Float64=0.01: The standard deviation of the drive derivative random initialization.\nQ::Float64=100.0: The weight on the state objective.\nR=1e-2: The weight on the control pulse and its derivatives.\nR_a::Union{Float64, Vector{Float64}}=R: The weight on the control pulse.\nR_da::Union{Float64, Vector{Float64}}=R: The weight on the first derivative of the control pulse.\nR_dda::Union{Float64, Vector{Float64}}=R: The weight on the second derivative of the control pulse.\nleakage_operator::Union{Nothing, EmbeddedOperator}=nothing: The leakage operator, if leakage suppression is desired.\nconstraints::Vector{<:AbstractConstraint}=AbstractConstraint[]: The constraints.\n\n\n\n\n\n","category":"method"},{"location":"lib/#QuantumCollocation.ProblemTemplates.UnitaryBangBangProblem-Tuple{AbstractMatrix{<:Number}, Vector{<:AbstractMatrix{<:Number}}, Vararg{Any}}","page":"Library","title":"QuantumCollocation.ProblemTemplates.UnitaryBangBangProblem","text":"UnitaryBangBangProblem(\n    H_drift::AbstractMatrix{<:Number},\n    H_drives::Vector{<:AbstractMatrix{<:Number}},\n    operator,\n    T,\n    Δt;\n    kwargs...\n)\n\nConstructor for a UnitaryBangBangProblem from a drift Hamiltonian and a set of control Hamiltonians.\n\n\n\n\n\n","category":"method"},{"location":"lib/#QuantumCollocation.ProblemTemplates.UnitaryBangBangProblem-Tuple{AbstractQuantumSystem, OperatorType, Int64, Union{Float64, Vector{Float64}}}","page":"Library","title":"QuantumCollocation.ProblemTemplates.UnitaryBangBangProblem","text":"UnitaryBangBangProblem(system::QuantumSystem, operator, T, Δt; kwargs...)\n\nConstruct a QuantumControlProblem for a free-time unitary gate problem with bang-bang control pulses.\n\nbeginaligned\nundersetvectildeU a dota Delta ttextminimize  quad\nQ cdot ellqty(vectildeU_T vectildeU_textgoal) + frac12 sum_t qty(R_a a_t^2 + R_dota dota_t^2) \ntext subject to   quad vbP^(n)qty(vectildeU_t+1 vectildeU_t a_t Delta t_t) = 0 \n a_t+1 - a_t - dota_t Delta t_t = 0 \n quad a_t leq a_textbound \n quad dota_t leq da_textbound \n quad Delta t_textmin leq Delta t_t leq Delta t_textmax \nendaligned\n\nwhere, for U in SU(N),\n\nellqty(vectildeU_T vectildeU_textgoal) =\nabs1 - frac1N abs tr qty(U_textgoal U_T) \n\nis the infidelity objective function, Q is a weight, R_a, and R_dota are weights on the regularization terms, and vbP^(n) is the nth-order Pade integrator.\n\nTODO: Document bang-bang modification.\n\nArguments\n\nH_drift::AbstractMatrix{<:Number}: the drift hamiltonian\nH_drives::Vector{<:AbstractMatrix{<:Number}}: the control hamiltonians\n\nor\n\nsystem::QuantumSystem: the system to be controlled\n\nwith\n\noperator::OperatorType: the target unitary, either in the form of an EmbeddedOperator or a `Matrix{ComplexF64}\nT::Int: the number of timesteps\nΔt::Float64: the (initial) time step size\n\nKeyword Arguments\n\nipopt_options::IpoptOptions=IpoptOptions(): the options for the Ipopt solver\npiccolo_options::PiccoloOptions=PiccoloOptions(): the options for the Piccolo solver\nstate_name::Symbol = :Ũ⃗: the name of the state variable\ncontrol_name::Symbol = :a: the name of the control variable\ntimestep_name::Symbol = :Δt: the name of the timestep variable\ninit_trajectory::Union{NamedTrajectory, Nothing}=nothing: an initial trajectory to use\na_bound::Float64=1.0: the bound on the control pulse\na_bounds=fill(a_bound, length(system.G_drives)): the bounds on the control pulses, one for each drive\na_guess::Union{Matrix{Float64}, Nothing}=nothing: an initial guess for the control pulses\nda_bound::Float64=1.0: the bound on the control pulse derivative\nda_bounds=fill(da_bound, length(system.G_drives)): the bounds on the control pulse derivatives, one for each drive\nΔt_min::Float64=Δt isa Float64 ? 0.5 * Δt : 0.5 * mean(Δt): the minimum time step size\nΔt_max::Float64=Δt isa Float64 ? 1.5 * Δt : 1.5 * mean(Δt): the maximum time step size\ndrive_derivative_σ::Float64=0.01: the standard deviation of the initial guess for the control pulse derivatives\nQ::Float64=100.0: the weight on the infidelity objective\nR=1e-2: the weight on the regularization terms\nquadratic_control_regularization=false: whether or not to use quadratic regularization for the control pulses\nR_a::Union{Float64, Vector{Float64}}=R: the weight on the regularization term for the control pulses\nR_da::Union{Float64, Vector{Float64}}=R: the weight on the regularization term for the control pulse derivatives\nR_bang_bang::Union{Float64, Vector{Float64}}=1e-1: the weight on the bang-bang regularization term\nglobal_data::Union{NamedTuple, Nothing}=nothing: global data to be used in the problem\nconstraints::Vector{<:AbstractConstraint}=AbstractConstraint[]: the constraints to enforce\n\nTODO: control modulus norm, advanced feature, needs documentation\n\n\n\n\n\n","category":"method"},{"location":"lib/#QuantumCollocation.ProblemTemplates.UnitaryDirectSumProblem-Tuple{AbstractVector{<:QuantumControlProblem}, Real}","page":"Library","title":"QuantumCollocation.ProblemTemplates.UnitaryDirectSumProblem","text":"UnitaryDirectSumProblem(probs, final_fidelity; kwargs...)\n\nConstruct a QuantumControlProblem as a direct sum of unitary gate problems. The purpose is to find solutions that are as close as possible with respect to one of their components. In particular, this is useful for finding interpolatable control solutions.\n\nA graph of edges (specified by problem labels) will enforce a PairwiseQuadraticRegularizer between the component trajectories of the problem in probs corresponding to the names of the edge in edges with corresponding edge weight Q.\n\nBoundary values can be included to enforce a QuadraticRegularizer on edges where one of the nodes is not optimized. The boundary values are specified as a dictionary with keys corresponding to the edge labels and values corresponding to the boundary values.\n\nThe default behavior is to use a 1D chain for the graph, i.e., enforce a PairwiseQuadraticRegularizer between each neighbor of the provided probs.\n\nArguments\n\nprobs::AbstractVector{<:QuantumControlProblem}: the problems to combine\nfinal_fidelity::Real: the fidelity to enforce between the component final unitaries and the component goal unitaries\n\nKeyword Arguments\n\nprob_labels::AbstractVector{<:String}}: the labels for the problems\ngraph::Union{Nothing, AbstractVector{<:Tuple{String, String}}, AbstractVector{<:Tuple{Symbol, Symbol}}}`: the graph of edges to enforce\nboundary_values::Union{Nothing, AbstractDict{<:String, <:AbstractArray}, AbstractDict{<:Symbol, <:AbstractVector}}=nothing: the boundary values for the problems\nQ::Union{Float64, Vector{Float64}}=100.0: the weights on the pairwise regularizers\nQ_symb::Symbol=:Ũ⃗: the symbol to use for the regularizer\nR::Float64=1e-2: the shared weight on all control terms (:a, :da, :dda is assumed)\nR_a::Union{Float64, Vector{Float64}}=R: the weight on the regularization term for the control pulses\nR_da::Union{Float64, Vector{Float64}}=R: the weight on the regularization term for the control pulse derivatives\nR_dda::Union{Float64, Vector{Float64}}=R: the weight on the regularization term for the control pulse second derivatives\nR_b::Union{Float64, Vector{Float64}}=R: the weight on the regularization term for the boundary values\ndrive_derivative_σ::Float64=0.01: the standard deviation of the initial guess for the control pulse derivatives\ndrive_reset_ratio::Float64=0.1: amount of random noise to add to the control data (can help avoid hitting restoration if provided problems are converged)\nfidelity_cost::Bool=false: whether or not to include a fidelity cost in the objective\nsubspace::Union{AbstractVector{<:Integer}, Nothing}=nothing: the subspace to use for the fidelity of each problem\nipopt_options::IpoptOptions=IpoptOptions(): the options for the Ipopt solver\npiccolo_options::PiccoloOptions=PiccoloOptions(): the options for the Piccolo solver\n\n\n\n\n\n","category":"method"},{"location":"lib/#QuantumCollocation.ProblemTemplates.UnitaryRobustnessProblem","page":"Library","title":"QuantumCollocation.ProblemTemplates.UnitaryRobustnessProblem","text":"UnitaryRobustnessProblem(\n    H_error,\n    trajectory,\n    system,\n    objective,\n    integrators,\n    constraints;\n    kwargs...\n)\n\nUnitaryRobustnessProblem(Hₑ, prob::QuantumControlProblem; kwargs...)\n\nCreate a quantum control problem for robustness optimization of a unitary trajectory.\n\nKeyword Arguments\n\nunitary_symbol::Symbol=:Ũ⃗: The symbol for the unitary trajectory in trajectory.\nfinal_fidelity::Union{Real, Nothing}=nothing: The target fidelity for the final unitary.\nipopt_options::IpoptOptions=IpoptOptions(): Options for the Ipopt solver.\npiccolo_options::PiccoloOptions=PiccoloOptions(): Options for the Piccolo solver.\nkwargs...: Additional keyword arguments passed to QuantumControlProblem.\n\n\n\n\n\n","category":"function"},{"location":"lib/#QuantumCollocation.ProblemTemplates.UnitarySamplingProblem-Tuple{AbstractVector{<:AbstractQuantumSystem}, OperatorType, Int64, Union{Float64, Vector{Float64}}}","page":"Library","title":"QuantumCollocation.ProblemTemplates.UnitarySamplingProblem","text":"UnitarySamplingProblem(systemns, operator, T, Δt; kwargs...)\n\nA UnitarySamplingProblem is a quantum control problem where the goal is to find a control pulse that generates a target unitary operator for a set of quantum systems. The controls are shared among all systems, and the optimization seeks to find the control pulse that achieves the operator for each system. The idea is to enforce a robust solution by including multiple systems reflecting the problem uncertainty.\n\nArguments\n\nsystems::AbstractVector{<:AbstractQuantumSystem}: A vector of quantum systems.\noperator::OperatorType: The target unitary operator.\nT::Int: The number of time steps.\nΔt::Union{Float64, Vector{Float64}}: The time step value or vector of time steps.\n\nKeyword Arguments\n\nsystem_labels::Vector{String} = string.(1:length(systems)): The labels for each system.\nsystem_weights::Vector{Float64} = fill(1.0, length(systems)): The weights for each system.\ninit_trajectory::Union{NamedTrajectory, Nothing} = nothing: The initial trajectory.\nipopt_options::IpoptOptions = IpoptOptions(): The IPOPT options.\npiccolo_options::PiccoloOptions = PiccoloOptions(): The Piccolo options.\nstate_name::Symbol = :Ũ⃗: The name of the state variable.\ncontrol_name::Symbol = :a: The name of the control variable.\ntimestep_name::Symbol = :Δt: The name of the timestep variable.\nconstraints::Vector{<:AbstractConstraint} = AbstractConstraint[]: The constraints.\na_bound::Float64 = 1.0: The bound for the control amplitudes.\na_bounds::Vector{Float64} = fill(a_bound, length(systems[1].G_drives)): The bounds for the control amplitudes.\na_guess::Union{Matrix{Float64}, Nothing} = nothing: The initial guess for the control amplitudes.\nda_bound::Float64 = Inf: The bound for the control first derivatives.\nda_bounds::Vector{Float64} = fill(da_bound, length(systems[1].G_drives)): The bounds for the control first derivatives.\ndda_bound::Float64 = 1.0: The bound for the control second derivatives.\ndda_bounds::Vector{Float64} = fill(dda_bound, length(systems[1].G_drives)): The bounds for the control second derivatives.\nΔt_min::Float64 = 0.5 * Δt: The minimum time step size.\nΔt_max::Float64 = 1.5 * Δt: The maximum time step size.\ndrive_derivative_σ::Float64 = 0.01: The standard deviation for the drive derivative noise.\nQ::Float64 = 100.0: The fidelity weight.\nR::Float64 = 1e-2: The regularization weight.\nR_a::Union{Float64, Vector{Float64}} = R: The regularization weight for the control amplitudes.\nR_da::Union{Float64, Vector{Float64}} = R: The regularization weight for the control first derivatives.\nR_dda::Union{Float64, Vector{Float64}} = R: The regularization weight for the control second derivatives.\nkwargs...: Additional keyword arguments.\n\n\n\n\n\n","category":"method"},{"location":"lib/#QuantumCollocation.ProblemTemplates.UnitarySmoothPulseProblem-Tuple{AbstractMatrix{<:Number}, Vector{<:AbstractMatrix{<:Number}}, Vararg{Any}}","page":"Library","title":"QuantumCollocation.ProblemTemplates.UnitarySmoothPulseProblem","text":"UnitarySmoothPulseProblem(\n    H_drift::AbstractMatrix{<:Number},\n    H_drives::Vector{<:AbstractMatrix{<:Number}},\n    operator,\n    T,\n    Δt;\n    kwargs...\n)\n\nConstructor for a UnitarySmoothPulseProblem from a drift Hamiltonian and a set of control Hamiltonians.\n\n\n\n\n\n","category":"method"},{"location":"lib/#QuantumCollocation.ProblemTemplates.UnitarySmoothPulseProblem-Tuple{AbstractQuantumSystem, OperatorType, Int64, Union{Float64, Vector{Float64}}}","page":"Library","title":"QuantumCollocation.ProblemTemplates.UnitarySmoothPulseProblem","text":"UnitarySmoothPulseProblem(system, operator, T, Δt; kwargs...)\n\nConstruct a QuantumControlProblem for a free-time unitary gate problem with smooth control pulses enforced by constraining the second derivative of the pulse trajectory, i.e.,\n\nbeginaligned\nundersetvectildeU a dota ddota Delta ttextminimize  quad\nQ cdot ellqty(vectildeU_T vectildeU_textgoal) + frac12 sum_t qty(R_a a_t^2 + R_dota dota_t^2 + R_ddota ddota_t^2) \ntext subject to   quad vbP^(n)qty(vectildeU_t+1 vectildeU_t a_t Delta t_t) = 0 \n a_t+1 - a_t - dota_t Delta t_t = 0 \n quad dota_t+1 - dota_t - ddota_t Delta t_t = 0 \n quad a_t leq a_textbound \n quad ddota_t leq ddota_textbound \n quad Delta t_textmin leq Delta t_t leq Delta t_textmax \nendaligned\n\nwhere, for U in SU(N),\n\nellqty(vectildeU_T vectildeU_textgoal) =\nabs1 - frac1N abs tr qty(U_textgoal U_T) \n\nis the infidelity objective function, Q is a weight, R_a, R_dota, and R_ddota are weights on the regularization terms, and vbP^(n) is the nth-order Pade integrator.\n\nArguments\n\nH_drift::AbstractMatrix{<:Number}: the drift hamiltonian\nH_drives::Vector{<:AbstractMatrix{<:Number}}: the control hamiltonians\n\nor\n\nsystem::QuantumSystem: the system to be controlled\n\nwith\n\noperator::OperatorType: the target unitary, either in the form of an EmbeddedOperator or a `Matrix{ComplexF64}\nT::Int: the number of timesteps\nΔt::Float64: the (initial) time step size\n\nKeyword Arguments\n\nipopt_options::IpoptOptions=IpoptOptions(): the options for the Ipopt solver\npiccolo_options::PiccoloOptions=PiccoloOptions(): the options for the Piccolo solver\nstate_name::Symbol = :Ũ⃗: the name of the state\ncontrol_name::Symbol = :a: the name of the control\ntimestep_name::Symbol = :Δt: the name of the timestep\ninit_trajectory::Union{NamedTrajectory, Nothing}=nothing: an initial trajectory to use\na_bound::Float64=1.0: the bound on the control pulse\na_bounds::Vector{Float64}=fill(a_bound, length(system.G_drives)): the bounds on the control pulses, one for each drive\na_guess::Union{Matrix{Float64}, Nothing}=nothing: an initial guess for the control pulses\nda_bound::Float64=Inf: the bound on the control pulse derivative\nda_bounds::Vector{Float64}=fill(da_bound, length(system.G_drives)): the bounds on the control pulse derivatives, one for each drive\ndda_bound::Float64=1.0: the bound on the control pulse second derivative\ndda_bounds::Vector{Float64}=fill(dda_bound, length(system.G_drives)): the bounds on the control pulse second derivatives, one for each drive\nΔt_min::Float64=Δt isa Float64 ? 0.5 * Δt : 0.5 * mean(Δt): the minimum time step size\nΔt_max::Float64=Δt isa Float64 ? 1.5 * Δt : 1.5 * mean(Δt): the maximum time step size\ndrive_derivative_σ::Float64=0.01: the standard deviation of the initial guess for the control pulse derivatives\nQ::Float64=100.0: the weight on the infidelity objective\nR=1e-2: the weight on the regularization terms\nR_a::Union{Float64, Vector{Float64}}=R: the weight on the regularization term for the control pulses\nR_da::Union{Float64, Vector{Float64}}=R: the weight on the regularization term for the control pulse derivatives\nR_dda::Union{Float64, Vector{Float64}}=R: the weight on the regularization term for the control pulse second derivatives\nglobal_data::Union{NamedTuple, Nothing}=nothing: global data for the problem\nconstraints::Vector{<:AbstractConstraint}=AbstractConstraint[]: the constraints to enforce\n\n\n\n\n\n","category":"method"},{"location":"lib/#Direct-Sums","page":"Library","title":"Direct Sums","text":"","category":"section"},{"location":"lib/","page":"Library","title":"Library","text":"Modules = [QuantumCollocation.DirectSums]","category":"page"},{"location":"lib/#QuantumCollocation.DirectSums.direct_sum-Tuple{AbstractMatrix, AbstractMatrix}","page":"Library","title":"QuantumCollocation.DirectSums.direct_sum","text":"direct_sum(A::AbstractMatrix, B::AbstractMatrix)\n\nReturns the direct sum of two matrices.\n\n\n\n\n\n","category":"method"},{"location":"lib/#QuantumCollocation.DirectSums.direct_sum-Tuple{AbstractVector, AbstractVector}","page":"Library","title":"QuantumCollocation.DirectSums.direct_sum","text":"direct_sum(Ã⃗::AbstractVector, B̃⃗::AbstractVector)\n\nReturns the direct sum of two iso_vec operators.\n\n\n\n\n\n","category":"method"},{"location":"lib/#QuantumCollocation.DirectSums.direct_sum-Tuple{NamedTrajectories.StructNamedTrajectory.NamedTrajectory, NamedTrajectories.StructNamedTrajectory.NamedTrajectory}","page":"Library","title":"QuantumCollocation.DirectSums.direct_sum","text":"direct_sum(traj1::NamedTrajectory, traj2::NamedTrajectory)\n\nReturns the direct sum of two NamedTrajectory objects.\n\nThe NamedTrajectory objects must have the same timestep. However, a direct sum can return a free time problem by passing the keyword argument  free_time=true. In this case, the timestep symbol must be provided. If a free time problem with more than two trajectories is desired, the reduce function has been written to handle calls to direct sums of NamedTrajectory objects; simply pass the keyword argument free_time=true to the reduce function.\n\nArguments\n\ntraj1::NamedTrajectory: The first NamedTrajectory object.\ntraj2::NamedTrajectory: The second NamedTrajectory object.\nfree_time::Bool=false: Whether to construct a free time problem.\ntimestep_name::Symbol=:Δt: The timestep symbol to use for free time problems.\n\n\n\n\n\n","category":"method"},{"location":"lib/#QuantumCollocation.DirectSums.direct_sum-Tuple{QuantumSystem, QuantumSystem}","page":"Library","title":"QuantumCollocation.DirectSums.direct_sum","text":"direct_sum(sys1::QuantumSystem, sys2::QuantumSystem)\n\nReturns the direct sum of two QuantumSystem objects.\n\n\n\n\n\n","category":"method"},{"location":"lib/#QuantumCollocation.DirectSums.direct_sum-Tuple{SparseArrays.SparseMatrixCSC, SparseArrays.SparseMatrixCSC}","page":"Library","title":"QuantumCollocation.DirectSums.direct_sum","text":"direct_sum(A::SparseMatrixCSC, B::SparseMatrixCSC)\n\nReturns the direct sum of two sparse matrices.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Quantum-Object-Utils","page":"Library","title":"Quantum Object Utils","text":"","category":"section"},{"location":"lib/","page":"Library","title":"Library","text":"Modules = [QuantumCollocation.QuantumObjectUtils]","category":"page"},{"location":"lib/#QuantumCollocation.QuantumObjectUtils.GATES","page":"Library","title":"QuantumCollocation.QuantumObjectUtils.GATES","text":"A constant dictionary GATES containing common quantum gate matrices as complex-valued matrices. Each gate is represented by its unitary matrix.\n\nGATES[:I] - Identity gate: Leaves the state unchanged.\nGATES[:X] - Pauli-X (NOT) gate: Flips the qubit state.\nGATES[:Y] - Pauli-Y gate: Rotates the qubit state around the Y-axis of the Bloch sphere.\nGATES[:Z] - Pauli-Z gate: Flips the phase of the qubit state.\nGATES[:H] - Hadamard gate: Creates superposition by transforming basis states.\nGATES[:CX] - Controlled-X (CNOT) gate: Flips the second qubit (target) if the first qubit (control) is |1⟩.\nGATES[:CZ] - Controlled-Z (CZ) gate: Flips the phase of the second qubit (target) if the first qubit (control) is |1⟩.\nGATES[:XI] - Complex gate: A specific gate used for complex operations.\nGATES[:sqrtiSWAP] - Square root of iSWAP gate: Partially swaps two qubits with a phase.\n\njulia> GATES[:Z]\n2×2 Matrix{ComplexF64}:\n 1.0+0.0im   0.0+0.0im\n 0.0+0.0im  -1.0+0.0im\n\njulia> get_gate(:CX)\n4×4 Matrix{ComplexF64}:\n 1.0+0.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im\n 0.0+0.0im  1.0+0.0im  0.0+0.0im  0.0+0.0im\n 0.0+0.0im  0.0+0.0im  0.0+0.0im  1.0+0.0im\n 0.0+0.0im  0.0+0.0im  1.0+0.0im  0.0+0.0im\n\n\n\n\n\n","category":"constant"},{"location":"lib/#QuantumCollocation.QuantumObjectUtils.:⊗-Tuple{AbstractVecOrMat, AbstractVecOrMat}","page":"Library","title":"QuantumCollocation.QuantumObjectUtils.:⊗","text":"⊗(A::AbstractVecOrMat, B::AbstractVecOrMat) = kron(A, B)\n\nThe Kronecker product, denoted by ⊗, results in a block matrix formed by multiplying each element of A by the entire matrix B.\n\njulia> GATES[:X] ⊗ GATES[:Y]\n4×4 Matrix{ComplexF64}:\n 0.0+0.0im  0.0+0.0im  0.0+0.0im  0.0-1.0im\n 0.0+0.0im  0.0+0.0im  0.0+1.0im  0.0+0.0im\n 0.0+0.0im  0.0-1.0im  0.0+0.0im  0.0+0.0im\n 0.0+1.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im\n\n\n\n\n\n","category":"method"},{"location":"lib/#QuantumCollocation.QuantumObjectUtils.annihilate-Tuple{Int64}","page":"Library","title":"QuantumCollocation.QuantumObjectUtils.annihilate","text":"annihilate(levels::Int)\n\nGet the annihilation operator for a system with levels levels.\n\n\n\n\n\n","category":"method"},{"location":"lib/#QuantumCollocation.QuantumObjectUtils.create-Tuple{Int64}","page":"Library","title":"QuantumCollocation.QuantumObjectUtils.create","text":"create(levels::Int)\n\nGet the creation operator for a system with levels levels.\n\n\n\n\n\n","category":"method"},{"location":"lib/#QuantumCollocation.QuantumObjectUtils.haar_identity-Tuple{Int64, Number}","page":"Library","title":"QuantumCollocation.QuantumObjectUtils.haar_identity","text":"haar_identity(n::Int, radius::Number)\n\nGenerate a random unitary matrix close to the identity matrix using the Haar measure for an n-dimensional system with a given radius.\n\n\n\n\n\n","category":"method"},{"location":"lib/#QuantumCollocation.QuantumObjectUtils.haar_random-Tuple{Int64}","page":"Library","title":"QuantumCollocation.QuantumObjectUtils.haar_random","text":"haar_random(n::Int)\n\nGenerate a random unitary matrix using the Haar measure for an n-dimensional system.\n\n\n\n\n\n","category":"method"},{"location":"lib/#QuantumCollocation.QuantumObjectUtils.ket_from_bitstring-Tuple{String}","page":"Library","title":"QuantumCollocation.QuantumObjectUtils.ket_from_bitstring","text":"ket_from_bitstring(ket::String)\n\nGet the state vector for a qubit system given a ket string ket of 0s and 1s.\n\n\n\n\n\n","category":"method"},{"location":"lib/#QuantumCollocation.QuantumObjectUtils.ket_from_string-Tuple{String, Vector{Int64}}","page":"Library","title":"QuantumCollocation.QuantumObjectUtils.ket_from_string","text":"ket_from_string(\n    ket::String,\n    levels::Vector{Int};\n    level_dict=Dict(:g => 0, :e => 1, :f => 2, :h => 2),\n    return_states=false\n)\n\nConstruct a quantum state from a string ket representation.\n\nExample\n\nTODO: add example\n\n\n\n\n\n","category":"method"},{"location":"lib/#QuantumCollocation.QuantumObjectUtils.operator_from_string-Tuple{String}","page":"Library","title":"QuantumCollocation.QuantumObjectUtils.operator_from_string","text":"operatorfromstring(operator::String; lookup::Dict{Symbol, AbstractMatrix}=PAULIS)\n\nReduce the string (each character is one key) via operators from a dictionary.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Quantum-Systems","page":"Library","title":"Quantum Systems","text":"","category":"section"},{"location":"lib/","page":"Library","title":"Library","text":"Modules = [QuantumCollocation.QuantumSystems]","category":"page"},{"location":"lib/#QuantumCollocation.QuantumSystems.AbstractQuantumSystem","page":"Library","title":"QuantumCollocation.QuantumSystems.AbstractQuantumSystem","text":"AbstractQuantumSystem\n\nAbstract type for defining systems.\n\n\n\n\n\n","category":"type"},{"location":"lib/#QuantumCollocation.QuantumSystems.QuantumSystem","page":"Library","title":"QuantumCollocation.QuantumSystems.QuantumSystem","text":"QuantumSystem <: AbstractQuantumSystem\n\nA struct for storing the isomorphisms of the system's drift and drive Hamiltonians, as well as the system's parameters.\n\n\n\n\n\n","category":"type"},{"location":"lib/#QuantumCollocation.QuantumSystems.QuantumSystem-Tuple{AbstractMatrix{<:Number}, Vector{<:AbstractMatrix{<:Number}}}","page":"Library","title":"QuantumCollocation.QuantumSystems.QuantumSystem","text":"QuantumSystem(\n    H_drift::Matrix{<:Number},\n    H_drives::Vector{Matrix{<:Number}};\n    params=Dict{Symbol, Any}(),\n    kwargs...\n)::QuantumSystem\n\nConstructs a QuantumSystem object from the drift and drive Hamiltonian terms.\n\n\n\n\n\n","category":"method"},{"location":"lib/#QuantumCollocation.QuantumSystems.QuantumSystemCoupling","page":"Library","title":"QuantumCollocation.QuantumSystems.QuantumSystemCoupling","text":"QuantumSystemCoupling <: AbstractQuantumSystem\n\n\n\n\n\n","category":"type"},{"location":"lib/#QuantumCollocation.QuantumSystems.lift-Tuple{AbstractMatrix{<:Number}, Int64, Int64}","page":"Library","title":"QuantumCollocation.QuantumSystems.lift","text":"lift(U::AbstractMatrix{<:Number}, qubit_index::Int, n_qubits::Int; levels::Int=size(U, 1))\n\nLift an operator U acting on a single qubit to an operator acting on the entire system of n_qubits.\n\n\n\n\n\n","category":"method"},{"location":"lib/#QuantumCollocation.QuantumSystems.lift-Tuple{AbstractMatrix{<:Number}, Int64, Vector{Int64}}","page":"Library","title":"QuantumCollocation.QuantumSystems.lift","text":"lift(op::AbstractMatrix{<:Number}, i::Int, subsystem_levels::Vector{Int})\n\nLift an operator op acting on the i-th subsystem to an operator acting on the entire system with given subsystem levels.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Integrators","page":"Library","title":"Integrators","text":"","category":"section"},{"location":"lib/","page":"Library","title":"Library","text":"Modules = [QuantumCollocation.Integrators]","category":"page"},{"location":"lib/#QuantumCollocation.Integrators.UnitaryPadeIntegrator","page":"Library","title":"QuantumCollocation.Integrators.UnitaryPadeIntegrator","text":"\n\n\n\n","category":"type"},{"location":"lib/#Objectives","page":"Library","title":"Objectives","text":"","category":"section"},{"location":"lib/","page":"Library","title":"Library","text":"Modules = [QuantumCollocation.Objectives]","category":"page"},{"location":"lib/#QuantumCollocation.Objectives.Objective","page":"Library","title":"QuantumCollocation.Objectives.Objective","text":"Objective\n\nA structure for defining objective functions.\n\nThe terms field contains all the arguments needed to construct the objective function.\n\nFields:     L: the objective function     ∇L: the gradient of the objective function     ∂²L: the Hessian of the objective function     ∂²L_structure: the structure of the Hessian of the objective function     terms: a vector of dictionaries containing the terms of the objective function\n\n\n\n\n\n","category":"type"},{"location":"lib/#QuantumCollocation.Objectives.L1Regularizer-Tuple{}","page":"Library","title":"QuantumCollocation.Objectives.L1Regularizer","text":"L1Regularizer\n\nCreate an L1 regularizer for the trajectory component. The regularizer is defined as\n\nJ_L1(u) = sum_t absR cdot u_t\n\nwhere (R) is the regularization matrix and (u_t) is the trajectory component at time (t).\n\n\n\n\n\n","category":"method"},{"location":"lib/#QuantumCollocation.Objectives.MinimumTimeObjective-Tuple{}","page":"Library","title":"QuantumCollocation.Objectives.MinimumTimeObjective","text":"MinimumTimeObjective\n\nA type of objective that counts the time taken to complete a task.\n\nFields:     D: a scaling factor     Δt_indices: the indices of the time steps     eval_hessian: whether to evaluate the Hessian\n\n\n\n\n\n","category":"method"},{"location":"lib/#QuantumCollocation.Objectives.PairwiseQuadraticRegularizer-Tuple{AbstractVector{<:Real}, AbstractVector{Int64}, Symbol, Symbol}","page":"Library","title":"QuantumCollocation.Objectives.PairwiseQuadraticRegularizer","text":"PairwiseQuadraticRegularizer\n\nCreate a pairwise quadratic regularizer for the trajectory component name with regularization strength R. The regularizer is defined as\n\n    J_v(u) = sum_t frac12 Delta t_t^2 (v_1t - v_2t)^T R (v_1t - v_2t)\n\nwhere v_1 and v_2 are selected by name1 and name2. The indices specify the appropriate block diagonal components of the direct sum vector v⃗.\n\nTODO: Hessian not implemented\n\nFields:     R: the regularization strength     times: the time steps to apply the regularizer     name1: the first name     name2: the second name     timestep_name: the symbol for the timestep     eval_hessian: whether to evaluate the Hessian\n\n\n\n\n\n","category":"method"},{"location":"lib/#QuantumCollocation.Objectives.PairwiseQuadraticRegularizer-Tuple{NamedTrajectories.StructNamedTrajectory.NamedTrajectory, Union{Float64, AbstractVector{<:Float64}}, AbstractVector{<:Tuple{Symbol, Symbol}}}","page":"Library","title":"QuantumCollocation.Objectives.PairwiseQuadraticRegularizer","text":"PairwiseQuadraticRegularizer\n\nA convenience constructor for creating a PairwiseQuadraticRegularizer for the trajectory component name with regularization strength Rs over the graph graph.\n\n\n\n\n\n","category":"method"},{"location":"lib/#QuantumCollocation.Objectives.PairwiseUnitaryRobustnessObjective-Tuple{}","page":"Library","title":"QuantumCollocation.Objectives.PairwiseUnitaryRobustnessObjective","text":"PairwiseUnitaryRobustnessObjective(;\n    H1::Union{OperatorType, Nothing}=nothing,\n    H2_error::Union{OperatorType, Nothing}=nothing,\n    symb1::Symbol=:Ũ⃗1,\n    symb2::Symbol=:Ũ⃗2,\n    eval_hessian::Bool=false,\n)\n\nCreate a control objective which penalizes the sensitivity of the infidelity to the provided operators defined in the subspaces of the control dynamics, thereby realizing robust control.\n\n\n\n\n\n","category":"method"},{"location":"lib/#QuantumCollocation.Objectives.QuadraticRegularizer-Tuple{}","page":"Library","title":"QuantumCollocation.Objectives.QuadraticRegularizer","text":"QuadraticRegularizer\n\nA quadratic regularizer for a trajectory component.\n\nFields:     name: the name of the trajectory component to regularize     times: the times at which to evaluate the regularizer     dim: the dimension of the trajectory component     R: the regularization matrix     baseline: the baseline values for the trajectory component     eval_hessian: whether to evaluate the Hessian of the regularizer     timestep_name: the symbol for the timestep variable\n\n\n\n\n\n","category":"method"},{"location":"lib/#QuantumCollocation.Objectives.QuadraticSmoothnessRegularizer-Tuple{}","page":"Library","title":"QuantumCollocation.Objectives.QuadraticSmoothnessRegularizer","text":"QuadraticSmoothnessRegularizer\n\nA quadratic smoothness regularizer for a trajectory component.\n\nFields:     name: the name of the trajectory component to regularize     times: the times at which to evaluate the regularizer     R: the regularization matrix     eval_hessian: whether to evaluate the Hessian of the regularizer\n\n\n\n\n\n","category":"method"},{"location":"lib/#QuantumCollocation.Objectives.QuantumObjective-Tuple{}","page":"Library","title":"QuantumCollocation.Objectives.QuantumObjective","text":"QuantumObjective\n\nA generic objective function for quantum trajectories that use a loss.\n\n\n\n\n\n","category":"method"},{"location":"lib/#QuantumCollocation.Objectives.UnitaryFreePhaseInfidelityObjective-Union{Tuple{}, Tuple{R}} where R<:Real","page":"Library","title":"QuantumCollocation.Objectives.UnitaryFreePhaseInfidelityObjective","text":"UnitaryFreePhaseInfidelityObjective\n\nA type of objective that measures the infidelity of a unitary operator to a target unitary operator, where the target unitary operator is allowed to have phases on qubit subspaces.\n\nFields:     name: the name of the unitary operator in the trajectory     global_name: the name of the global phase in the trajectory     goal: the target unitary operator     Q: a scaling factor     eval_hessian: whether to evaluate the Hessian     subspace: the subspace in which to evaluate the objective\n\n\n\n\n\n","category":"method"},{"location":"lib/#QuantumCollocation.Objectives.UnitaryInfidelityObjective-Tuple{}","page":"Library","title":"QuantumCollocation.Objectives.UnitaryInfidelityObjective","text":"UnitaryInfidelityObjective\n\nA type of objective that measures the infidelity of a unitary operator to a target unitary operator.\n\nFields:     name: the name of the unitary operator in the trajectory     goal: the target unitary operator     Q: a scaling factor     eval_hessian: whether to evaluate the Hessian     subspace: the subspace in which to evaluate the objective\n\n\n\n\n\n","category":"method"},{"location":"lib/#QuantumCollocation.Objectives.UnitaryRobustnessObjective-Tuple{}","page":"Library","title":"QuantumCollocation.Objectives.UnitaryRobustnessObjective","text":"UnitaryRobustnessObjective(;     H::::Union{OperatorType, Nothing}=nothing,     eval_hessian::Bool=false,     symb::Symbol=:Ũ⃗ )\n\nCreate a control objective which penalizes the sensitivity of the infidelity to the provided operator defined in the subspace of the control dynamics, thereby realizing robust control.\n\nThe control dynamics are\n\nU_C(a)= prod_t exp-i H_C(a_t)\n\nIn the control frame, the H operator is (proportional to)\n\nR_Robust(a) = frac1T normH_e_2 sum_t U_C(a_t)^dag H_e U_C(a_t) Delta t\n\nwhere we have adjusted to a unitless expression of the operator.\n\nThe robustness objective is\n\nR_Robust(a) = frac1N normR^2_F\n\nwhere N is the dimension of the Hilbert space.\n\n\n\n\n\n","category":"method"},{"location":"lib/#QuantumCollocation.Objectives.sparse_to_moi-Tuple{SparseArrays.SparseMatrixCSC}","page":"Library","title":"QuantumCollocation.Objectives.sparse_to_moi","text":"sparse_to_moi(A::SparseMatrixCSC)\n\nConverts a sparse matrix to tuple of vector of nonzero indices and vector of nonzero values\n\n\n\n\n\n","category":"method"},{"location":"lib/#Losses","page":"Library","title":"Losses","text":"","category":"section"},{"location":"lib/","page":"Library","title":"Library","text":"Modules = [QuantumCollocation.Losses]","category":"page"},{"location":"lib/#QuantumCollocation.Losses.fidelity-Tuple{AbstractVector, AbstractVector}","page":"Library","title":"QuantumCollocation.Losses.fidelity","text":"fidelity(ψ, ψ_goal)\n\nCalculate the fidelity between two quantum states ψ and ψ_goal.\n\n\n\n\n\n","category":"method"},{"location":"lib/#QuantumCollocation.Losses.iso_fidelity-Tuple{AbstractVector, AbstractVector}","page":"Library","title":"QuantumCollocation.Losses.iso_fidelity","text":"iso_fidelity(ψ̃, ψ̃_goal)\n\nCalculate the fidelity between two quantum states in their isomorphic form ψ̃ and ψ̃_goal.\n\n\n\n\n\n","category":"method"},{"location":"lib/#QuantumCollocation.Losses.iso_infidelity","page":"Library","title":"QuantumCollocation.Losses.iso_infidelity","text":"iso_infidelity(ψ̃, ψ̃goal)\n\nReturns the iso_infidelity between two quantum statevectors specified in the mathbbC^n to mathbbR^2n isomorphism space.\n\n\n\n\n\n","category":"function"},{"location":"lib/#QuantumCollocation.Losses.iso_vec_unitary_fidelity-Tuple{AbstractVector, AbstractVector}","page":"Library","title":"QuantumCollocation.Losses.iso_vec_unitary_fidelity","text":"iso_vec_unitary_fidelity(Ũ⃗::AbstractVector, Ũ⃗_goal::AbstractVector)\n\nReturns the fidelity between the isomorphic unitary vector vecwidetildeU sim U in SU(n) and the isomorphic goal unitary vector vecwidetildeU_textgoal.\n\nbeginaligned\nmathcalF(vecwidetildeU vecwidetildeU_textgoal) = frac1n abstr qty(U_textgoal^dagger U) \n= frac1n sqrtT_R^2 + T_I^2\nendaligned\n\nwhere T_R = langle vecwidetildeU_textgoal R vecwidetildeU_R rangle + langle vecwidetildeU_textgoal I vecwidetildeU_I rangle and T_I = langle vecwidetildeU_textgoal R vecwidetildeU_I rangle - langle vecwidetildeU_textgoal I vecwidetildeU_R rangle.\n\n\n\n\n\n","category":"method"},{"location":"lib/#QuantumCollocation.Losses.unitary_fidelity-Tuple{Matrix, Matrix}","page":"Library","title":"QuantumCollocation.Losses.unitary_fidelity","text":"unitary_fidelity(U::Matrix, U_goal::Matrix; kwargs...)\nunitary_fidelity(Ũ⃗::AbstractVector, Ũ⃗_goal::AbstractVector; kwargs...)\n\nCalculate the fidelity between two unitary operators U and U_goal.\n\nmathcalF(U U_textgoal) = frac1n abstr qty(U_textgoal^dagger U)\n\nwhere n is the dimension of the unitary operators.\n\nKeyword Arguments\n\nsubspace::AbstractVector{Int}: The subspace to calculate the fidelity over.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Embedded-Operators","page":"Library","title":"Embedded Operators","text":"","category":"section"},{"location":"lib/","page":"Library","title":"Library","text":"Modules = [QuantumCollocation.EmbeddedOperators]","category":"page"},{"location":"lib/#QuantumCollocation.EmbeddedOperators.EmbeddedOperator-Tuple{Matrix{<:Number}, AbstractVector{Int64}, AbstractVector{Int64}}","page":"Library","title":"QuantumCollocation.EmbeddedOperators.EmbeddedOperator","text":"EmbeddedOperator(op::Matrix{<:Number}, subspace_indices::AbstractVector{Int}, subsystem_levels::AbstractVector{Int})\n\nCreate an embedded operator. The operator op is embedded in the subspace defined by subspace_indices in subsystem_levels.\n\nArguments\n\nop::Matrix{<:Number}: Operator to embed.\nsubspace_indices::AbstractVector{Int}: Indices of the subspace to embed the operator in. e.g. get_subspace_indices([1:2, 1:2], [3, 3]).\nsubsystem_levels::AbstractVector{Int}: Levels of the subsystems in the composite system. e.g. [3, 3] for two 3-level systems.\n\n\n\n\n\n","category":"method"},{"location":"lib/#QuantumCollocation.EmbeddedOperators.embed-Tuple{Matrix{ComplexF64}, AbstractVector{Int64}, Int64}","page":"Library","title":"QuantumCollocation.EmbeddedOperators.embed","text":"embed(matrix::Matrix{ComplexF64}, subspace_indices::AbstractVector{Int}, levels::Int)\n\nEmbed an operator U in the subspace of a larger system mathcalX = mathcalX_textsubspace oplus mathcalX_textleakage which is composed of matrices of size textlevels times textlevels.\n\nArguments\n\nmatrix::Matrix{ComplexF64}: Operator to embed.\nsubspace_indices::AbstractVector{Int}: Indices of the subspace to embed the operator in.\nlevels::Int: Total number of levels in the system.\n\n\n\n\n\n","category":"method"},{"location":"lib/#QuantumCollocation.EmbeddedOperators.get_subspace_indices-Tuple{Vector{<:AbstractVector{Int64}}, AbstractVector{Int64}}","page":"Library","title":"QuantumCollocation.EmbeddedOperators.get_subspace_indices","text":"get_subspace_indices(subspaces::Vector{<:AbstractVector{Int}}, subsystem_levels::AbstractVector{Int})\n\nGet the indices for the subspace of composite quantum system.\n\nExample: for the two-qubit subspace of two 3-level systems:\n\nsubspaces = [1:2, 1:2]\nsubsystem_levels = [3, 3]\nget_subspace_indices(subspaces, subsystem_levels) == [1, 2, 4, 5]\n\nArguments\n\nsubspaces::Vector{<:AbstractVector{Int}}: Subspaces to get indices for. e.g. [1:2, 1:2].\nsubsystem_levels::AbstractVector{Int}: Levels of the subsystems in the composite system. e.g. [3, 3]. Each element corresponds to a subsystem.\n\n\n\n\n\n","category":"method"},{"location":"lib/#QuantumCollocation.EmbeddedOperators.unembed-Tuple{AbstractMatrix, AbstractVector{Int64}}","page":"Library","title":"QuantumCollocation.EmbeddedOperators.unembed","text":"unembed(matrix::AbstractMatrix, subspace_indices::AbstractVector{Int})\n\nUnembed an operator U from a subspace of a larger system mathcalX = mathcalX_textsubspace oplus mathcalX_textleakage which is composed of matrices of size textlevels times textlevels.\n\nThis is equivalent to calling matrix[subspace_indices, subspace_indices].\n\nArguments\n\nmatrix::AbstractMatrix: Operator to unembed.\nsubspace_indices::AbstractVector{Int}: Indices of the subspace to unembed the operator from.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Isomorphisms","page":"Library","title":"Isomorphisms","text":"","category":"section"},{"location":"lib/","page":"Library","title":"Library","text":"Modules = [QuantumCollocation.Isomorphisms]","category":"page"},{"location":"lib/#QuantumCollocation.Isomorphisms.G-Tuple{AbstractMatrix{<:Number}}","page":"Library","title":"QuantumCollocation.Isomorphisms.G","text":"G(H::AbstractMatrix)::Matrix{Float64}\n\nReturns the isomorphism of -iH:\n\nG(H) = widetilde- i H = mqty(1  0  0  1) otimes Im(H) - mqty(0  -1  1  0) otimes Re(H)\n\nwhere Im(H) and Re(H) are the imaginary and real parts of H and the tilde indicates the standard isomorphism of a complex valued matrix:\n\nwidetildeH = mqty(1  0  0  1) otimes Re(H) + mqty(0  -1  1  0) otimes Im(H)\n\n\n\n\n\n","category":"method"},{"location":"lib/#QuantumCollocation.Isomorphisms.H-Tuple{AbstractMatrix{<:Number}}","page":"Library","title":"QuantumCollocation.Isomorphisms.H","text":"H(G::AbstractMatrix{<:Number})::Matrix{ComplexF64}\n\nReturns the inverse of G(H) = iso(-iH), i.e. returns H\n\n\n\n\n\n","category":"method"},{"location":"lib/#QuantumCollocation.Isomorphisms.iso_dm-Tuple{AbstractMatrix}","page":"Library","title":"QuantumCollocation.Isomorphisms.iso_dm","text":"iso_dm(ρ::AbstractMatrix)\n\nreturns the isomorphism ρ⃗̃ = ket_to_iso(vec(ρ)) of a density matrix ρ\n\n\n\n\n\n","category":"method"},{"location":"lib/#QuantumCollocation.Isomorphisms.iso_operator_to_iso_vec-Union{Tuple{AbstractMatrix{R}}, Tuple{R}} where R","page":"Library","title":"QuantumCollocation.Isomorphisms.iso_operator_to_iso_vec","text":"iso_operator_to_iso_vec(Ũ::AbstractMatrix)\n\nConvert a real matrix Ũ representing an isomorphism operator into a real vector.\n\nMust be differentiable.\n\n\n\n\n\n","category":"method"},{"location":"lib/#QuantumCollocation.Isomorphisms.iso_to_ket-Tuple{Any}","page":"Library","title":"QuantumCollocation.Isomorphisms.iso_to_ket","text":"iso_to_ket(ψ̃)\n\nConvert a complex vector ψ̃ with real and imaginary parts into a ket vector.\n\n\n\n\n\n","category":"method"},{"location":"lib/#QuantumCollocation.Isomorphisms.iso_vec_to_iso_operator-Union{Tuple{AbstractVector{R}}, Tuple{R}} where R","page":"Library","title":"QuantumCollocation.Isomorphisms.iso_vec_to_iso_operator","text":"iso_vec_to_iso_operator(Ũ⃗::AbstractVector)\n\nConvert a real vector Ũ⃗ into a real matrix representing an isomorphism operator.\n\nMust be differentiable.\n\n\n\n\n\n","category":"method"},{"location":"lib/#QuantumCollocation.Isomorphisms.iso_vec_to_operator-Union{Tuple{AbstractVector{R}}, Tuple{R}} where R","page":"Library","title":"QuantumCollocation.Isomorphisms.iso_vec_to_operator","text":"iso_vec_to_operator(Ũ⃗::AbstractVector)\n\nConvert a real vector Ũ⃗ into a complex matrix representing an operator.\n\nMust be differentiable.\n\n\n\n\n\n","category":"method"},{"location":"lib/#QuantumCollocation.Isomorphisms.ket_to_iso-Tuple{Any}","page":"Library","title":"QuantumCollocation.Isomorphisms.ket_to_iso","text":"ket_to_iso(ψ)\n\nConvert a ket vector ψ into a complex vector with real and imaginary parts.\n\n\n\n\n\n","category":"method"},{"location":"lib/#QuantumCollocation.Isomorphisms.mat-Tuple{AbstractVector}","page":"Library","title":"QuantumCollocation.Isomorphisms.mat","text":"mat(x::AbstractVector)\n\nConvert a vector x into a square matrix. The length of x must be a perfect square.\n\n\n\n\n\n","category":"method"},{"location":"lib/#QuantumCollocation.Isomorphisms.operator_to_iso_vec-Union{Tuple{AbstractMatrix{R}}, Tuple{R}} where R","page":"Library","title":"QuantumCollocation.Isomorphisms.operator_to_iso_vec","text":"operator_to_iso_vec(U::AbstractMatrix{<:Complex})\n\nConvert a complex matrix U representing an operator into a real vector.\n\nMust be differentiable.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Options","page":"Library","title":"Options","text":"","category":"section"},{"location":"lib/","page":"Library","title":"Library","text":"Modules = [QuantumCollocation.Options]","category":"page"},{"location":"lib/#QuantumCollocation.Options.IpoptOptions","page":"Library","title":"QuantumCollocation.Options.IpoptOptions","text":"Solver options for Ipopt\n\nhttps://coin-or.github.io/Ipopt/OPTIONS.html#OPT_print_options_documentation\n\n\n\n\n\n","category":"type"},{"location":"lib/#QuantumCollocation.Options.PiccoloOptions","page":"Library","title":"QuantumCollocation.Options.PiccoloOptions","text":"Solver settings for Quantum Collocation.\n\n\n\n\n\n","category":"type"},{"location":"lib/#Plotting","page":"Library","title":"Plotting","text":"","category":"section"},{"location":"lib/","page":"Library","title":"Library","text":"Modules = [QuantumCollocation.Plotting]","category":"page"},{"location":"lib/#QuantumCollocation.Plotting.plot_unitary_populations","page":"Library","title":"QuantumCollocation.Plotting.plot_unitary_populations","text":"plot_unitary_populations(\n    traj::NamedTrajectory;\n    unitary_columns::AbstractVector{Int}=1:2,\n    unitary_name::Symbol=:Ũ⃗,\n    control_name::Symbol=:a,\n    kwargs...\n)\n\nplot_unitary_populations(\n    prob::QuantumControlProblem;\n    kwargs...\n)\n\nPlot the populations of the unitary columns of the unitary matrix in the trajectory. kwargs are passed to NamedTrajectories.plot.\n\n\n\n\n\n","category":"function"},{"location":"lib/#Problem-Solvers","page":"Library","title":"Problem Solvers","text":"","category":"section"},{"location":"lib/","page":"Library","title":"Library","text":"Modules = [QuantumCollocation.ProblemSolvers]","category":"page"},{"location":"lib/#Rollouts","page":"Library","title":"Rollouts","text":"","category":"section"},{"location":"lib/","page":"Library","title":"Library","text":"Modules = [QuantumCollocation.Rollouts]","category":"page"},{"location":"lib/#QuantumCollocation.Rollouts.infer_is_evp-Tuple{Function}","page":"Library","title":"QuantumCollocation.Rollouts.infer_is_evp","text":"infer_is_evp(integrator::Function)\n\nInfer whether the integrator is a exponential-vector product (EVP) function.\n\nIf true, the integrator is expected to have a signature like the exponential action, expv. Otherwise, it is expected to have a signature like exp.\n\n\n\n\n\n","category":"method"},{"location":"lib/#QuantumCollocation.Rollouts.lab_frame_unitary_rollout-Tuple{AbstractQuantumSystem, AbstractMatrix{Float64}}","page":"Library","title":"QuantumCollocation.Rollouts.lab_frame_unitary_rollout","text":"lab_frame_unitary_rollout(\n    sys::AbstractQuantumSystem,\n    controls::AbstractMatrix{Float64};\n    duration=nothing,\n    timestep=nothing,\n    ω=nothing,\n    timestep_nyquist=1 / (50 * ω)\n)\n\n\n\n\n\n","category":"method"},{"location":"lib/#QuantumCollocation.Rollouts.rollout-Tuple{AbstractVector{<:Real}, AbstractMatrix, AbstractVector, AbstractQuantumSystem}","page":"Library","title":"QuantumCollocation.Rollouts.rollout","text":"rollout(\n    ψ̃_init::AbstractVector{<:Float64},\n    controls::AbstractMatrix,\n    Δt::AbstractVector,\n    system::AbstractQuantumSystem\n)\n\nRollout a quantum state ψ̃_init under the control controls for a time Δt using the system system.\n\nIf exp_vector_product is true, the integrator is expected to have a signature like the exponential action, expv. Otherwise, it is expected to have a signature like exp.\n\nTypes should allow for autodifferentiable controls and times.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Saving-and-Loading","page":"Library","title":"Saving and Loading","text":"","category":"section"},{"location":"lib/","page":"Library","title":"Library","text":"Modules = [QuantumCollocation.SaveLoadUtils]","category":"page"},{"location":"lib/#Structure-Utils","page":"Library","title":"Structure Utils","text":"","category":"section"},{"location":"lib/","page":"Library","title":"Library","text":"Modules = [QuantumCollocation.StructureUtils]","category":"page"},{"location":"lib/#Trajectory-Initialization","page":"Library","title":"Trajectory Initialization","text":"","category":"section"},{"location":"lib/","page":"Library","title":"Library","text":"Modules = [QuantumCollocation.TrajectoryInitialization]","category":"page"},{"location":"lib/#QuantumCollocation.TrajectoryInitialization.initialize_trajectory-Tuple{Vector{Matrix{Float64}}, Vector{<:AbstractVector{Float64}}, Vector{<:AbstractVector{Float64}}, AbstractVector{Symbol}, Int64, Union{Float64, AbstractVecOrMat{<:Float64}}, Int64, Tuple{Vararg{Union{Tuple{AbstractVector{R}, AbstractVector{R}}, AbstractVector{R}} where R<:Real}}}","page":"Library","title":"QuantumCollocation.TrajectoryInitialization.initialize_trajectory","text":"initialize_unitary_trajectory\n\nInitialize a trajectory for a unitary control problem. The trajectory is initialized with data that should be consistently the same type (in this case, Float64).\n\n\n\n\n\n","category":"method"},{"location":"lib/#QuantumCollocation.TrajectoryInitialization.unitary_geodesic","page":"Library","title":"QuantumCollocation.TrajectoryInitialization.unitary_geodesic","text":"unitary_geodesic(\n    operator::EmbeddedOperator,\n    samples::Int;\n    kwargs...\n)\n\nunitary_geodesic(\n    U_goal::AbstractMatrix{<:Number},\n    samples::Int;\n    kwargs...\n)\n\nunitary_geodesic(\n    U₀::AbstractMatrix{<:Number},\n    U₁::AbstractMatrix{<:Number},\n    samples::Number;\n    kwargs...\n)\n\nunitary_geodesic(\n    U₀::AbstractMatrix{<:Number},\n    U₁::AbstractMatrix{<:Number},\n    timesteps::AbstractVector{<:Number};\n    return_generator=false\n)\n\nCompute a geodesic connecting two unitary operators.\n\n\n\n\n\n","category":"function"},{"location":"lib/#QuantumCollocation.TrajectoryInitialization.unitary_geodesic-Tuple{AbstractMatrix{<:Number}, AbstractMatrix{<:Number}, AbstractVector{<:Number}}","page":"Library","title":"QuantumCollocation.TrajectoryInitialization.unitary_geodesic","text":"unitary_geodesic(U_init, U_goal, times; kwargs...)\n\nCompute the geodesic connecting Uinit and Ugoal at the specified times. Allows for the possibility of unequal times and ranges outside [0,1].\n\nArguments\n\nU_init::AbstractMatrix{<:Number}: The initial unitary operator.\nU_goal::AbstractMatrix{<:Number}: The goal unitary operator.\ntimes::AbstractVector{<:Number}: The times at which to evaluate the geodesic.\n\nKeyword Arguments\n\nreturn_unitary_isos::Bool=true: If true returns a matrix where each column is a unitary isovec, i.e. vec(vcat(real(U), imag(U))). If false, returns a vector of unitary matrices.\nreturn_generator::Bool=false: If true, returns the effective Hamiltonian generating the geodesic.\n\n\n\n\n\n","category":"method"},{"location":"lib/#QuantumCollocation.TrajectoryInitialization.unitary_linear_interpolation-Tuple{AbstractMatrix{<:Number}, AbstractMatrix{<:Number}, Int64}","page":"Library","title":"QuantumCollocation.TrajectoryInitialization.unitary_linear_interpolation","text":"unitary_linear_interpolation(\n    U_init::AbstractMatrix,\n    U_goal::AbstractMatrix,\n    samples::Int\n)\n\nCompute a linear interpolation of unitary operators with samples samples.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Trajectory-Interpolations","page":"Library","title":"Trajectory Interpolations","text":"","category":"section"},{"location":"lib/","page":"Library","title":"Library","text":"Modules = [QuantumCollocation.TrajectoryInterpolations]","category":"page"},{"location":"generated/examples/two_qubit_gates/","page":"Two Qubit Gates","title":"Two Qubit Gates","text":"EditURL = \"../../../literate/examples/two_qubit_gates.jl\"","category":"page"},{"location":"generated/examples/two_qubit_gates/#Two-Qubit-Gates","page":"Two Qubit Gates","title":"Two Qubit Gates","text":"","category":"section"},{"location":"generated/examples/two_qubit_gates/","page":"Two Qubit Gates","title":"Two Qubit Gates","text":"In this example we will solve for a selection of two-qubit gates using a simple two-qubit system. We will use the UnitarySmoothPulseProblem template to solve for the optimal control fields.","category":"page"},{"location":"generated/examples/two_qubit_gates/#Defining-our-Hamiltonian","page":"Two Qubit Gates","title":"Defining our Hamiltonian","text":"","category":"section"},{"location":"generated/examples/two_qubit_gates/","page":"Two Qubit Gates","title":"Two Qubit Gates","text":"In quantum optimal control we work with Hamiltonians of the form","category":"page"},{"location":"generated/examples/two_qubit_gates/","page":"Two Qubit Gates","title":"Two Qubit Gates","text":"H(t) = H_textdrift + sum_j u^j(t) H_textdrive^j","category":"page"},{"location":"generated/examples/two_qubit_gates/","page":"Two Qubit Gates","title":"Two Qubit Gates","text":"Specifically, for a simple two-qubit system in a rotating frame, we have","category":"page"},{"location":"generated/examples/two_qubit_gates/","page":"Two Qubit Gates","title":"Two Qubit Gates","text":"H = J_12 sigma_1^x sigma_2^x + sum_i in 12 a_i^R(t) sigma^x_i over 2 + a_i^I(t) sigma^y_i over 2","category":"page"},{"location":"generated/examples/two_qubit_gates/","page":"Two Qubit Gates","title":"Two Qubit Gates","text":"where","category":"page"},{"location":"generated/examples/two_qubit_gates/","page":"Two Qubit Gates","title":"Two Qubit Gates","text":"beginalign*\nJ_12 = 0001 text GHz \na_i^R(t) leq 01 text GHz \nendalign*","category":"page"},{"location":"generated/examples/two_qubit_gates/","page":"Two Qubit Gates","title":"Two Qubit Gates","text":"And the duration of the gate will be capped at 400  mu s.","category":"page"},{"location":"generated/examples/two_qubit_gates/","page":"Two Qubit Gates","title":"Two Qubit Gates","text":"Let's now set this up using some of the convenience functions available in QuantumCollocation.jl.","category":"page"},{"location":"generated/examples/two_qubit_gates/","page":"Two Qubit Gates","title":"Two Qubit Gates","text":"using QuantumCollocation\nusing NamedTrajectories\nusing LinearAlgebra\n\n# Define our operators\nσx = GATES[:X]\nσy = GATES[:Y]\nId = GATES[:I]\n\n# Lift the operators to the two-qubit Hilbert space\nσx_1 = σx ⊗ Id\nσx_2 = Id ⊗ σx\n\nσy_1 = σy ⊗ Id\nσy_2 = Id ⊗ σy\n\n# Define the parameters of the Hamiltonian\nJ_12 = 0.001 # GHz\na_bound = 0.100 # GHz\n\n# Define the drift (coupling) Hamiltonian\nH_drift = J_12 * (σx ⊗ σx)\n\n# Define the control Hamiltonians\nH_drives = [σx_1 / 2, σy_1 / 2, σx_2 / 2, σy_2 / 2]\n\n# Define control (and higher derivative) bounds\na_bound = 0.1\nda_bound = 0.0005\ndda_bound = 0.0025\n\n# Scale the Hamiltonians by 2π\nH_drift *= 2π\nH_drives .*= 2π\n\n# Define the time parameters\nT = 100 # timesteps\nduration = 100 # μs\nΔt = duration / T\nΔt_max = 400 / T\n\n# Define the system\nsys = QuantumSystem(H_drift, H_drives)\n\n# Look at max eigenvalue of the generator (for deciding if Pade integrators are viable)\nmaximum(abs.(eigvals(Δt_max * (H_drift + sum(a_bound .* H_drives)))))","category":"page"},{"location":"generated/examples/two_qubit_gates/","page":"Two Qubit Gates","title":"Two Qubit Gates","text":"That this value above is greater than one means that we must use an exponential integrator for these problems. We can set the kwarg integrator=:exponential in the PiccoloOptions struct as follows.","category":"page"},{"location":"generated/examples/two_qubit_gates/","page":"Two Qubit Gates","title":"Two Qubit Gates","text":"piccolo_options = PiccoloOptions(\n    integrator=:exponential,\n)","category":"page"},{"location":"generated/examples/two_qubit_gates/#SWAP-gate","page":"Two Qubit Gates","title":"SWAP gate","text":"","category":"section"},{"location":"generated/examples/two_qubit_gates/","page":"Two Qubit Gates","title":"Two Qubit Gates","text":"# Define the goal operation\nU_goal = [\n    1 0 0 0;\n    0 0 1 0;\n    0 1 0 0;\n    0 0 0 1\n] |> Matrix{ComplexF64}\n\n# Set up and solve the problem\n\nprob = UnitarySmoothPulseProblem(\n    sys,\n    U_goal,\n    T,\n    Δt;\n    a_bound=a_bound,\n    da_bound=da_bound,\n    dda_bound=dda_bound,\n    R_da=0.01,\n    R_dda=0.01,\n    Δt_max=Δt_max,\n    piccolo_options=piccolo_options\n)\n\nsolve!(prob; max_iter=100)\n\n# Let's take a look at the final fidelity\nunitary_fidelity(prob)","category":"page"},{"location":"generated/examples/two_qubit_gates/","page":"Two Qubit Gates","title":"Two Qubit Gates","text":"Looks good!","category":"page"},{"location":"generated/examples/two_qubit_gates/","page":"Two Qubit Gates","title":"Two Qubit Gates","text":"Now let's plot the pulse and the population trajectories for the first two columns of the unitary, i.e. initial state of ket00 and ket01. For this we provide the function plot_unitary_populations.","category":"page"},{"location":"generated/examples/two_qubit_gates/","page":"Two Qubit Gates","title":"Two Qubit Gates","text":"plot_unitary_populations(prob)","category":"page"},{"location":"generated/examples/two_qubit_gates/","page":"Two Qubit Gates","title":"Two Qubit Gates","text":"For fun, let's look at a minimum time pulse for this problem","category":"page"},{"location":"generated/examples/two_qubit_gates/","page":"Two Qubit Gates","title":"Two Qubit Gates","text":"min_time_prob = UnitaryMinimumTimeProblem(prob; final_fidelity=.99)\n\nsolve!(min_time_prob; max_iter=300)\n\nunitary_fidelity(min_time_prob)","category":"page"},{"location":"generated/examples/two_qubit_gates/","page":"Two Qubit Gates","title":"Two Qubit Gates","text":"And let's plot this solution","category":"page"},{"location":"generated/examples/two_qubit_gates/","page":"Two Qubit Gates","title":"Two Qubit Gates","text":"plot_unitary_populations(min_time_prob)","category":"page"},{"location":"generated/examples/two_qubit_gates/","page":"Two Qubit Gates","title":"Two Qubit Gates","text":"It looks like our pulse derivative bounds are holding back the solution, but regardless, the duration has decreased:","category":"page"},{"location":"generated/examples/two_qubit_gates/","page":"Two Qubit Gates","title":"Two Qubit Gates","text":"get_duration(prob.trajectory) - get_duration(min_time_prob.trajectory)","category":"page"},{"location":"generated/examples/two_qubit_gates/#Mølmer–Sørensen-gate","page":"Two Qubit Gates","title":"Mølmer–Sørensen gate","text":"","category":"section"},{"location":"generated/examples/two_qubit_gates/","page":"Two Qubit Gates","title":"Two Qubit Gates","text":"Here we will solve for a Mølmer–Sørensen gate between two. The gate is generally described, for N qubits, by the unitary matrix","category":"page"},{"location":"generated/examples/two_qubit_gates/","page":"Two Qubit Gates","title":"Two Qubit Gates","text":"U_textMS(vectheta) = expleft(isum_j=1^N-1sum_k=j+1^Ntheta_jksigma_j^xsigma_k^xright)","category":"page"},{"location":"generated/examples/two_qubit_gates/","page":"Two Qubit Gates","title":"Two Qubit Gates","text":"where sigma_j^x is the Pauli-X operator acting on the j-th qubit, and vectheta is a vector of real parameters. The Mølmer–Sørensen gate is a two-qubit gate that is particularly well-suited for trapped-ion qubits, where the interaction between qubits is mediated.","category":"page"},{"location":"generated/examples/two_qubit_gates/","page":"Two Qubit Gates","title":"Two Qubit Gates","text":"Here we will focus on the simplest case of a Mølmer–Sørensen gate between two qubits. The gate is described by the unitary matrix","category":"page"},{"location":"generated/examples/two_qubit_gates/","page":"Two Qubit Gates","title":"Two Qubit Gates","text":"U_textMSleft(pi over 4right) = expleft(ifracpi4sigma_1^xsigma_2^xright)","category":"page"},{"location":"generated/examples/two_qubit_gates/","page":"Two Qubit Gates","title":"Two Qubit Gates","text":"Let's set up the problem.","category":"page"},{"location":"generated/examples/two_qubit_gates/","page":"Two Qubit Gates","title":"Two Qubit Gates","text":"# Define the goal operation\nU_goal = exp(im * π/4 * σx_1 * σx_2)\n\n# Set up and solve the problem\n\nprob = UnitarySmoothPulseProblem(\n    sys,\n    U_goal,\n    T,\n    Δt;\n    a_bound=a_bound,\n    da_bound=da_bound,\n    dda_bound=dda_bound,\n    R_da=0.01,\n    R_dda=0.01,\n    Δt_max=Δt_max,\n    piccolo_options=piccolo_options\n)\n\nsolve!(prob; max_iter=1_000)\n\n# Let's take a look at the final fidelity\nunitary_fidelity(prob)","category":"page"},{"location":"generated/examples/two_qubit_gates/","page":"Two Qubit Gates","title":"Two Qubit Gates","text":"Again, looks good!","category":"page"},{"location":"generated/examples/two_qubit_gates/","page":"Two Qubit Gates","title":"Two Qubit Gates","text":"Now let's plot the pulse and the population trajectories for the first two columns of the unitary, i.e. initial state of ket00 and ket01.","category":"page"},{"location":"generated/examples/two_qubit_gates/","page":"Two Qubit Gates","title":"Two Qubit Gates","text":"plot_unitary_populations(prob)","category":"page"},{"location":"generated/examples/two_qubit_gates/","page":"Two Qubit Gates","title":"Two Qubit Gates","text":"For fun, let's look at a minimum time pulse for this problem","category":"page"},{"location":"generated/examples/two_qubit_gates/","page":"Two Qubit Gates","title":"Two Qubit Gates","text":"min_time_prob = UnitaryMinimumTimeProblem(prob; final_fidelity=.999)\n\nsolve!(min_time_prob; max_iter=300)\n\nunitary_fidelity(min_time_prob)","category":"page"},{"location":"generated/examples/two_qubit_gates/","page":"Two Qubit Gates","title":"Two Qubit Gates","text":"And let's plot this solution","category":"page"},{"location":"generated/examples/two_qubit_gates/","page":"Two Qubit Gates","title":"Two Qubit Gates","text":"plot_unitary_populations(min_time_prob)","category":"page"},{"location":"generated/examples/two_qubit_gates/","page":"Two Qubit Gates","title":"Two Qubit Gates","text":"It looks like our pulse derivative bounds are holding back the solution, but regardless, the duration has decreased:","category":"page"},{"location":"generated/examples/two_qubit_gates/","page":"Two Qubit Gates","title":"Two Qubit Gates","text":"get_duration(prob.trajectory) - get_duration(min_time_prob.trajectory)","category":"page"},{"location":"generated/examples/two_qubit_gates/","page":"Two Qubit Gates","title":"Two Qubit Gates","text":"","category":"page"},{"location":"generated/examples/two_qubit_gates/","page":"Two Qubit Gates","title":"Two Qubit Gates","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/examples/multilevel_transmon/","page":"Multilevel Transmon","title":"Multilevel Transmon","text":"EditURL = \"../../../literate/examples/multilevel_transmon.jl\"","category":"page"},{"location":"generated/examples/multilevel_transmon/#Multilevel-Transmon","page":"Multilevel Transmon","title":"Multilevel Transmon","text":"","category":"section"},{"location":"generated/examples/multilevel_transmon/","page":"Multilevel Transmon","title":"Multilevel Transmon","text":"In this example we will look at a multilevel transmon qubit with a Hamiltonian given by","category":"page"},{"location":"generated/examples/multilevel_transmon/","page":"Multilevel Transmon","title":"Multilevel Transmon","text":"hatH(t) = -fracdelta2 hatn(hatn - 1) + u_1(t) (hata + hata^dagger) + u_2(t) i (hata - hata^dagger)","category":"page"},{"location":"generated/examples/multilevel_transmon/","page":"Multilevel Transmon","title":"Multilevel Transmon","text":"where hatn = hata^dagger hata is the number operator, hata is the annihilation operator, delta is the anharmonicity, and u_1(t) and u_2(t) are control fields.","category":"page"},{"location":"generated/examples/multilevel_transmon/","page":"Multilevel Transmon","title":"Multilevel Transmon","text":"We will use the following parameter values:","category":"page"},{"location":"generated/examples/multilevel_transmon/","page":"Multilevel Transmon","title":"Multilevel Transmon","text":"beginaligned\ndelta = 02 text GHz\nabsu_i(t) leq 02 text GHz\nT_0 = 10 text ns\nendaligned","category":"page"},{"location":"generated/examples/multilevel_transmon/","page":"Multilevel Transmon","title":"Multilevel Transmon","text":"For convenience, we have defined the TransmonSystem function in the QuantumSystemTemplates module, which returns a QuantumSystem object for a transmon qubit. We will use this function to define the system.","category":"page"},{"location":"generated/examples/multilevel_transmon/#Setting-up-the-problem","page":"Multilevel Transmon","title":"Setting up the problem","text":"","category":"section"},{"location":"generated/examples/multilevel_transmon/","page":"Multilevel Transmon","title":"Multilevel Transmon","text":"To begin, let's load the necessary packages, define the system parameters, and create a a QuantumSystem object using the TransmonSystem function.","category":"page"},{"location":"generated/examples/multilevel_transmon/","page":"Multilevel Transmon","title":"Multilevel Transmon","text":"using QuantumCollocation\nusing NamedTrajectories\nusing LinearAlgebra\nusing SparseArrays\nusing Random; Random.seed!(123)\n\n# define the time parameters\n\nT₀ = 10     # total time in ns\nT = 50      # number of time steps\nΔt = T₀ / T # time step\n\n# define the system parameters\nlevels = 5\nδ = 0.2\n\n# add a bound to the controls\na_bound = 0.2\n\n# create the system\nsys = TransmonSystem(levels=levels, δ=δ)\n\n# let's look at the parameters of the system\nsys.params","category":"page"},{"location":"generated/examples/multilevel_transmon/","page":"Multilevel Transmon","title":"Multilevel Transmon","text":"Since this is a multilevel transmon and we want to implement an, let's say, X gate on the qubit subspace, i.e., the first two levels we can utilize the EmbeddedOperator type to define the target operator.","category":"page"},{"location":"generated/examples/multilevel_transmon/","page":"Multilevel Transmon","title":"Multilevel Transmon","text":"# define the target operator\nop = EmbeddedOperator(:X, sys)\n\n# show the full operator\nop.operator |> sparse","category":"page"},{"location":"generated/examples/multilevel_transmon/","page":"Multilevel Transmon","title":"Multilevel Transmon","text":"In this formulation, we also use a subspace identity as the initial state, which looks like","category":"page"},{"location":"generated/examples/multilevel_transmon/","page":"Multilevel Transmon","title":"Multilevel Transmon","text":"get_subspace_identity(op) |> sparse","category":"page"},{"location":"generated/examples/multilevel_transmon/","page":"Multilevel Transmon","title":"Multilevel Transmon","text":"We can then pass this embedded operator to the UnitarySmoothPulseProblem template to create","category":"page"},{"location":"generated/examples/multilevel_transmon/","page":"Multilevel Transmon","title":"Multilevel Transmon","text":"# create the problem\nprob = UnitarySmoothPulseProblem(sys, op, T, Δt; a_bound=a_bound)\n\n# solve the problem\nsolve!(prob; max_iter=50)","category":"page"},{"location":"generated/examples/multilevel_transmon/","page":"Multilevel Transmon","title":"Multilevel Transmon","text":"Let's look at the fidelity in the subspace","category":"page"},{"location":"generated/examples/multilevel_transmon/","page":"Multilevel Transmon","title":"Multilevel Transmon","text":"println(\"Fidelity: \", unitary_fidelity(prob; subspace=op.subspace_indices))","category":"page"},{"location":"generated/examples/multilevel_transmon/","page":"Multilevel Transmon","title":"Multilevel Transmon","text":"and plot the result using the plot_unitary_populations function.","category":"page"},{"location":"generated/examples/multilevel_transmon/","page":"Multilevel Transmon","title":"Multilevel Transmon","text":"plot_unitary_populations(prob; fig_size=(900, 700))","category":"page"},{"location":"generated/examples/multilevel_transmon/#Leakage-suppresion","page":"Multilevel Transmon","title":"Leakage suppresion","text":"","category":"section"},{"location":"generated/examples/multilevel_transmon/","page":"Multilevel Transmon","title":"Multilevel Transmon","text":"As can be seen from the above plot, there is a substantial amount of leakage into the higher levels during the evolution. To mitigate this, we have implemented the ability to add a cost to populating the leakage levels, in particular this is an L_1 norm cost, which is implemented via slack variables and should ideally drive those leakage populations down to zero. To implement this, pass leakage_suppresion=true and R_leakage={value} to the UnitarySmoothPulseProblem template.","category":"page"},{"location":"generated/examples/multilevel_transmon/","page":"Multilevel Transmon","title":"Multilevel Transmon","text":"# create the a leakage suppression problem, initializing with the previous solution\n\nprob_leakage = UnitarySmoothPulseProblem(sys, op, T, Δt;\n    a_bound=a_bound,\n    leakage_suppression=true,\n    R_leakage=1e-1,\n    a_guess=prob.trajectory.a\n)\n\n# solve the problem\n\nsolve!(prob_leakage; max_iter=50)","category":"page"},{"location":"generated/examples/multilevel_transmon/","page":"Multilevel Transmon","title":"Multilevel Transmon","text":"Let's look at the fidelity in the subspace","category":"page"},{"location":"generated/examples/multilevel_transmon/","page":"Multilevel Transmon","title":"Multilevel Transmon","text":"println(\"Fidelity: \", unitary_fidelity(prob_leakage; subspace=op.subspace_indices))","category":"page"},{"location":"generated/examples/multilevel_transmon/","page":"Multilevel Transmon","title":"Multilevel Transmon","text":"and plot the result using the plot_unitary_populations function.","category":"page"},{"location":"generated/examples/multilevel_transmon/","page":"Multilevel Transmon","title":"Multilevel Transmon","text":"plot_unitary_populations(prob_leakage; fig_size=(900, 700))","category":"page"},{"location":"generated/examples/multilevel_transmon/","page":"Multilevel Transmon","title":"Multilevel Transmon","text":"Here we can see that the leakage populations have been driven substantially down.","category":"page"},{"location":"generated/examples/multilevel_transmon/","page":"Multilevel Transmon","title":"Multilevel Transmon","text":"","category":"page"},{"location":"generated/examples/multilevel_transmon/","page":"Multilevel Transmon","title":"Multilevel Transmon","text":"This page was generated using Literate.jl.","category":"page"},{"location":"contribution_guide/#Contribution-Guide","page":"Contribution Guide","title":"Contribution Guide","text":"","category":"section"},{"location":"contribution_guide/#Introduction","page":"Contribution Guide","title":"Introduction","text":"","category":"section"},{"location":"contribution_guide/","page":"Contribution Guide","title":"Contribution Guide","text":"We welcome contributiuons to QuantumCollocation.jl! This document outlines the guidelines for contributing to the project. If you know what you want to see, but are unsure of the best way to achieve it, add an issue and start a discussion with the community! ","category":"page"},{"location":"contribution_guide/","page":"Contribution Guide","title":"Contribution Guide","text":"Let us know how you are using Piccolo! We enjoy hearing about the problems our users are solving.","category":"page"},{"location":"contribution_guide/#Developing","page":"Contribution Guide","title":"Developing","text":"","category":"section"},{"location":"contribution_guide/","page":"Contribution Guide","title":"Contribution Guide","text":"We recommend creating a fresh environment, and using the dev command to install QuantumCollocation.jl from source. Adding Revise.jl to this environment allows us to make changes to QuantumCollocation.jl during development, without restarting Julia or notebooks in VSCode.","category":"page"},{"location":"contribution_guide/","page":"Contribution Guide","title":"Contribution Guide","text":"Here are a few places to think about participating!","category":"page"},{"location":"contribution_guide/","page":"Contribution Guide","title":"Contribution Guide","text":"Documentation:","category":"page"},{"location":"contribution_guide/","page":"Contribution Guide","title":"Contribution Guide","text":"[ ] cross-referencing to library\n[ ] adding docstrings, examples, and tests of utilities\n[ ] examples\n[ ] two-qubit\n[ ] cat qubit \n[ ] three-qubit \n[ ] qubit-cavity\n[ ] qubit-cavity-qubit\n[ ] document type requirements for Constraints, Losses, and Objectives ","category":"page"},{"location":"contribution_guide/","page":"Contribution Guide","title":"Contribution Guide","text":"Functionality:","category":"page"},{"location":"contribution_guide/","page":"Contribution Guide","title":"Contribution Guide","text":"[ ] custom QuantumTrajectory types (repr. of isomorphic states)\n[ ] better quantum system constructors (e.g. storing composite system info) \n[ ] refactor Objectives and distinguish from Losses","category":"page"},{"location":"contribution_guide/#Documentation","page":"Contribution Guide","title":"Documentation","text":"","category":"section"},{"location":"contribution_guide/","page":"Contribution Guide","title":"Contribution Guide","text":"Documentation is built using Documenter.jl and uses Literate.jl to generate markdown files from scripts stored in docs/literate. To build the documentation locally, start julia with the docs environment:","category":"page"},{"location":"contribution_guide/","page":"Contribution Guide","title":"Contribution Guide","text":"julia --project=docs","category":"page"},{"location":"contribution_guide/","page":"Contribution Guide","title":"Contribution Guide","text":"Then (for ease of development) load the following packages:","category":"page"},{"location":"contribution_guide/","page":"Contribution Guide","title":"Contribution Guide","text":"using Revise, LiveServer, QuantumCollocation","category":"page"},{"location":"contribution_guide/","page":"Contribution Guide","title":"Contribution Guide","text":"To live-serve the docs, run","category":"page"},{"location":"contribution_guide/","page":"Contribution Guide","title":"Contribution Guide","text":"servedocs(literate_dir=\"docs/literate\", skip_dir=\"docs/src/generated\")","category":"page"},{"location":"contribution_guide/","page":"Contribution Guide","title":"Contribution Guide","text":"Changes made to files in the docs directory should be automatically reflected in the live server. To reflect changes in the source code (e.g. doc strings), since we are using Revise, simply kill the live server running in the REPL (with, e.g., Ctrl-C) and restart it with the above command. ","category":"page"},{"location":"contribution_guide/#Writing-tests","page":"Contribution Guide","title":"Writing tests","text":"","category":"section"},{"location":"contribution_guide/","page":"Contribution Guide","title":"Contribution Guide","text":"Tests are implemented using the TestItemRunner.jl package. ","category":"page"},{"location":"contribution_guide/","page":"Contribution Guide","title":"Contribution Guide","text":"@testitem \"Hadamard gate\" begin\n    H_drift, H_drives = GATES[:Z], [GATES[:X], GATES[:Y]]\n    U_goal = GATES[:H]\n    T = 51\n    Δt = 0.2\n\n    prob = UnitarySmoothPulseProblem(\n        H_drift, H_drives, U_goal, T, Δt,\n        ipopt_options=IpoptOptions(print_level=1)\n    )\n\n    solve!(prob, max_iter=100)\n    @test unitary_fidelity(prob) > 0.99\nend","category":"page"},{"location":"contribution_guide/","page":"Contribution Guide","title":"Contribution Guide","text":"Individual tests will populate in the Testing panel in VSCode. All tests are integrated into the base test system for CI, which occurs at each PR submission.","category":"page"},{"location":"contribution_guide/","page":"Contribution Guide","title":"Contribution Guide","text":"We organize our tests in two ways:","category":"page"},{"location":"contribution_guide/","page":"Contribution Guide","title":"Contribution Guide","text":"Modules in single files (e.g. quantum_utils.jl, direct_sums.jl) should have a single test file in the test/ directory.\nModule directories containing templates (e.g. quantum_system_templates/, problem_templates/) should include tests in the same file that the template is defined, so problem_templates/unitary_smooth_pulse_problem.jl includes the test items for UnitarySmoothPulseProblem.","category":"page"},{"location":"contribution_guide/#Reporting-Issues","page":"Contribution Guide","title":"Reporting Issues","text":"","category":"section"},{"location":"contribution_guide/","page":"Contribution Guide","title":"Contribution Guide","text":"Issue templates are available on GitHub. We are happy to take feature requests!","category":"page"},{"location":"generated/man/embedded_operators/","page":"Embedded Operators","title":"Embedded Operators","text":"EditURL = \"../../../literate/man/embedded_operators.jl\"","category":"page"},{"location":"generated/man/embedded_operators/","page":"Embedded Operators","title":"Embedded Operators","text":"CollapsedDocStrings = true","category":"page"},{"location":"generated/man/embedded_operators/#Embedded-Operators","page":"Embedded Operators","title":"Embedded Operators","text":"","category":"section"},{"location":"generated/man/embedded_operators/","page":"Embedded Operators","title":"Embedded Operators","text":"In this manual, we will discuss embedding operators in subspaces of larger quantum systems.","category":"page"},{"location":"generated/man/embedded_operators/#The-embed-and-unembed-functions","page":"Embedded Operators","title":"The embed and unembed functions","text":"","category":"section"},{"location":"generated/man/embedded_operators/","page":"Embedded Operators","title":"Embedded Operators","text":"A frequent situation in quantum optimal control is the need to embed a quantum operator in a larger Hilbert space. This is often necessary when the control Hamiltonian acts on a subspace of the full Hilbert space.","category":"page"},{"location":"generated/man/embedded_operators/","page":"Embedded Operators","title":"Embedded Operators","text":"The embed function allows to embed a quantum operator in a larger Hilbert space.","category":"page"},{"location":"generated/man/embedded_operators/","page":"Embedded Operators","title":"Embedded Operators","text":"embed","category":"page"},{"location":"generated/man/embedded_operators/#QuantumCollocation.EmbeddedOperators.embed","page":"Embedded Operators","title":"QuantumCollocation.EmbeddedOperators.embed","text":"embed(matrix::Matrix{ComplexF64}, subspace_indices::AbstractVector{Int}, levels::Int)\n\nEmbed an operator U in the subspace of a larger system mathcalX = mathcalX_textsubspace oplus mathcalX_textleakage which is composed of matrices of size textlevels times textlevels.\n\nArguments\n\nmatrix::Matrix{ComplexF64}: Operator to embed.\nsubspace_indices::AbstractVector{Int}: Indices of the subspace to embed the operator in.\nlevels::Int: Total number of levels in the system.\n\n\n\n\n\n","category":"function"},{"location":"generated/man/embedded_operators/","page":"Embedded Operators","title":"Embedded Operators","text":"The unembed function allows to unembed a quantum operator from a larger Hilbert space.","category":"page"},{"location":"generated/man/embedded_operators/","page":"Embedded Operators","title":"Embedded Operators","text":"unembed","category":"page"},{"location":"generated/man/embedded_operators/#QuantumCollocation.EmbeddedOperators.unembed","page":"Embedded Operators","title":"QuantumCollocation.EmbeddedOperators.unembed","text":"unembed(matrix::AbstractMatrix, subspace_indices::AbstractVector{Int})\n\nUnembed an operator U from a subspace of a larger system mathcalX = mathcalX_textsubspace oplus mathcalX_textleakage which is composed of matrices of size textlevels times textlevels.\n\nThis is equivalent to calling matrix[subspace_indices, subspace_indices].\n\nArguments\n\nmatrix::AbstractMatrix: Operator to unembed.\nsubspace_indices::AbstractVector{Int}: Indices of the subspace to unembed the operator from.\n\n\n\n\n\n","category":"function"},{"location":"generated/man/embedded_operators/","page":"Embedded Operators","title":"Embedded Operators","text":"For example, for a single qubit X gate embedded in a multilevel system:","category":"page"},{"location":"generated/man/embedded_operators/","page":"Embedded Operators","title":"Embedded Operators","text":"using QuantumCollocation\nusing SparseArrays # for visualization\n\n# define levels of full system\nlevels = 3\n\n# get a 2-level X gate\nX = GATES[:X]\n\n# define subspace indices as lowest two levels\nsubspace_indices = 1:2\n\n# embed the X gate in the full system\nX_embedded = embed(X, subspace_indices, levels)","category":"page"},{"location":"generated/man/embedded_operators/","page":"Embedded Operators","title":"Embedded Operators","text":"We can retrieve the original operator:","category":"page"},{"location":"generated/man/embedded_operators/","page":"Embedded Operators","title":"Embedded Operators","text":"X_unembedded = unembed(X_embedded, subspace_indices)","category":"page"},{"location":"generated/man/embedded_operators/#The-EmbeddedOperator-type","page":"Embedded Operators","title":"The EmbeddedOperator type","text":"","category":"section"},{"location":"generated/man/embedded_operators/","page":"Embedded Operators","title":"Embedded Operators","text":"The EmbeddedOperator type is a convenient way to define an operator embedded in a subspace of a larger quantum system.","category":"page"},{"location":"generated/man/embedded_operators/","page":"Embedded Operators","title":"Embedded Operators","text":"The EmbeddedOperator type is defined as follows:","category":"page"},{"location":"generated/man/embedded_operators/","page":"Embedded Operators","title":"Embedded Operators","text":"EmbeddedOperator","category":"page"},{"location":"generated/man/embedded_operators/#QuantumCollocation.EmbeddedOperators.EmbeddedOperator","page":"Embedded Operators","title":"QuantumCollocation.EmbeddedOperators.EmbeddedOperator","text":"EmbeddedOperator\n\nEmbedded operator type to represent an operator embedded in a subspace of a larger quantum system.\n\nFields\n\noperator::Matrix{ComplexF64}: Embedded operator of size prod(subsystem_levels) x prod(subsystem_levels).\nsubspace_indices::Vector{Int}: Indices of the subspace the operator is embedded in.\nsubsystem_levels::Vector{Int}: Levels of the subsystems in the composite system.\n\n\n\n\n\n","category":"type"},{"location":"generated/man/embedded_operators/","page":"Embedded Operators","title":"Embedded Operators","text":"And can be constructed using the following method:","category":"page"},{"location":"generated/man/embedded_operators/","page":"Embedded Operators","title":"Embedded Operators","text":"EmbeddedOperator(op::Matrix{<:Number}, subspace_indices::AbstractVector{Int}, subsystem_levels::AbstractVector{Int})","category":"page"},{"location":"generated/man/embedded_operators/#QuantumCollocation.EmbeddedOperators.EmbeddedOperator-Tuple{Matrix{<:Number}, AbstractVector{Int64}, AbstractVector{Int64}}","page":"Embedded Operators","title":"QuantumCollocation.EmbeddedOperators.EmbeddedOperator","text":"EmbeddedOperator(op::Matrix{<:Number}, subspace_indices::AbstractVector{Int}, subsystem_levels::AbstractVector{Int})\n\nCreate an embedded operator. The operator op is embedded in the subspace defined by subspace_indices in subsystem_levels.\n\nArguments\n\nop::Matrix{<:Number}: Operator to embed.\nsubspace_indices::AbstractVector{Int}: Indices of the subspace to embed the operator in. e.g. get_subspace_indices([1:2, 1:2], [3, 3]).\nsubsystem_levels::AbstractVector{Int}: Levels of the subsystems in the composite system. e.g. [3, 3] for two 3-level systems.\n\n\n\n\n\n","category":"method"},{"location":"generated/man/embedded_operators/","page":"Embedded Operators","title":"Embedded Operators","text":"For example, for an X gate on the first qubit of two qubit, 3-level system:","category":"page"},{"location":"generated/man/embedded_operators/","page":"Embedded Operators","title":"Embedded Operators","text":"# define the target operator X ⊗ I\ngate = GATES[:X] ⊗ GATES[:I]\n\n# define the subsystem levels\nsubsystem_levels = [3, 3]\n\n# define the subspace indices\nsubspace_indices = get_subspace_indices([1:2, 1:2], subsystem_levels)\n\n# create the embedded operator\nop = EmbeddedOperator(gate, subspace_indices, subsystem_levels)\n\n# show the full operator\nop.operator .|> abs |> sparse","category":"page"},{"location":"generated/man/embedded_operators/","page":"Embedded Operators","title":"Embedded Operators","text":"We can get the original operator back:","category":"page"},{"location":"generated/man/embedded_operators/","page":"Embedded Operators","title":"Embedded Operators","text":"gate_unembeded = unembed(op)\n\ngate_unembeded .|> abs |> sparse","category":"page"},{"location":"generated/man/embedded_operators/#The-get_subspace_indices-function","page":"Embedded Operators","title":"The get_subspace_indices function","text":"","category":"section"},{"location":"generated/man/embedded_operators/","page":"Embedded Operators","title":"Embedded Operators","text":"The get_subspace_indices function is a convenient way to get the indices of a subspace in a larger quantum system.","category":"page"},{"location":"generated/man/embedded_operators/#Simple-quantum-systems","page":"Embedded Operators","title":"Simple quantum systems","text":"","category":"section"},{"location":"generated/man/embedded_operators/","page":"Embedded Operators","title":"Embedded Operators","text":"For simple (non-composite) quantum systems, such as a single multilevel qubit, we provode the following method:","category":"page"},{"location":"generated/man/embedded_operators/","page":"Embedded Operators","title":"Embedded Operators","text":"get_subspace_indices(subspace::AbstractVector{Int}, levels::Int)","category":"page"},{"location":"generated/man/embedded_operators/#QuantumCollocation.EmbeddedOperators.get_subspace_indices-Tuple{AbstractVector{Int64}, Int64}","page":"Embedded Operators","title":"QuantumCollocation.EmbeddedOperators.get_subspace_indices","text":"get_subspace_indices(subspace::AbstractVector{Int}, levels::Int)\n\nGet the indices for the subspace of simple, non-composite, quantum system. For example:\n\nget_subspace_indices([1, 2], 3) == [1, 2]\n\nArguments\n\nsubspace::AbstractVector{Int}: Subspace to get indices for. e.g. [1, 2].\nlevels::Int: Levels of the subsystem. e.g. 3.\n\n\n\n\n\n","category":"method"},{"location":"generated/man/embedded_operators/","page":"Embedded Operators","title":"Embedded Operators","text":"# get the indices of the lowest two levels of a 3-level system\nsubspace_indices = get_subspace_indices(1:2, 3)","category":"page"},{"location":"generated/man/embedded_operators/#Comosite-quantum-systems","page":"Embedded Operators","title":"Comosite quantum systems","text":"","category":"section"},{"location":"generated/man/embedded_operators/","page":"Embedded Operators","title":"Embedded Operators","text":"For composite quantum systems, such as a two qubit system, we provide the following methods.","category":"page"},{"location":"generated/man/embedded_operators/","page":"Embedded Operators","title":"Embedded Operators","text":"Targeting subspaces in a composite quantum system, with general subsystem levels:","category":"page"},{"location":"generated/man/embedded_operators/","page":"Embedded Operators","title":"Embedded Operators","text":"get_subspace_indices(subspaces::Vector{<:AbstractVector{Int}}, subsystem_levels::AbstractVector{Int})","category":"page"},{"location":"generated/man/embedded_operators/#QuantumCollocation.EmbeddedOperators.get_subspace_indices-Tuple{Vector{<:AbstractVector{Int64}}, AbstractVector{Int64}}","page":"Embedded Operators","title":"QuantumCollocation.EmbeddedOperators.get_subspace_indices","text":"get_subspace_indices(subspaces::Vector{<:AbstractVector{Int}}, subsystem_levels::AbstractVector{Int})\n\nGet the indices for the subspace of composite quantum system.\n\nExample: for the two-qubit subspace of two 3-level systems:\n\nsubspaces = [1:2, 1:2]\nsubsystem_levels = [3, 3]\nget_subspace_indices(subspaces, subsystem_levels) == [1, 2, 4, 5]\n\nArguments\n\nsubspaces::Vector{<:AbstractVector{Int}}: Subspaces to get indices for. e.g. [1:2, 1:2].\nsubsystem_levels::AbstractVector{Int}: Levels of the subsystems in the composite system. e.g. [3, 3]. Each element corresponds to a subsystem.\n\n\n\n\n\n","category":"method"},{"location":"generated/man/embedded_operators/","page":"Embedded Operators","title":"Embedded Operators","text":"# get the subspace indices for a three level qubit coupled to a 9-level cavity\nget_subspace_indices([1:2, 1:2], [3, 9])","category":"page"},{"location":"generated/man/embedded_operators/","page":"Embedded Operators","title":"Embedded Operators","text":"Targeting subspaces in a composite quantum system, with all subsystems having the same number of levels:","category":"page"},{"location":"generated/man/embedded_operators/","page":"Embedded Operators","title":"Embedded Operators","text":"get_subspace_indices(levels::AbstractVector{Int}; subspace=1:2, kwargs...)","category":"page"},{"location":"generated/man/embedded_operators/#QuantumCollocation.EmbeddedOperators.get_subspace_indices-Tuple{AbstractVector{Int64}}","page":"Embedded Operators","title":"QuantumCollocation.EmbeddedOperators.get_subspace_indices","text":"get_subspace_indices(levels::AbstractVector{Int}; subspace=1:2, kwargs...)\n\nGet the indices for the subspace of composite quantum system. This is a convenience function that allows to specify the subspace as a range that is constant for every subsystem, which defaults to 1:2, that is qubit systems.\n\nArguments\n\nlevels::AbstractVector{Int}: Levels of the subsystems in the composite system. e.g. [3, 3].\n\nKeyword Arguments\n\nsubspace::AbstractVector{Int}: Subspace to get indices for. e.g. 1:2.\n\n\n\n\n\n","category":"method"},{"location":"generated/man/embedded_operators/","page":"Embedded Operators","title":"Embedded Operators","text":"# get the subspace indices for a two qubit system with 3 levels each\nget_subspace_indices([3, 3])","category":"page"},{"location":"generated/man/embedded_operators/","page":"Embedded Operators","title":"Embedded Operators","text":"","category":"page"},{"location":"generated/man/embedded_operators/","page":"Embedded Operators","title":"Embedded Operators","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/man/utils/","page":"Utilities","title":"Utilities","text":"EditURL = \"../../../literate/man/utils.jl\"","category":"page"},{"location":"generated/man/utils/#Utilities","page":"Utilities","title":"Utilities","text":"","category":"section"},{"location":"generated/man/utils/#Gates","page":"Utilities","title":"Gates","text":"","category":"section"},{"location":"generated/man/utils/#States","page":"Utilities","title":"States","text":"","category":"section"},{"location":"generated/man/utils/#Operators","page":"Utilities","title":"Operators","text":"","category":"section"},{"location":"generated/man/utils/#Isomorphisms","page":"Utilities","title":"Isomorphisms","text":"","category":"section"},{"location":"generated/man/utils/#Measurements","page":"Utilities","title":"Measurements","text":"","category":"section"},{"location":"generated/man/utils/#Subspaces","page":"Utilities","title":"Subspaces","text":"","category":"section"},{"location":"generated/man/utils/","page":"Utilities","title":"Utilities","text":"","category":"page"},{"location":"generated/man/utils/","page":"Utilities","title":"Utilities","text":"This page was generated using Literate.jl.","category":"page"},{"location":"release_notes/#Release-Notes","page":"Release Notes","title":"Release Notes","text":"","category":"section"},{"location":"release_notes/","page":"Release Notes","title":"Release Notes","text":"The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.","category":"page"},{"location":"release_notes/#[v0.2.0]-2024-02-22","page":"Release Notes","title":"[v0.2.0] - 2024-02-22","text":"","category":"section"},{"location":"release_notes/#Added","page":"Release Notes","title":"Added","text":"","category":"section"},{"location":"release_notes/","page":"Release Notes","title":"Release Notes","text":"EmbeddedOperators to handle subspace gate optimization and leakage suppression\nPlotting methods for unitary populations","category":"page"},{"location":"release_notes/#Changed","page":"Release Notes","title":"Changed","text":"","category":"section"},{"location":"release_notes/","page":"Release Notes","title":"Release Notes","text":"New quantum systems interface\nTransmon system template\nRestructured the code base for easier quantum system and problem template development","category":"page"},{"location":"release_notes/#Removed","page":"Release Notes","title":"Removed","text":"","category":"section"},{"location":"release_notes/","page":"Release Notes","title":"Release Notes","text":"Stale examples ","category":"page"},{"location":"release_notes/#Fixed","page":"Release Notes","title":"Fixed","text":"","category":"section"},{"location":"release_notes/","page":"Release Notes","title":"Release Notes","text":"Robustness improvements objective test fixes ","category":"page"},{"location":"generated/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"EditURL = \"../../literate/quickstart.jl\"","category":"page"},{"location":"generated/quickstart/#Quickstart-Guide","page":"Quickstart Guide","title":"Quickstart Guide","text":"","category":"section"},{"location":"generated/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"To set up and solve a quantum optimal control problems we provide high level problem templates to quickly get started. For unitary gate problems, where we want to realize a gate U_textgoal, with a system Hamiltonian of the form,","category":"page"},{"location":"generated/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"H(t) = H_0 + sum_i a^i(t) H_i","category":"page"},{"location":"generated/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"there is the UnitarySmoothPulseProblem constructor which only requires","category":"page"},{"location":"generated/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"the drift Hamiltonian, H_0\nthe drive Hamiltonians, qtyH_i\nthe target unitary, U_textgoal\nthe number of timesteps, T\nthe (initial) time step size, Delta t","category":"page"},{"location":"generated/quickstart/#Basic-Usage","page":"Quickstart Guide","title":"Basic Usage","text":"","category":"section"},{"location":"generated/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"For example, to create a problem for a single qubit X gate (with a bound on the drive of a^i  a_textbound), i.e., with system hamiltonian","category":"page"},{"location":"generated/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"H(t) = fracomega2 sigma_z + a^1(t) sigma_x + a^2(t) sigma_y","category":"page"},{"location":"generated/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"we can do the following:","category":"page"},{"location":"generated/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"using NamedTrajectories\nusing QuantumCollocation\n\n# set time parameters\nT = 100\nΔt = 0.1\n\n# use the exported gate dictionary to get the gates we need\nσx = GATES[:X]\nσy = GATES[:Y]\nσz = GATES[:Z]\n\n# define drift and drive Hamiltonians\nH_drift = 0.5 * σz\nH_drives = [σx, σy]\n\n# define target unitary\nU_goal = σx\n\n# set bound on the drive\na_bound = 1.0\n\n# build the problem\nprob = UnitarySmoothPulseProblem(\n    H_drift,\n    H_drives,\n    U_goal,\n    T,\n    Δt;\n    a_bound=a_bound,\n)\n\n# solve the problem\nsolve!(prob; max_iter=30)","category":"page"},{"location":"generated/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"The above output comes from the Ipopt.jl solver. To see the final fidelity we can use the unitary_fidelity function exported by QuantumCollocation.jl.","category":"page"},{"location":"generated/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"println(\"Final fidelity: \", unitary_fidelity(prob))","category":"page"},{"location":"generated/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"We can also easily plot the solutions using the plot function exported by NamedTrajectories.jl.","category":"page"},{"location":"generated/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"plot(prob.trajectory, [:Ũ⃗, :a])","category":"page"},{"location":"generated/quickstart/#Minimum-Time-Problems","page":"Quickstart Guide","title":"Minimum Time Problems","text":"","category":"section"},{"location":"generated/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"We can also easily set up and solve a minimum time problem, where we enforce a constraint on the final fidelity:","category":"page"},{"location":"generated/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"mathcalF(U_T U_textgoal) geq mathcalF_textmin","category":"page"},{"location":"generated/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"Using the problem we just solved we can do the following:","category":"page"},{"location":"generated/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"# final fidelity constraint\nfinal_fidelity = 0.99\n\n# weight on the minimum time objective\nD = 10.0\n\nprob_min_time = UnitaryMinimumTimeProblem(\n    prob;\n    final_fidelity=final_fidelity,\n    D=D\n)\n\nsolve!(prob_min_time; max_iter=30)","category":"page"},{"location":"generated/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"We can see that the final fidelity is indeed greater than the minimum fidelity we set.","category":"page"},{"location":"generated/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"println(\"Final fidelity:    \", unitary_fidelity(prob_min_time))","category":"page"},{"location":"generated/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"and that the duration of the pulse has decreased.","category":"page"},{"location":"generated/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"initial_dur = get_times(prob.trajectory)[end]\nmin_time_dur = get_times(prob_min_time.trajectory)[end]\n\nprintln(\"Initial duration:  \", initial_dur)\nprintln(\"Minimum duration:  \", min_time_dur)\nprintln(\"Duration decrease: \", initial_dur - min_time_dur)","category":"page"},{"location":"generated/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"We can also plot the solutions for the minimum time problem.","category":"page"},{"location":"generated/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"plot(prob_min_time.trajectory, [:Ũ⃗, :a])","category":"page"},{"location":"generated/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"","category":"page"},{"location":"generated/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"This page was generated using Literate.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = QuantumCollocation","category":"page"},{"location":"#QuantumCollocation.jl","page":"Home","title":"QuantumCollocation.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Direct Collocation for Quantum Optimal Control (arXiv)","category":"page"},{"location":"#Motivation","page":"Home","title":"Motivation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"In quantum optimal control, we are interested in finding a pulse sequence a_1T-1 to drive a quantum system and realize a target gate U_textgoal. We formulate this problem as a nonlinear program (NLP) of the form","category":"page"},{"location":"","page":"Home","title":"Home","text":"beginaligned\nundersetU_1T a_1T-1 Delta t_1T-1textminimize  quad ell(U_T U_textgoal)\ntext subject to   quad f(U_t+1 U_t a_t Delta t_t) = 0 \nendaligned","category":"page"},{"location":"","page":"Home","title":"Home","text":"where f defines the dynamics, implicitly, as constraints on the states and controls, U_1T and a_1T-1, which are both free variables in the solver. This optimization framework is called direct collocation.  For details of our implementation please see our award-winning paper Direct Collocation for Quantum Optimal Control.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The gist of the method is that the dynamics are given by the solution to the Schrodinger equation, which results in unitary evolution given by exp(-i Delta t H(a_t)), where H(a_t) is the Hamiltonian of the system and Delta t is the timestep.  We can approximate this evolution using Pade approximants:","category":"page"},{"location":"","page":"Home","title":"Home","text":"beginaligned\nf(U_t+1 U_t a_t Delta t_t) = U_t+1 - exp(-i Delta t_t H(a_t)) U_t \napprox U_t+1 - B^-1(a_t Delta t_t) F(a_t Delta t_t) U_t \n= B(a_t Delta t_t) U_t+1 - F(a_t Delta t_t) U_t \nendaligned","category":"page"},{"location":"","page":"Home","title":"Home","text":"where B(a_t) and F(a_t) are the backward and forward Pade operators and are just polynomials in H(a_t). ","category":"page"},{"location":"","page":"Home","title":"Home","text":"This implementation is possible because direct collocation allows for the dynamics to be implicit. Since numerically calculating matrix exponentials inherently requires an approximation – the Padé approximant is commonly used – utilizing this formulation significantly improves performance, as, at least here, no matrix inversion is required.","category":"page"},{"location":"#Index","page":"Home","title":"Index","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"generated/man/problem_templates/","page":"Problem Templates","title":"Problem Templates","text":"EditURL = \"../../../literate/man/problem_templates.jl\"","category":"page"},{"location":"generated/man/problem_templates/#Problem-Templates","page":"Problem Templates","title":"Problem Templates","text":"","category":"section"},{"location":"generated/man/problem_templates/","page":"Problem Templates","title":"Problem Templates","text":"We provide a number of problem templates for making it simple and easy to set up and solve certain types of quantum optimal control problems. These templates all construct a QuantumControlProblem object.  The problem templates are:","category":"page"},{"location":"generated/man/problem_templates/#Unitary-Smooth-Pulse-Problem","page":"Problem Templates","title":"Unitary Smooth Pulse Problem","text":"","category":"section"},{"location":"generated/man/problem_templates/","page":"Problem Templates","title":"Problem Templates","text":"UnitarySmoothPulseProblem","category":"page"},{"location":"generated/man/problem_templates/#QuantumCollocation.ProblemTemplates.UnitarySmoothPulseProblem","page":"Problem Templates","title":"QuantumCollocation.ProblemTemplates.UnitarySmoothPulseProblem","text":"UnitarySmoothPulseProblem(system, operator, T, Δt; kwargs...)\n\nConstruct a QuantumControlProblem for a free-time unitary gate problem with smooth control pulses enforced by constraining the second derivative of the pulse trajectory, i.e.,\n\nbeginaligned\nundersetvectildeU a dota ddota Delta ttextminimize  quad\nQ cdot ellqty(vectildeU_T vectildeU_textgoal) + frac12 sum_t qty(R_a a_t^2 + R_dota dota_t^2 + R_ddota ddota_t^2) \ntext subject to   quad vbP^(n)qty(vectildeU_t+1 vectildeU_t a_t Delta t_t) = 0 \n a_t+1 - a_t - dota_t Delta t_t = 0 \n quad dota_t+1 - dota_t - ddota_t Delta t_t = 0 \n quad a_t leq a_textbound \n quad ddota_t leq ddota_textbound \n quad Delta t_textmin leq Delta t_t leq Delta t_textmax \nendaligned\n\nwhere, for U in SU(N),\n\nellqty(vectildeU_T vectildeU_textgoal) =\nabs1 - frac1N abs tr qty(U_textgoal U_T) \n\nis the infidelity objective function, Q is a weight, R_a, R_dota, and R_ddota are weights on the regularization terms, and vbP^(n) is the nth-order Pade integrator.\n\nArguments\n\nH_drift::AbstractMatrix{<:Number}: the drift hamiltonian\nH_drives::Vector{<:AbstractMatrix{<:Number}}: the control hamiltonians\n\nor\n\nsystem::QuantumSystem: the system to be controlled\n\nwith\n\noperator::OperatorType: the target unitary, either in the form of an EmbeddedOperator or a `Matrix{ComplexF64}\nT::Int: the number of timesteps\nΔt::Float64: the (initial) time step size\n\nKeyword Arguments\n\nipopt_options::IpoptOptions=IpoptOptions(): the options for the Ipopt solver\npiccolo_options::PiccoloOptions=PiccoloOptions(): the options for the Piccolo solver\nstate_name::Symbol = :Ũ⃗: the name of the state\ncontrol_name::Symbol = :a: the name of the control\ntimestep_name::Symbol = :Δt: the name of the timestep\ninit_trajectory::Union{NamedTrajectory, Nothing}=nothing: an initial trajectory to use\na_bound::Float64=1.0: the bound on the control pulse\na_bounds::Vector{Float64}=fill(a_bound, length(system.G_drives)): the bounds on the control pulses, one for each drive\na_guess::Union{Matrix{Float64}, Nothing}=nothing: an initial guess for the control pulses\nda_bound::Float64=Inf: the bound on the control pulse derivative\nda_bounds::Vector{Float64}=fill(da_bound, length(system.G_drives)): the bounds on the control pulse derivatives, one for each drive\ndda_bound::Float64=1.0: the bound on the control pulse second derivative\ndda_bounds::Vector{Float64}=fill(dda_bound, length(system.G_drives)): the bounds on the control pulse second derivatives, one for each drive\nΔt_min::Float64=Δt isa Float64 ? 0.5 * Δt : 0.5 * mean(Δt): the minimum time step size\nΔt_max::Float64=Δt isa Float64 ? 1.5 * Δt : 1.5 * mean(Δt): the maximum time step size\ndrive_derivative_σ::Float64=0.01: the standard deviation of the initial guess for the control pulse derivatives\nQ::Float64=100.0: the weight on the infidelity objective\nR=1e-2: the weight on the regularization terms\nR_a::Union{Float64, Vector{Float64}}=R: the weight on the regularization term for the control pulses\nR_da::Union{Float64, Vector{Float64}}=R: the weight on the regularization term for the control pulse derivatives\nR_dda::Union{Float64, Vector{Float64}}=R: the weight on the regularization term for the control pulse second derivatives\nglobal_data::Union{NamedTuple, Nothing}=nothing: global data for the problem\nconstraints::Vector{<:AbstractConstraint}=AbstractConstraint[]: the constraints to enforce\n\n\n\n\n\nUnitarySmoothPulseProblem(\n    H_drift::AbstractMatrix{<:Number},\n    H_drives::Vector{<:AbstractMatrix{<:Number}},\n    operator,\n    T,\n    Δt;\n    kwargs...\n)\n\nConstructor for a UnitarySmoothPulseProblem from a drift Hamiltonian and a set of control Hamiltonians.\n\n\n\n\n\n","category":"function"},{"location":"generated/man/problem_templates/#Unitary-Minimum-Time-Problem","page":"Problem Templates","title":"Unitary Minimum Time Problem","text":"","category":"section"},{"location":"generated/man/problem_templates/","page":"Problem Templates","title":"Problem Templates","text":"UnitaryMinimumTimeProblem","category":"page"},{"location":"generated/man/problem_templates/#QuantumCollocation.ProblemTemplates.UnitaryMinimumTimeProblem","page":"Problem Templates","title":"QuantumCollocation.ProblemTemplates.UnitaryMinimumTimeProblem","text":"UnitaryMinimumTimeProblem(\n    trajectory::NamedTrajectory,\n    system::AbstractQuantumSystem,\n    objective::Objective,\n    integrators::Vector{<:AbstractIntegrator},\n    constraints::Vector{<:AbstractConstraint};\n    kwargs...\n)\n\nUnitaryMinimumTimeProblem(\n    prob::QuantumControlProblem;\n    kwargs...\n)\n\nCreate a minimum-time problem for unitary control.\n\nbeginaligned\nundersetvectildeU a dota ddota Delta ttextminimize  quad\nJ(vectildeU a dota ddota) + D sum_t Delta t_t \ntext subject to   quad vbP^(n)qty(vectildeU_t+1 vectildeU_t a_t Delta t_t) = 0 \n c(vectildeU a dota ddota) = 0 \n quad Delta t_textmin leq Delta t_t leq Delta t_textmax \nendaligned\n\nArguments\n\ntrajectory::NamedTrajectory: The initial trajectory.\nsystem::AbstractQuantumSystem: The quantum system.\nobjective::Objective: The objective function (additional to the minimum-time objective).\nintegrators::Vector{<:AbstractIntegrator}: The integrators.\nconstraints::Vector{<:AbstractConstraint}: The constraints.\n\nKeyword Arguments\n\nunitary_name::Symbol=:Ũ⃗: The symbol for the unitary control.\nfinal_fidelity::Float64=0.99: The final fidelity.\nD=1.0: The weight for the minimum-time objective.\nipopt_options::IpoptOptions=IpoptOptions(): The options for the Ipopt solver.\npiccolo_options::PiccoloOptions=PiccoloOptions(): The options for the Piccolo solver.\nkwargs...: Additional keyword arguments to pass to QuantumControlProblem.\n\n\n\n\n\n","category":"function"},{"location":"generated/man/problem_templates/","page":"Problem Templates","title":"Problem Templates","text":"","category":"page"},{"location":"generated/man/problem_templates/","page":"Problem Templates","title":"Problem Templates","text":"This page was generated using Literate.jl.","category":"page"}]
}
