var documenterSearchIndex = {"docs":
[{"location":"lib/#Library","page":"Library","title":"Library","text":"","category":"section"},{"location":"lib/#Problem-Templates","page":"Library","title":"Problem Templates","text":"","category":"section"},{"location":"lib/#Quantum-Objectives","page":"Library","title":"Quantum Objectives","text":"","category":"section"},{"location":"lib/#Quantum-Constraints","page":"Library","title":"Quantum Constraints","text":"","category":"section"},{"location":"lib/#Quantum-Integrators","page":"Library","title":"Quantum Integrators","text":"","category":"section"},{"location":"lib/#Options","page":"Library","title":"Options","text":"","category":"section"},{"location":"lib/#Control-Problems","page":"Library","title":"Control Problems","text":"","category":"section"},{"location":"lib/#QuantumCollocation.ProblemTemplates.MinimumTimeProblem-Union{Tuple{QuantumControlProblem{QT}}, Tuple{QT}} where QT<:PiccoloQuantumObjects.QuantumTrajectories.AbstractQuantumTrajectory","page":"Library","title":"QuantumCollocation.ProblemTemplates.MinimumTimeProblem","text":"MinimumTimeProblem(qcp::QuantumControlProblem; kwargs...)\n\nConvert an existing quantum control problem to minimum-time optimization.\n\nIMPORTANT: This function requires an existing QuantumControlProblem (e.g., from SmoothPulseProblem). It cannot be created directly from a quantum trajectory. The workflow is:\n\nCreate base problem with SmoothPulseProblem (or similar)\nSolve base problem to get feasible solution\nConvert to minimum-time with MinimumTimeProblem\n\nThis ensures the problem starts from a good initialization and maintains solution quality through the final fidelity constraint.\n\nType Dispatch\n\nAutomatically handles different quantum trajectory types through the type parameter:\n\nQuantumControlProblem{UnitaryTrajectory} → Uses FinalUnitaryFidelityConstraint\nQuantumControlProblem{KetTrajectory} → Uses FinalKetFidelityConstraint\nQuantumControlProblem{DensityTrajectory} → Not yet implemented\n\nThe optimization problem is:\n\nbeginaligned\nundersetvectildeq u Delta ttextminimize  quad\nJ_textoriginal(vectildeq u) + D sum_t Delta t_t \ntext subject to   quad textoriginal dynamics  constraints \n F_textfinal geq F_textthreshold \n quad Delta t_textmin leq Delta t_t leq Delta t_textmax \nendaligned\n\nwhere q represents the quantum state (unitary, ket, or density matrix).\n\nArguments\n\nqcp::QuantumControlProblem: Existing quantum control problem to convert\n\nKeyword Arguments\n\nfinal_fidelity::Float64=0.99: Minimum fidelity constraint at final time\nD::Float64=100.0: Weight on minimum-time objective ∑Δt\npiccolo_options::PiccoloOptions=PiccoloOptions(): Piccolo solver options\n\nReturns\n\nQuantumControlProblem: New problem with minimum-time objective and fidelity constraint\n\nExamples\n\n# Standard workflow\nsys = QuantumSystem(H_drift, H_drives, drive_bounds)\npulse = ZeroOrderPulse(0.1 * randn(n_drives, N), collect(range(0.0, T, length=N)))\nqtraj = UnitaryTrajectory(sys, pulse, U_goal)\n\n# Step 1: Create and solve base smooth pulse problem (with Δt_bounds for free time)\nqcp_smooth = SmoothPulseProblem(qtraj, N; Q=100.0, R=1e-2, Δt_bounds=(0.01, 0.5))\nsolve!(qcp_smooth; max_iter=100)\n\n# Step 2: Convert to minimum-time\nqcp_mintime = MinimumTimeProblem(qcp_smooth; final_fidelity=0.99, D=100.0)\nsolve!(qcp_mintime; max_iter=100)\n\n# Compare durations\nduration_before = sum(get_timesteps(get_trajectory(qcp_smooth)))\nduration_after = sum(get_timesteps(get_trajectory(qcp_mintime)))\n@assert duration_after <= duration_before\n\n# Nested transformations also work\nqcp_final = MinimumTimeProblem(\n    RobustnessProblem(qcp_smooth);  # Future feature\n    final_fidelity=0.95\n)\n\nConvenience Constructors\n\nYou can also update the goal when creating minimum-time problem:\n\n# Different goal for minimum-time optimization\nqcp_mintime = MinimumTimeProblem(qcp_smooth; goal=U_goal_new, final_fidelity=0.98)\n\n\n\n\n\n","category":"method"},{"location":"lib/#QuantumCollocation.ProblemTemplates.SamplingProblem-Tuple{QuantumControlProblem, Vector{<:PiccoloQuantumObjects.QuantumSystems.AbstractQuantumSystem}}","page":"Library","title":"QuantumCollocation.ProblemTemplates.SamplingProblem","text":"SamplingProblem(qcp::QuantumControlProblem, systems::Vector{<:AbstractQuantumSystem}; kwargs...)\n\nConstruct a SamplingProblem from an existing QuantumControlProblem and a list of systems.\n\nThis creates a robust optimization problem where the controls are shared across all systems, but each system evolves according to its own dynamics. The objective is the weighted sum of fidelity objectives for each system.\n\nArguments\n\nqcp::QuantumControlProblem: The base problem (defines nominal trajectory, objective, etc.)\nsystems::Vector{<:AbstractQuantumSystem}: List of systems to optimize over\n\nKeyword Arguments\n\nweights::Vector{Float64}=fill(1.0, length(systems)): Weights for each system\nQ::Float64=100.0: Weight on infidelity objective (explicit, not extracted from base problem)\npiccolo_options::PiccoloOptions=PiccoloOptions(): Options for the solver\n\nReturns\n\nQuantumControlProblem{SamplingTrajectory}: A new problem with the sampling trajectory\n\n\n\n\n\n","category":"method"},{"location":"lib/#QuantumCollocation.ProblemTemplates.SmoothPulseProblem-Tuple{PiccoloQuantumObjects.QuantumTrajectories.AbstractQuantumTrajectory{<:PiccoloQuantumObjects.Pulses.ZeroOrderPulse}, Int64}","page":"Library","title":"QuantumCollocation.ProblemTemplates.SmoothPulseProblem","text":"SmoothPulseProblem(qtraj::AbstractQuantumTrajectory{<:ZeroOrderPulse}, N::Int; kwargs...)\n\nConstruct a QuantumControlProblem for smooth pulse optimization with piecewise constant controls.\n\nNote: This problem template is for ZeroOrderPulse only. For spline-based pulses (LinearSplinePulse, CubicSplinePulse), use SplinePulseProblem instead.\n\nThe problem adds discrete derivative variables (du, ddu) that:\n\nRegularize control changes between timesteps\nEnforce smoothness via DerivativeIntegrator constraints\n\nArguments\n\nqtraj::AbstractQuantumTrajectory{<:ZeroOrderPulse}: Quantum trajectory with piecewise constant pulse\nN::Int: Number of timesteps for discretization\n\nKeyword Arguments\n\nintegrator::Union{Nothing, AbstractIntegrator, Vector{<:AbstractIntegrator}}=nothing: Optional custom integrator(s)\ndu_bound::Float64=Inf: Bound on discrete first derivative (controls jump rate)\nddu_bound::Float64=1.0: Bound on discrete second derivative (controls acceleration)\nQ::Float64=100.0: Weight on infidelity/objective\nR::Float64=1e-2: Weight on regularization terms (u, u̇, ü)\nR_u::Union{Float64, Vector{Float64}}=R: Weight on control regularization\nR_du::Union{Float64, Vector{Float64}}=R: Weight on first derivative regularization\nR_ddu::Union{Float64, Vector{Float64}}=R: Weight on second derivative regularization\nconstraints::Vector{<:AbstractConstraint}=AbstractConstraint[]: Additional constraints\npiccolo_options::PiccoloOptions=PiccoloOptions(): Piccolo solver options\n\nReturns\n\nQuantumControlProblem: Wrapper containing quantum trajectory and optimization problem\n\nExamples\n\n# Unitary gate synthesis with piecewise constant pulse\nsys = QuantumSystem(H_drift, H_drives, drive_bounds)\npulse = ZeroOrderPulse(0.1 * randn(n_drives, N), collect(range(0.0, T, length=N)))\nqtraj = UnitaryTrajectory(sys, pulse, U_goal)\nqcp = SmoothPulseProblem(qtraj, N; Q=100.0, R=1e-2)\nsolve!(qcp; max_iter=100)\n\n# Quantum state transfer\npulse = ZeroOrderPulse(0.1 * randn(n_drives, N), collect(range(0.0, T, length=N)))\nqtraj = KetTrajectory(sys, pulse, ψ_init, ψ_goal)\nqcp = SmoothPulseProblem(qtraj, N; Q=50.0, R=1e-3)\nsolve!(qcp)\n\nSee also: SplinePulseProblem for spline-based pulses.\n\n\n\n\n\n","category":"method"},{"location":"lib/#QuantumCollocation.ProblemTemplates.SmoothPulseProblem-Tuple{PiccoloQuantumObjects.QuantumTrajectories.MultiKetTrajectory{<:PiccoloQuantumObjects.Pulses.ZeroOrderPulse}, Int64}","page":"Library","title":"QuantumCollocation.ProblemTemplates.SmoothPulseProblem","text":"SmoothPulseProblem(qtraj::MultiKetTrajectory{<:ZeroOrderPulse}, N::Int; kwargs...)\n\nConstruct a QuantumControlProblem for smooth pulse optimization over an ensemble of ket state transfers with piecewise constant controls.\n\nThis handles the case where you want to optimize a single pulse that achieves multiple  state transfers simultaneously (e.g., |0⟩→|1⟩ and |1⟩→|0⟩ for an X gate via state transfer).\n\nNote: This problem template is for ZeroOrderPulse only. For spline-based pulses, use SplinePulseProblem instead.\n\nArguments\n\nqtraj::MultiKetTrajectory{<:ZeroOrderPulse}: Ensemble of ket state transfers with piecewise constant pulse\nN::Int: Number of timesteps for the discretization\n\nKeyword Arguments\n\nintegrator::Union{Nothing, AbstractIntegrator, Vector{<:AbstractIntegrator}}=nothing: Optional custom integrator(s)\ndu_bound::Float64=Inf: Bound on discrete first derivative\nddu_bound::Float64=1.0: Bound on discrete second derivative\nQ::Float64=100.0: Weight on infidelity/objective\nR::Float64=1e-2: Weight on regularization terms (u, u̇, ü)\nR_u::Union{Float64, Vector{Float64}}=R: Weight on control regularization\nR_du::Union{Float64, Vector{Float64}}=R: Weight on first derivative regularization\nR_ddu::Union{Float64, Vector{Float64}}=R: Weight on second derivative regularization\nconstraints::Vector{<:AbstractConstraint}=AbstractConstraint[]: Additional constraints\npiccolo_options::PiccoloOptions=PiccoloOptions(): Piccolo solver options\n\nReturns\n\nQuantumControlProblem{MultiKetTrajectory}: Wrapper containing ensemble trajectory and optimization problem\n\nExamples\n\n# Create ensemble for X gate via state transfer\nsys = QuantumSystem(H_drift, H_drives, drive_bounds)\npulse = ZeroOrderPulse(0.1 * randn(n_drives, N), collect(range(0.0, T, length=N)))\n\nψ0 = ComplexF64[1.0, 0.0]\nψ1 = ComplexF64[0.0, 1.0]\n\nensemble_qtraj = MultiKetTrajectory(sys, pulse, [ψ0, ψ1], [ψ1, ψ0])\nqcp = SmoothPulseProblem(ensemble_qtraj, N; Q=100.0, R=1e-2)\nsolve!(qcp; max_iter=100)\n\nSee also: SplinePulseProblem for spline-based pulses.\n\n\n\n\n\n","category":"method"},{"location":"lib/#QuantumCollocation.ProblemTemplates.SmoothPulseProblem-Union{Tuple{P}, Tuple{PiccoloQuantumObjects.QuantumTrajectories.AbstractQuantumTrajectory{P}, Int64}} where P<:PiccoloQuantumObjects.Pulses.AbstractPulse","page":"Library","title":"QuantumCollocation.ProblemTemplates.SmoothPulseProblem","text":"SmoothPulseProblem(qtraj::AbstractQuantumTrajectory, N::Int; kwargs...)\n\nFallback method that provides helpful error for non-ZeroOrderPulse types.\n\n\n\n\n\n","category":"method"},{"location":"lib/#QuantumCollocation.ProblemTemplates.SplinePulseProblem-Tuple{PiccoloQuantumObjects.QuantumTrajectories.AbstractQuantumTrajectory{<:PiccoloQuantumObjects.Pulses.AbstractSplinePulse}, Int64}","page":"Library","title":"QuantumCollocation.ProblemTemplates.SplinePulseProblem","text":"SplinePulseProblem(qtraj::AbstractQuantumTrajectory{<:AbstractSplinePulse}, N::Int; kwargs...)\n\nConstruct a QuantumControlProblem for spline-based pulse optimization.\n\nUnlike SmoothPulseProblem (which uses piecewise constant controls with discrete smoothing  variables), this problem template is designed for spline-based pulses where the derivative  variables (du) are the actual spline coefficients or slopes.\n\nPulse Type Semantics\n\nLinearSplinePulse: The du variable represents the slope at each knot point. The pulse  amplitude is linearly interpolated between knots.\n\nCubicSplinePulse (Hermite spline): The du variable is the tangent/derivative at each  knot point, which is a true degree of freedom in Hermite interpolation.\n\nMathematical Notes\n\nFor CubicSplinePulse (Hermite splines), the :du values are true degrees of freedom  representing the tangent/derivative at each knot point. These are independent of the  control values :u and are used directly by the SplineIntegrator for cubic Hermite  interpolation.\n\nUnlike SmoothPulseProblem, there is no DerivativeIntegrator constraint enforcing  a finite-difference relationship between :u and :du. The optimizer is free to adjust  both independently, subject only to regularization.\n\nArguments\n\nqtraj::AbstractQuantumTrajectory{<:AbstractSplinePulse}: Quantum trajectory with spline pulse\nN::Int: Number of timesteps for the discretization\n\nKeyword Arguments\n\nintegrator::Union{Nothing, AbstractIntegrator, Vector{<:AbstractIntegrator}}=nothing: Optional custom integrator(s). If not provided, uses BilinearIntegrator.\ndu_bound::Float64=Inf: Bound on derivative (slope) magnitude\nQ::Float64=100.0: Weight on infidelity/objective\nR::Float64=1e-2: Weight on regularization terms\nR_u::Union{Float64, Vector{Float64}}=R: Weight on control regularization\nR_du::Union{Float64, Vector{Float64}}=R: Weight on derivative regularization  \nconstraints::Vector{<:AbstractConstraint}=AbstractConstraint[]: Additional constraints\npiccolo_options::PiccoloOptions=PiccoloOptions(): Piccolo solver options\n\nReturns\n\nQuantumControlProblem{<:AbstractQuantumTrajectory}: Wrapper containing trajectory and optimization problem\n\nExamples\n\n# Linear spline pulse\nsys = QuantumSystem(H_drift, H_drives, drive_bounds)\npulse = LinearSplinePulse(0.1 * randn(n_drives, N), collect(range(0.0, T, length=N)))\nqtraj = UnitaryTrajectory(sys, pulse, U_goal)\n\nqcp = SplinePulseProblem(qtraj, N; Q=100.0, R=1e-2, du_bound=10.0)\nsolve!(qcp; max_iter=100)\n\nSee also: SmoothPulseProblem for piecewise constant pulses with discrete smoothing.\n\n\n\n\n\n","category":"method"},{"location":"lib/#QuantumCollocation.ProblemTemplates.SplinePulseProblem-Tuple{PiccoloQuantumObjects.QuantumTrajectories.MultiKetTrajectory{<:PiccoloQuantumObjects.Pulses.AbstractSplinePulse}, Int64}","page":"Library","title":"QuantumCollocation.ProblemTemplates.SplinePulseProblem","text":"SplinePulseProblem(qtraj::MultiKetTrajectory{<:AbstractSplinePulse}, N; kwargs...)\n\nCreate a spline-based trajectory optimization problem for ensemble ket state transfers.\n\nUses coherent fidelity objective (phases must align) for gate implementation.\n\nArguments\n\nqtraj::MultiKetTrajectory{<:AbstractSplinePulse}: Ensemble trajectory with spline pulse\nN::Int: Number of timesteps\n\nKeyword Arguments\n\nSame as the base SplinePulseProblem method.\n\n\n\n\n\n","category":"method"},{"location":"lib/#QuantumCollocation.ProblemTemplates.SplinePulseProblem-Union{Tuple{P}, Tuple{PiccoloQuantumObjects.QuantumTrajectories.AbstractQuantumTrajectory{P}, Int64}} where P<:PiccoloQuantumObjects.Pulses.AbstractPulse","page":"Library","title":"QuantumCollocation.ProblemTemplates.SplinePulseProblem","text":"SplinePulseProblem(qtraj::AbstractQuantumTrajectory, N::Int; kwargs...)\n\nFallback method that provides helpful error for non-spline pulse types.\n\n\n\n\n\n","category":"method"},{"location":"lib/#QuantumCollocation.ProblemTemplates._ensemble_ket_objective-Tuple{PiccoloQuantumObjects.QuantumTrajectories.MultiKetTrajectory, NamedTrajectories.StructNamedTrajectory.NamedTrajectory, Vector{Symbol}, Vector{Float64}, Vector, Float64}","page":"Library","title":"QuantumCollocation.ProblemTemplates._ensemble_ket_objective","text":"_ensemble_ket_objective(qtraj::MultiKetTrajectory, traj, state_names, weights, goals, Q)\n\nCreate a coherent fidelity objective for ensemble state transfers.\n\nFor ensemble trajectories (implementing a gate via multiple state transfers), we use coherent fidelity:     Fcoherent = |1/n ∑ᵢ ⟨ψᵢgoal|ψᵢ⟩|²\n\nThis requires all state overlaps to have aligned phases, which is essential for gate implementation (the gate should have a single global phase).\n\n\n\n\n\n","category":"method"},{"location":"lib/#QuantumCollocation.ProblemTemplates._final_fidelity_constraint-Tuple{PiccoloQuantumObjects.QuantumTrajectories.MultiKetTrajectory, Float64, NamedTrajectories.StructNamedTrajectory.NamedTrajectory}","page":"Library","title":"QuantumCollocation.ProblemTemplates._final_fidelity_constraint","text":"_final_fidelity_constraint(qtraj::MultiKetTrajectory, final_fidelity, traj)\n\nCreate a coherent fidelity constraint for an MultiKetTrajectory.\n\nUses coherent fidelity: F = |1/n ∑ᵢ ⟨ψᵢ_goal|ψᵢ⟩|²\n\nThis enforces that all state transfers have aligned global phases, which is  essential when implementing a gate via state transfer (e.g., X gate via  |0⟩→|1⟩ and |1⟩→|0⟩).\n\n\n\n\n\n","category":"method"},{"location":"lib/#QuantumCollocation.ProblemTemplates.extract_regularization-Tuple{Any, Symbol, NamedTrajectories.StructNamedTrajectory.NamedTrajectory}","page":"Library","title":"QuantumCollocation.ProblemTemplates.extract_regularization","text":"extract_regularization(objective, state_sym::Symbol, new_traj::NamedTrajectory) -> AbstractObjective\n\nExtract regularization terms (non-state-dependent objectives) from a composite objective, filtering to only include terms for variables that exist in the new trajectory.\n\nUsed by SamplingProblem to extract shared regularizers (e.g., control penalty) from the base problem while excluding regularizers for variables that don't exist in the sampling trajectory (e.g., :du, :ddu which are added by SmoothPulseProblem).\n\n\n\n\n\n","category":"method"},{"location":"lib/#QuantumCollocation.ProblemTemplates.sampling_state_objective-Tuple{PiccoloQuantumObjects.QuantumTrajectories.UnitaryTrajectory, NamedTrajectories.StructNamedTrajectory.NamedTrajectory, Symbol, Float64}","page":"Library","title":"QuantumCollocation.ProblemTemplates.sampling_state_objective","text":"sampling_state_objective(qtraj, traj, state_sym, Q)\n\nCreate the state-dependent objective for a sampling member. Dispatches on quantum trajectory type.\n\n\n\n\n\n","category":"method"},{"location":"lib/#QuantumCollocation.QuantumObjectives.CoherentKetInfidelityObjective-Tuple{Vector{<:AbstractVector{<:Complex}}, Vector{Symbol}, NamedTrajectories.StructNamedTrajectory.NamedTrajectory}","page":"Library","title":"QuantumCollocation.QuantumObjectives.CoherentKetInfidelityObjective","text":"CoherentKetInfidelityObjective(ψ_goals, ψ̃_names, traj; Q=100.0)\n\nCreate a terminal objective for coherent ket state infidelity across multiple states.\n\nCoherent fidelity is defined as:     Fcoherent = |1/n ∑ᵢ ⟨ψᵢgoal|ψᵢ⟩|²\n\nUnlike incoherent fidelity (average of individual |⟨ψᵢ_goal|ψᵢ⟩|²), coherent fidelity  requires all state overlaps to have aligned phases. This is essential when implementing a gate via multiple state transfers - the gate should have a single global phase, not independent phases per state.\n\nArguments\n\nψ_goals::Vector{<:AbstractVector{<:Complex}}: Target ket states\nψ̃_names::Vector{Symbol}: Names of isomorphic state variables in trajectory\ntraj::NamedTrajectory: The trajectory\n\nKeyword Arguments\n\nQ::Float64=100.0: Weight on the infidelity objective\n\nExample\n\n# For implementing X gate via |0⟩→|1⟩ and |1⟩→|0⟩\ngoals = [ComplexF64[0, 1], ComplexF64[1, 0]]\nnames = [:ψ̃1, :ψ̃2]\nobj = CoherentKetInfidelityObjective(goals, names, traj; Q=100.0)\n\n\n\n\n\n","category":"method"},{"location":"lib/#QuantumCollocation.QuantumObjectives.KetInfidelityObjective-Tuple{AbstractVector{<:Complex}, Symbol, NamedTrajectories.StructNamedTrajectory.NamedTrajectory}","page":"Library","title":"QuantumCollocation.QuantumObjectives.KetInfidelityObjective","text":"KetInfidelityObjective(ψ_goal, ψ̃_name, traj; Q=100.0)\n\nCreate a terminal objective for ket state infidelity with an explicit goal state.\n\nThis variant is useful for SamplingProblem and EnsembleTrajectory where the goal is shared across multiple state variables that don't have individual goals in traj.goal.\n\nArguments\n\nψ_goal::AbstractVector{<:Complex}: The target ket state (complex vector)\nψ̃_name::Symbol: Name of the isomorphic state variable in the trajectory\ntraj::NamedTrajectory: The trajectory\n\nKeyword Arguments\n\nQ::Float64=100.0: Weight on the infidelity objective\n\n\n\n\n\n","category":"method"},{"location":"lib/#QuantumCollocation.QuantumObjectives.KetInfidelityObjective-Tuple{Symbol, NamedTrajectories.StructNamedTrajectory.NamedTrajectory}","page":"Library","title":"QuantumCollocation.QuantumObjectives.KetInfidelityObjective","text":"KetInfidelityObjective(ψ̃_name, traj; Q=100.0)\n\nCreate a terminal objective for ket state infidelity, using the goal from traj.goal[ψ̃_name].\n\n\n\n\n\n","category":"method"},{"location":"lib/#QuantumCollocation.QuantumObjectives.LeakageObjective-Tuple{AbstractVector{Int64}, Symbol, NamedTrajectories.StructNamedTrajectory.NamedTrajectory}","page":"Library","title":"QuantumCollocation.QuantumObjectives.LeakageObjective","text":"LeakageObjective(indices, name, traj::NamedTrajectory)\n\nConstruct a KnotPointObjective that penalizes leakage of name at the knot points specified by times at any indices that are outside the computational subspace.\n\n\n\n\n\n","category":"method"},{"location":"lib/#QuantumCollocation.QuantumObjectives.coherent_ket_fidelity-Tuple{Any, Vector{<:AbstractVector{<:ComplexF64}}}","page":"Library","title":"QuantumCollocation.QuantumObjectives.coherent_ket_fidelity","text":"coherent_ket_fidelity(ψ̃s, ψ_goals)\n\nCompute coherent fidelity across multiple ket states:\n\nF_coherent = |1/n ∑ᵢ ⟨ψᵢ_goal|ψᵢ⟩|²\n\nThis requires all overlaps to have consistent phases (global phase alignment), which is necessary for implementing gates via state transfer.\n\nArguments\n\nψ̃s::Vector{<:AbstractVector}: List of isomorphic state vectors\nψ_goals::Vector{<:AbstractVector{<:Complex}}: List of goal states\n\n\n\n\n\n","category":"method"},{"location":"lib/#QuantumCollocation.QuantumConstraints.FinalCoherentKetFidelityConstraint-Tuple{Vector{<:AbstractVector{<:Complex}}, Vector{Symbol}, Float64, NamedTrajectories.StructNamedTrajectory.NamedTrajectory}","page":"Library","title":"QuantumCollocation.QuantumConstraints.FinalCoherentKetFidelityConstraint","text":"FinalCoherentKetFidelityConstraint(ψ_goals, ψ̃_names, final_fidelity, traj)\n\nCreate a final fidelity constraint using coherent ket fidelity across multiple states.\n\nCoherent fidelity: F = |1/n ∑ᵢ ⟨ψᵢ_goal|ψᵢ⟩|²\n\nThis constraint enforces that all state overlaps have aligned phases, which is  essential when implementing a gate via multiple state transfers (e.g., MultiKetTrajectory).\n\nArguments\n\nψ_goals::Vector{<:AbstractVector{<:Complex}}: Target ket states\nψ̃_names::Vector{Symbol}: Names of isomorphic state variables in trajectory\nfinal_fidelity::Float64: Minimum fidelity threshold (constraint: F ≥ final_fidelity)\ntraj::NamedTrajectory: The trajectory\n\nExample\n\n# For implementing X gate via |0⟩→|1⟩ and |1⟩→|0⟩\ngoals = [ComplexF64[0, 1], ComplexF64[1, 0]]\nnames = [:ψ̃1, :ψ̃2]\nconstraint = FinalCoherentKetFidelityConstraint(goals, names, 0.99, traj)\n\n\n\n\n\n","category":"method"},{"location":"lib/#QuantumCollocation.QuantumConstraints.LeakageConstraint-Tuple{Float64, AbstractVector{Int64}, Symbol, NamedTrajectories.StructNamedTrajectory.NamedTrajectory}","page":"Library","title":"QuantumCollocation.QuantumConstraints.LeakageConstraint","text":"LeakageConstraint(value, indices, name, traj::NamedTrajectory)\n\nConstruct a KnotPointConstraint that bounds leakage of name at the knot points specified by times at any indices that are outside the computational subspace.\n\n\n\n\n\n","category":"method"},{"location":"lib/#DirectTrajOpt.Integrators.BilinearIntegrator-Tuple{PiccoloQuantumObjects.QuantumTrajectories.DensityTrajectory, Int64}","page":"Library","title":"DirectTrajOpt.Integrators.BilinearIntegrator","text":"BilinearIntegrator(qtraj::DensityTrajectory, N::Int)\n\nCreate a BilinearIntegrator for density matrix evolution.\n\n\n\n\n\n","category":"method"},{"location":"lib/#DirectTrajOpt.Integrators.BilinearIntegrator-Tuple{PiccoloQuantumObjects.QuantumTrajectories.KetTrajectory, Int64}","page":"Library","title":"DirectTrajOpt.Integrators.BilinearIntegrator","text":"BilinearIntegrator(qtraj::KetTrajectory, N::Int)\n\nCreate a BilinearIntegrator for ket evolution.\n\n\n\n\n\n","category":"method"},{"location":"lib/#DirectTrajOpt.Integrators.BilinearIntegrator-Tuple{PiccoloQuantumObjects.QuantumTrajectories.MultiKetTrajectory, Int64}","page":"Library","title":"DirectTrajOpt.Integrators.BilinearIntegrator","text":"BilinearIntegrator(qtraj::MultiKetTrajectory, N::Int)\n\nCreate a vector of BilinearIntegrators for each ket in an MultiKetTrajectory.\n\n\n\n\n\n","category":"method"},{"location":"lib/#DirectTrajOpt.Integrators.BilinearIntegrator-Tuple{PiccoloQuantumObjects.QuantumTrajectories.SamplingTrajectory, Int64}","page":"Library","title":"DirectTrajOpt.Integrators.BilinearIntegrator","text":"BilinearIntegrator(qtraj::SamplingTrajectory, N::Int)\n\nCreate a vector of BilinearIntegrators for each system in a SamplingTrajectory.\n\nEach system in the sampling ensemble gets its own dynamics integrator, but they all share the same control variables.\n\nReturns\n\nVector{BilinearIntegrator}: One integrator per system in the ensemble\n\n\n\n\n\n","category":"method"},{"location":"lib/#DirectTrajOpt.Integrators.BilinearIntegrator-Tuple{PiccoloQuantumObjects.QuantumTrajectories.UnitaryTrajectory, Int64}","page":"Library","title":"DirectTrajOpt.Integrators.BilinearIntegrator","text":"BilinearIntegrator(qtraj::UnitaryTrajectory, N::Int)\n\nCreate a BilinearIntegrator for unitary evolution.\n\n\n\n\n\n","category":"method"},{"location":"lib/#QuantumCollocation.Options.PiccoloOptions","page":"Library","title":"QuantumCollocation.Options.PiccoloOptions","text":"PiccoloOptions\n\nOptions for the Piccolo quantum optimal control library.\n\nFields\n\nverbose::Bool = true: Print verbose output\ntimesteps_all_equal::Bool = true: Use equal timesteps\nrollout_integrator::Function = expv: Integrator to use for rollout\ngeodesic = true: Use the geodesic to initialize the optimization.\nzero_initial_and_final_derivative::Bool=false: Zero the initial and final control pulse derivatives.\ncomplex_control_norm_constraint_name::Union{Nothing, Symbol} = nothing: Name of the complex control norm constraint.\ncomplex_control_norm_constraint_radius::Float64 = 1.0: Radius of the complex control norm constraint.\nbound_state::Bool = false: Bound the state variables <= 1.0.\nleakage_constraint::Bool = false: Suppress leakage with constraint and cost.\nleakage_constraint_value::Float64 = 1e-2: Value for the leakage constraint.\nleakage_cost::Float64 = 1e-2: Leakage suppression parameter.\n\n\n\n\n\n","category":"type"},{"location":"lib/#QuantumCollocation.QuantumControlProblems.QuantumControlProblem","page":"Library","title":"QuantumCollocation.QuantumControlProblems.QuantumControlProblem","text":"QuantumControlProblem{QT<:AbstractQuantumTrajectory}\n\nWrapper combining quantum trajectory information with trajectory optimization problem.\n\nThis type enables:\n\nType-stable dispatch on quantum trajectory type (Unitary, Ket, Density)\nClean separation of quantum information (system, goal) from optimization details\nComposable problem transformations (e.g., SmoothPulseProblem → MinimumTimeProblem)\n\nFields\n\nqtraj::QT: Quantum trajectory containing system, goal, and quantum state information\nprob::DirectTrajOptProblem: Direct trajectory optimization problem with objective, dynamics, constraints\n\nConstruction\n\nTypically created via problem templates:\n\nqtraj = UnitaryTrajectory(sys, U_goal, N)\nqcp = SmoothPulseProblem(qtraj; Q=100.0, R=1e-2)\n\nAccessors\n\nget_trajectory(qcp): Get the NamedTrajectory\nget_system(qcp): Get the QuantumSystem\nget_goal(qcp): Get the goal state/unitary\nstate_name(qcp): Get the state variable name\ndrive_name(qcp): Get the control variable name\n\nSolving\n\nsolve!(qcp; max_iter=100, verbose=true)\n\n\n\n\n\n","category":"type"},{"location":"lib/#DirectTrajOpt.Solvers.solve!-Tuple{QuantumControlProblem}","page":"Library","title":"DirectTrajOpt.Solvers.solve!","text":"solve!(qcp::QuantumControlProblem; sync::Bool=true, kwargs...)\n\nSolve the quantum control problem by forwarding to the inner DirectTrajOptProblem.\n\nArguments\n\nsync::Bool=true: If true, call sync_trajectory! after solving to update qtraj.trajectory with physical control values. Set to false to skip synchronization (e.g., for debugging).\n\nAll other keyword arguments are passed to the DirectTrajOpt solver.\n\n\n\n\n\n","category":"method"},{"location":"lib/#PiccoloQuantumObjects.Pulses.drive_name-Tuple{QuantumControlProblem}","page":"Library","title":"PiccoloQuantumObjects.Pulses.drive_name","text":"drive_name(qcp::QuantumControlProblem)\n\nGet the control variable name from the quantum trajectory.\n\n\n\n\n\n","category":"method"},{"location":"lib/#PiccoloQuantumObjects.QuantumTrajectories.get_goal-Tuple{QuantumControlProblem}","page":"Library","title":"PiccoloQuantumObjects.QuantumTrajectories.get_goal","text":"get_goal(qcp::QuantumControlProblem)\n\nGet the goal state/operator from the quantum trajectory.\n\n\n\n\n\n","category":"method"},{"location":"lib/#PiccoloQuantumObjects.QuantumTrajectories.get_system-Tuple{QuantumControlProblem}","page":"Library","title":"PiccoloQuantumObjects.QuantumTrajectories.get_system","text":"get_system(qcp::QuantumControlProblem)\n\nGet the QuantumSystem from the quantum trajectory.\n\n\n\n\n\n","category":"method"},{"location":"lib/#PiccoloQuantumObjects.QuantumTrajectories.state_name-Tuple{QuantumControlProblem}","page":"Library","title":"PiccoloQuantumObjects.QuantumTrajectories.state_name","text":"state_name(qcp::QuantumControlProblem)\n\nGet the state variable name from the quantum trajectory.\n\n\n\n\n\n","category":"method"},{"location":"lib/#PiccoloQuantumObjects.Rollouts.fidelity-Tuple{QuantumControlProblem}","page":"Library","title":"PiccoloQuantumObjects.Rollouts.fidelity","text":"fidelity(qcp::QuantumControlProblem; kwargs...)\n\nCompute the fidelity of the quantum trajectory.\n\nThis is a convenience wrapper that forwards to fidelity(qcp.qtraj; kwargs...).\n\nExample\n\nsolve!(qcp)\nfid = fidelity(qcp)  # Equivalent to fidelity(qcp.qtraj)\n\n\n\n\n\n","category":"method"},{"location":"lib/#QuantumCollocation.QuantumControlProblems.get_trajectory-Tuple{QuantumControlProblem}","page":"Library","title":"QuantumCollocation.QuantumControlProblems.get_trajectory","text":"get_trajectory(qcp::QuantumControlProblem)\n\nGet the NamedTrajectory from the optimization problem.\n\n\n\n\n\n","category":"method"},{"location":"lib/#QuantumCollocation.QuantumControlProblems.sync_trajectory!-Tuple{QuantumControlProblem}","page":"Library","title":"QuantumCollocation.QuantumControlProblems.sync_trajectory!","text":"sync_trajectory!(qcp::QuantumControlProblem)\n\nUpdate the quantum trajectory in-place from the optimized control values.\n\nAfter optimization, this function:\n\nExtracts the optimized controls from prob.trajectory (unadapting if needed)\nCreates a new pulse with those controls via extract_pulse\nRe-solves the ODE to get the updated quantum evolution\nReplaces qtraj with the new quantum trajectory\n\nThis gives you access to the continuous-time ODE solution with the optimized controls, allowing you to:\n\nEvaluate the fidelity via fidelity(qcp.qtraj)\nSample the quantum state at any time via qcp.qtraj(t)\nGet the optimized pulse via get_pulse(qcp.qtraj)\n\nExample\n\nsolve!(qcp; max_iter=100)  # Automatically calls sync_trajectory!\nfid = fidelity(qcp.qtraj)  # Evaluate fidelity with continuous-time solution\npulse = get_pulse(qcp.qtraj)  # Get the optimized pulse\n\n\n\n\n\n","category":"method"},{"location":"generated/man/working_with_solutions/#Working-with-Solutions","page":"Working with Solutions","title":"Working with Solutions","text":"This guide covers how to solve problems, extract data from solutions, evaluate performance, and save/load results.\n\nusing QuantumCollocation\nusing PiccoloQuantumObjects\nusing NamedTrajectories","category":"section"},{"location":"generated/man/working_with_solutions/#Solving-Problems","page":"Working with Solutions","title":"Solving Problems","text":"Once you've created a problem template, solving is straightforward with the solve! function:\n\nsystem = QuantumSystem(0.1 * PAULIS.Z, [PAULIS.X, PAULIS.Y], [1.0, 1.0])\nU_goal = EmbeddedOperator(GATES.H, system)\nT = 10.0 # time duration\nqtraj = UnitaryTrajectory(system, U_goal, T)\n\nN = 51 # number of timesteps\nprob = SmoothPulseProblem(qtraj, N)\n\nThe solve! function accepts several key options:\n\nsolve!(prob;\n    max_iter = 100,        # Maximum optimization iterations\n    verbose = true,         # Print convergence information\n    print_level = 1         # Ipopt output level (0-5)\n)","category":"section"},{"location":"generated/man/working_with_solutions/#Understanding-Convergence","page":"Working with Solutions","title":"Understanding Convergence","text":"Ipopt reports several key metrics:\n\nObjective: Current cost function value\ninf_pr: Constraint violation (primal infidelity) - should go to ~0\ninf_du: Dual infidelity - measure of optimality\nlg(mu): Log of barrier parameter\nalphadu/alphapr: Step sizes\n\nSuccessful convergence typically shows inf_pr < 1e-6 and status Optimal Solution Found.","category":"section"},{"location":"generated/man/working_with_solutions/#Extracting-Data-from-Solutions","page":"Working with Solutions","title":"Extracting Data from Solutions","text":"","category":"section"},{"location":"generated/man/working_with_solutions/#Accessing-Controls","page":"Working with Solutions","title":"Accessing Controls","text":"Control pulses are stored in the trajectory with automatic naming:\n\nu = prob.trajectory.u       # Control values [n_drives × N]\ndu = prob.trajectory.du     # First derivatives\nddu = prob.trajectory.ddu   # Second derivatives\n\nprintln(\"Control shape: \", size(u))\nprintln(\"Number of drives: \", size(u, 1))\nprintln(\"Number of timesteps: \", size(u, 2))\n\nAccess individual drive controls:\n\nu_drive_1 = u[1, :]   # First drive over time","category":"section"},{"location":"generated/man/working_with_solutions/#Accessing-States","page":"Working with Solutions","title":"Accessing States","text":"For unitary problems:\n\nŨ⃗ = prob.trajectory.Ũ⃗  # Vectorized unitary [N² × T]\n\nThe unitary is stored in \"isovec\" format (vectorized). To get the actual unitary matrix at timestep k:\n\nusing LinearAlgebra\nk = N  # Final timestep\nU_k = iso_vec_to_operator(Ũ⃗[:, k])\nprintln(\"Final unitary dimensions: \", size(U_k))\n\nFor ket (state) problems, use: ψ̃ = prob.trajectory.ψ̃  # Vectorized state [2N × T]","category":"section"},{"location":"generated/man/working_with_solutions/#Time-Grid","page":"Working with Solutions","title":"Time Grid","text":"Access timestep information:\n\nΔt_vec = prob.trajectory.Δt  # Timestep durations\n\nCalculate total duration:\n\nduration = get_duration(prob.trajectory)\nprintln(\"Total gate time: \", duration, \" (arbitrary units)\")\n\nFor minimum time problems, timesteps vary: minprob = UnitaryMinimumTimeProblem(prob, Ugoal) solve!(minprob, maxiter=100) Δtoptimized = minprob.trajectory.Δt  # Variable timesteps","category":"section"},{"location":"generated/man/working_with_solutions/#Evaluating-Solutions","page":"Working with Solutions","title":"Evaluating Solutions","text":"","category":"section"},{"location":"generated/man/working_with_solutions/#Fidelity-Calculations","page":"Working with Solutions","title":"Fidelity Calculations","text":"Direct fidelity - Compare final state to goal:\n\nU_final = iso_vec_to_operator(prob.trajectory.Ũ⃗[:, end])\nfid_direct = unitary_fidelity(U_final, U_goal.operator)\nprintln(\"Direct fidelity: \", fid_direct)\n\nRollout fidelity - Simulate dynamics forward:\n\nfid_rollout = unitary_rollout_fidelity(prob.trajectory, system)\nprintln(\"Rollout fidelity: \", fid_rollout)\n\nThe rollout fidelity is more accurate as it accounts for actual dynamics, while direct fidelity only checks the final point.","category":"section"},{"location":"generated/man/working_with_solutions/#For-Embedded-Operators-(Multilevel-Systems)","page":"Working with Solutions","title":"For Embedded Operators (Multilevel Systems)","text":"When working with subspaces (e.g., qubit in transmon): op = EmbeddedOperator(:X, system) probembedded = UnitarySmoothPulseProblem(system, op, N) solve!(probembedded, max_iter=100)","category":"section"},{"location":"generated/man/working_with_solutions/#Evaluate-fidelity-only-in-computational-subspace","page":"Working with Solutions","title":"Evaluate fidelity only in computational subspace","text":"fidsubspace = unitaryrolloutfidelity(     probembedded.trajectory,     system;     subspace = op.subspace )","category":"section"},{"location":"generated/man/working_with_solutions/#Leakage-Evaluation","page":"Working with Solutions","title":"Leakage Evaluation","text":"For multilevel systems, check population in leakage levels: This requires analyzing state populations during evolution See the Multilevel Transmon example for details","category":"section"},{"location":"generated/man/working_with_solutions/#Constraint-Violations","page":"Working with Solutions","title":"Constraint Violations","text":"Check if solution satisfies all constraints:\n\nDynamics constraints: Compare rollout vs direct fidelity\nBound constraints: Verify controls within system.drive_bounds\nDerivative constraints: Check |du|, |ddu| within bounds\n\nprintln(\"Max control value: \", maximum(abs.(u)))\nprintln(\"Max control derivative: \", maximum(abs.(du)))","category":"section"},{"location":"generated/man/working_with_solutions/#Saving-and-Loading","page":"Working with Solutions","title":"Saving and Loading","text":"","category":"section"},{"location":"generated/man/working_with_solutions/#Save-a-Trajectory","page":"Working with Solutions","title":"Save a Trajectory","text":"using JLD2 saveobject(\"mysolution.jld2\", prob.trajectory)","category":"section"},{"location":"generated/man/working_with_solutions/#Load-and-Reuse","page":"Working with Solutions","title":"Load and Reuse","text":"Load trajectory for warm-starting: trajloaded = loadobject(\"my_solution.jld2\")","category":"section"},{"location":"generated/man/working_with_solutions/#Use-as-initial-guess-for-new-problem","page":"Working with Solutions","title":"Use as initial guess for new problem","text":"probrefined = UnitarySmoothPulseProblem(     system, Ugoal, T, Δt;     uguess = trajloaded.u,     piccolo_options = PiccoloOptions(verbose=false) )","category":"section"},{"location":"generated/man/working_with_solutions/#Save-Entire-Problem","page":"Working with Solutions","title":"Save Entire Problem","text":"To save all problem information including constraints and objectives: saveobject(\"myproblem.jld2\", prob)","category":"section"},{"location":"generated/man/working_with_solutions/#Post-Processing","page":"Working with Solutions","title":"Post-Processing","text":"","category":"section"},{"location":"generated/man/working_with_solutions/#Resampling-Trajectories","page":"Working with Solutions","title":"Resampling Trajectories","text":"Change time discretization while preserving control shape: Tnew = 101  # More timesteps trajresampled = resample(prob.trajectory, T_new)","category":"section"},{"location":"generated/man/working_with_solutions/#Extracting-for-Experiments","page":"Working with Solutions","title":"Extracting for Experiments","text":"Prepare control pulses for hardware:\n\nusing PiccoloPlots  # For visualization\nusing CairoMakie\n\nPlot controls\n\nfig = plot(prob.trajectory)\n\nsave(\"controls.png\", fig)\n\nExtract control data for export\n\ncontrol_data = Dict(\n    \"time\" => cumsum([0; prob.trajectory.Δt[:]]),\n    \"drive_1_real\" => u[1, :],\n    \"drive_2_real\" => u[2, :],\n    \"duration\" => duration\n)","category":"section"},{"location":"generated/man/working_with_solutions/#Save-to-CSV-or-other-format-for-AWG","page":"Working with Solutions","title":"Save to CSV or other format for AWG","text":"using CSV, DataFrames df = DataFrame(controldata) CSV.write(\"pulsesequence.csv\", df)","category":"section"},{"location":"generated/man/working_with_solutions/#Pulse-Filtering","page":"Working with Solutions","title":"Pulse Filtering","text":"Apply smoothing to reduce high-frequency noise: using DSP for i in 1:size(u, 1)     u_filtered[i, :] = filtfilt(responsetype, u[i, :]) end","category":"section"},{"location":"generated/man/working_with_solutions/#Best-Practices","page":"Working with Solutions","title":"Best Practices","text":"Starting a new optimization:\n\nBegin with coarse discretization (small T)\nUse relaxed bounds and convergence criteria\nRefine solution incrementally\nUse previous solution as warm start\n\nDebugging poor convergence:\n\nCheck inf_pr - high values indicate constraint violations\nVerify system Hamiltonian is correct\nTry looser derivative bounds (dubound, ddubound)\nIncrease regularization weights (R_u, R_du, R_ddu)\nUse piccolo_options.bound_state=true for better numerics\n\nImproving solutions:\n\nIncrease T (more timesteps = finer control)\nAdd derivative constraints for smoother pulses\nUse minimum time optimization for fastest gates\nApply leakage constraints for multilevel systems\nUse sampling problems for robust control\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"generated/man/problem_templates_overview/#Problem-Templates-Overview","page":"Problem Templates Overview","title":"Problem Templates Overview","text":"QuantumCollocation.jl provides 4 problem templates that cover common quantum optimal control scenarios. These templates make it easy to set up and solve problems without manually constructing objectives, constraints, and integrators.","category":"section"},{"location":"generated/man/problem_templates_overview/#Template-Comparison","page":"Problem Templates Overview","title":"Template Comparison","text":"Template Objective Time Use Case\nSmoothPulseProblem Minimize control effort + infidelity Fixed Standard gate/state synthesis with smooth pulses\nMinimumTimeProblem Minimize duration Variable Fastest gate/state synthesis given fidelity constraint\nSplinePulseProblem Minimize control effort + infidelity Fixed Gate/state synthesis with spline-based pulses where the derivative variables (du) are the actual spline coefficients or slopes.\nSamplingProblem Minimize control effort + weighted sum of infidelity objectives Fixed Robust gate/state synthesis where the controls are shared across all systems, with differing dynamics.","category":"section"},{"location":"generated/man/problem_templates_overview/#Smooth-Pulse-vs-Minimum-Time","page":"Problem Templates Overview","title":"Smooth Pulse vs Minimum Time","text":"Smooth Pulse: Fixed total time T × Δt, minimizes control effort with regularization on u, u̇, ü\nMinimum Time: Variable timesteps Δt[k], minimizes total duration subject to fidelity constraint","category":"section"},{"location":"generated/man/problem_templates_overview/#Sampling-Problems","page":"Problem Templates Overview","title":"Sampling Problems","text":"Solve for a single control pulse that works well across multiple quantum systems\nUseful for robustness against parameter uncertainties or manufacturing variations\nExamples: different coupling strengths, detunings, or environmental conditions","category":"section"},{"location":"generated/man/problem_templates_overview/#Quick-Selection-Guide","page":"Problem Templates Overview","title":"Quick Selection Guide","text":"I want to implement a quantum gate:\n\nStart simple? → SmoothPulseProblem + UnitaryTrajectory\nNeed speed? → MinimumTimeProblem + UnitaryTrajectory\nNeed robustness? → SamplingProblem + UnitaryTrajectory\n\nI want to prepare a quantum state:\n\nStandard case? → SmoothPulseProblem + KetTrajectory\nSpeed critical? → MinimumTimeProblem + KetTrajectory\nRobust preparation? → SamplingProblem + KetTrajectory","category":"section"},{"location":"generated/man/problem_templates_overview/#Common-Parameters","page":"Problem Templates Overview","title":"Common Parameters","text":"All templates share these key parameters:\n\nusing QuantumCollocation # hide\nusing PiccoloQuantumObjects # hide\nH_drift = 0.1 * PAULIS.Z # hide\nH_drives = [PAULIS.X, PAULIS.Y] # hide\ndrive_bounds = [1.0, 1.0]  # hide\nsys = QuantumSystem(H_drift, H_drives, drive_bounds) # hide\nU_goal = GATES[:H] # hide\nT = 10.0  # hide\nqtraj = UnitaryTrajectory(sys, U_goal, T) # hide\nN = 51 # hide\n\nprob = SmoothPulseProblem(\n    qtraj,              # QuantumTrajectory wrapping system information, Unitary/Ket/MultiKet problem type\n    N;                  # Number of timesteps\n\n    Q=100.0,            # Objective weighting coefficient for the infidelity\n    R=1e-2,             # Objective weighting coefficient for the controls regularization\n\n    piccolo_options = PiccoloOptions(verbose = true),  # PiccoloOptions for solver configuration\n)\n\nSee the individual template pages for parameter details and examples.\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"generated/man/piccolo_options/#PiccoloOptions-Reference","page":"PiccoloOptions Reference","title":"PiccoloOptions Reference","text":"PiccoloOptions provides advanced configuration for problem templates. This page documents all available options and their effects.\n\nusing QuantumCollocation\nusing PiccoloQuantumObjects","category":"section"},{"location":"generated/man/piccolo_options/#Creating-PiccoloOptions","page":"PiccoloOptions Reference","title":"Creating PiccoloOptions","text":"Default options:\n\nopts = PiccoloOptions()\n\nCustom options:\n\nopts_custom = PiccoloOptions(\n    verbose = true,\n    leakage_constraint = true,\n    bound_state = true\n)\n\nPass to any problem template:\n\nsystem = QuantumSystem(0.1 * PAULIS.Z, [PAULIS.X, PAULIS.Y], [1.0, 1.0])\nU_goal = EmbeddedOperator(GATES.H, system)\n\nT = 10.0\nqtraj = UnitaryTrajectory(system, U_goal, T)\n\nN = 51\nprob = SmoothPulseProblem(\n    qtraj, N;\n    piccolo_options = opts_custom\n)","category":"section"},{"location":"generated/man/piccolo_options/#General-Options","page":"PiccoloOptions Reference","title":"General Options","text":"","category":"section"},{"location":"generated/man/piccolo_options/#verbose::Bool-false","page":"PiccoloOptions Reference","title":"verbose::Bool = false","text":"Print detailed information during problem setup.\n\nopts_verbose = PiccoloOptions(verbose = true)\n\nShows: constraint counts, objective terms, trajectory initialization details","category":"section"},{"location":"generated/man/piccolo_options/#free_time::Bool-false","page":"PiccoloOptions Reference","title":"free_time::Bool = false","text":"Allow timesteps to vary (used internally by minimum time problems). Typically not set directly by users.","category":"section"},{"location":"generated/man/piccolo_options/#State-and-Unitary-Options","page":"PiccoloOptions Reference","title":"State and Unitary Options","text":"","category":"section"},{"location":"generated/man/piccolo_options/#bound_state::Bool-false","page":"PiccoloOptions Reference","title":"bound_state::Bool = false","text":"Constrain state/unitary to lie on unit sphere (for numerical stability). Recommended for difficult convergence.\n\nopts_bounded = PiccoloOptions(bound_state = true)\n\nAdds constraint: ||ψ||² = 1 (ket) or ||U||² = N (unitary)","category":"section"},{"location":"generated/man/piccolo_options/#geodesic::Bool-true","page":"PiccoloOptions Reference","title":"geodesic::Bool = true","text":"Use geodesic interpolation for initial trajectory.\n\ntrue: States evolve along shortest path on manifold (better initial guess)\nfalse: Linear interpolation (simpler but often worse)\n\nopts_linear = PiccoloOptions(geodesic = false)","category":"section"},{"location":"generated/man/piccolo_options/#Control-Initialization","page":"PiccoloOptions Reference","title":"Control Initialization","text":"","category":"section"},{"location":"generated/man/piccolo_options/#init_trajectory::Union{NamedTrajectory,-Nothing}-nothing","page":"PiccoloOptions Reference","title":"init_trajectory::Union{NamedTrajectory, Nothing} = nothing","text":"Provide custom initial trajectory instead of automatic initialization.\n\ntrajcustom = initializetrajectory(...) optsinit = PiccoloOptions(inittrajectory = traj_custom)","category":"section"},{"location":"generated/man/piccolo_options/#build_trajectory_constraints::Bool-true","page":"PiccoloOptions Reference","title":"build_trajectory_constraints::Bool = true","text":"Automatically extract constraints from trajectory bounds. Set to false if manually managing constraints.","category":"section"},{"location":"generated/man/piccolo_options/#Leakage-Suppression-(Multilevel-Systems)","page":"PiccoloOptions Reference","title":"Leakage Suppression (Multilevel Systems)","text":"","category":"section"},{"location":"generated/man/piccolo_options/#leakage_constraint::Bool-false","page":"PiccoloOptions Reference","title":"leakage_constraint::Bool = false","text":"Add constraint to limit leakage population.","category":"section"},{"location":"generated/man/piccolo_options/#leakage_constraint_value::Float64-1e-3","page":"PiccoloOptions Reference","title":"leakage_constraint_value::Float64 = 1e-3","text":"Maximum allowed leakage: ∑ᵢ |⟨i|ψ⟩|² ≤ leakageconstraintvalue","category":"section"},{"location":"generated/man/piccolo_options/#leakage_cost::Float64-1.0","page":"PiccoloOptions Reference","title":"leakage_cost::Float64 = 1.0","text":"Penalty weight for leakage in objective (soft constraint).\n\nopts_leakage = PiccoloOptions(\n    leakage_constraint = true,\n    leakage_constraint_value = 1e-2,  # 1% max leakage\n    leakage_cost = 1e-1\n)\n\nExample with embedded operator: systransmon = TransmonSystem(levels=5, δ=0.2) op = EmbeddedOperator(:X, systransmon) probleakage = UnitarySmoothPulseProblem(     systransmon, op, T, Δt;     piccolooptions = optsleakage )","category":"section"},{"location":"generated/man/piccolo_options/#Control-Constraints","page":"PiccoloOptions Reference","title":"Control Constraints","text":"","category":"section"},{"location":"generated/man/piccolo_options/#complex_control_norm_constraint_name::Union{Symbol,-Nothing}-nothing","page":"PiccoloOptions Reference","title":"complex_control_norm_constraint_name::Union{Symbol, Nothing} = nothing","text":"Apply norm constraint to complex control amplitudes.\n\nFor systems with complex drives (e.g., rotating frame): optsnorm = PiccoloOptions(     complexcontrolnormconstraintname = :u,     complexcontrolnormconstraintradius = 0.2 ) Enforces: |ureal + i*u_imag| ≤ radius","category":"section"},{"location":"generated/man/piccolo_options/#complex_control_norm_constraint_radius::Float64-1.0","page":"PiccoloOptions Reference","title":"complex_control_norm_constraint_radius::Float64 = 1.0","text":"Radius for complex control norm constraint.","category":"section"},{"location":"generated/man/piccolo_options/#Timestep-Options","page":"PiccoloOptions Reference","title":"Timestep Options","text":"","category":"section"},{"location":"generated/man/piccolo_options/#timesteps_all_equal::Bool-false","page":"PiccoloOptions Reference","title":"timesteps_all_equal::Bool = false","text":"Force all timesteps to be equal: Δt[k] = Δt[1] ∀k. Useful for hardware with fixed sampling rates.\n\nopts_equal_dt = PiccoloOptions(timesteps_all_equal = true)","category":"section"},{"location":"generated/man/piccolo_options/#Derivative-Constraints","page":"PiccoloOptions Reference","title":"Derivative Constraints","text":"","category":"section"},{"location":"generated/man/piccolo_options/#zero_initial_and_final_derivative::Bool-false","page":"PiccoloOptions Reference","title":"zero_initial_and_final_derivative::Bool = false","text":"Force derivatives to zero at boundaries: u̇[1] = u̇[T] = 0, ü[1] = ü[T] = 0. Creates \"smooth ramp\" pulses that start and end at zero derivative.\n\nopts_smooth_edges = PiccoloOptions(zero_initial_and_final_derivative = true)","category":"section"},{"location":"generated/man/piccolo_options/#Common-Configuration-Patterns","page":"PiccoloOptions Reference","title":"Common Configuration Patterns","text":"","category":"section"},{"location":"generated/man/piccolo_options/#Quick-and-dirty-optimization","page":"PiccoloOptions Reference","title":"Quick and dirty optimization","text":"opts_quick = PiccoloOptions(\n    verbose = false,\n    geodesic = true\n)","category":"section"},{"location":"generated/man/piccolo_options/#High-fidelity-gate","page":"PiccoloOptions Reference","title":"High-fidelity gate","text":"opts_hifi = PiccoloOptions(\n    verbose = true,\n    bound_state = true,\n    geodesic = true,\n)","category":"section"},{"location":"generated/man/piccolo_options/#Multilevel-system-with-leakage-suppression","page":"PiccoloOptions Reference","title":"Multilevel system with leakage suppression","text":"opts_multilevel = PiccoloOptions(\n    bound_state = true,\n    leakage_constraint = true,\n    leakage_constraint_value = 1e-2,\n    leakage_cost = 1e-1,\n    verbose = true\n)","category":"section"},{"location":"generated/man/piccolo_options/#Smooth-pulses-for-hardware","page":"PiccoloOptions Reference","title":"Smooth pulses for hardware","text":"opts_hardware = PiccoloOptions(\n    zero_initial_and_final_derivative = true,\n    timesteps_all_equal = true,\n    bound_state = true\n)","category":"section"},{"location":"generated/man/piccolo_options/#Robust-optimization","page":"PiccoloOptions Reference","title":"Robust optimization","text":"opts_robust = PiccoloOptions(\n    bound_state = true,\n    geodesic = true,\n    verbose = true\n)","category":"section"},{"location":"generated/man/piccolo_options/#Tips-and-Tricks","page":"PiccoloOptions Reference","title":"Tips and Tricks","text":"When to use bound_state=true:\n\nOptimization struggling to converge\nFidelity stuck below 0.99\nNumerical instabilities in state evolution\nWorking with large Hilbert spaces\n\nLeakage vs bounds:\n\nLeakage constraint enforces hard limit (may fail to converge)\nLeakage cost adds soft penalty (more forgiving)\nUse both for best results\n\nGeodesic initialization:\n\nAlmost always better than linear\nOnly disable for debugging or special cases\nParticularly important for large T\n\nRollout integrator:\n\n:pade is fast and usually sufficient\n:exp more accurate for sensitive systems\nBoth give same result for well-conditioned problems\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"#QuantumCollocation.jl","page":"Home","title":"QuantumCollocation.jl","text":"QuantumCollocation.jl is a Julia package for solving quantum optimal control problems using direct collocation methods. It transforms continuous-time quantum control into finite-dimensional nonlinear programs (NLPs) solved efficiently with Ipopt.","category":"section"},{"location":"#Quick-Start","page":"Home","title":"Quick Start","text":"","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"using Pkg\nPkg.add(\"QuantumCollocation\")\n\nOr from the Julia REPL, press ] to enter package mode:\n\npkg> add QuantumCollocation","category":"section"},{"location":"#30-Second-Example","page":"Home","title":"30-Second Example","text":"Here's a complete example optimizing a Hadamard gate on a qubit:\n\nusing QuantumCollocation\nusing PiccoloQuantumObjects\n\n# Define system: drift + 2 control Hamiltonians\nH_drift = 0.1 * PAULIS.Z\nH_drives = [PAULIS.X, PAULIS.Y]\ndrive_bounds = [1.0, 1.0]  # symmetric bounds\nsys = QuantumSystem(H_drift, H_drives, drive_bounds)\n\n# 2. Create quantum trajectory. defines problem: system, target gate, timesteps\nU_goal = GATES[:H]\nT = 10.0\nqtraj = UnitaryTrajectory(sys, U_goal, T) # creates zero pulse internally\n\n# 3. Build optimization problem\nN = 51  # number of timesteps\nqcp = SmoothPulseProblem(qtraj, N; Q=100.0, R=1e-2)\n\n# Solve!\nsolve!(qcp; options=IpoptOptions(max_iter=100))\n\n# Check result\ntraj = get_trajectory(qcp)\nprintln(\"Fidelity: \", fidelity(qcp))\n\nThat's it! You've optimized control pulses for a quantum gate.","category":"section"},{"location":"#What-Can-QuantumCollocation-Do?","page":"Home","title":"What Can QuantumCollocation Do?","text":"Unitary gate optimization - Find pulses to implement quantum gates\nOpen quantum systems - Find pulses for lindladian dynamics \nState transfer - Drive quantum states to target states\nMinimum time control - Optimize gate duration\nRobust control - Account for system uncertainties\nMultilevel systems - Handle transmons, bosonic codes, etc.\nLeakage suppression - Constrain populations in unwanted levels\nCustom constraints - Add your own physics constraints","category":"section"},{"location":"#Overview","page":"Home","title":"Overview","text":"QuantumCollocation.jl sets up and solves quantum control problems as nonlinear programs (NLPs). A generic quantum control problem looks like:\n\nbeginaligned\n    arg min_mathbfZquad  J(mathbfZ) \n    textstqquad  mathbff(mathbfZ) = 0 \n     mathbfg(mathbfZ) le 0\nendaligned\n\nwhere mathbfZ is a trajectory containing states and controls from NamedTrajectories.jl.\n\nWe provide problem templates for common quantum control tasks. These templates construct a DirectTrajOptProblem from DirectTrajOpt.jl with appropriate objectives, constraints, and dynamics.","category":"section"},{"location":"#Problem-Templates","page":"Home","title":"Problem Templates","text":"Problem templates are organized by the type of quantum system being controlled:","category":"section"},{"location":"#General-Problem-Templates","page":"Home","title":"General Problem Templates","text":"MinimumTimeProblem - Minimize gate duration\nSamplingProblem - Robust control over system variations\nSmoothPulseProblem - Optimize smooth pulses for unitary gates\nSplinePulseProblem - Using higher order splines to characterize pulse shape\n\nSee the Problem Templates Overview for a detailed comparison and selection guide.","category":"section"},{"location":"#How-It-Works","page":"Home","title":"How It Works","text":"","category":"section"},{"location":"#Direct-Collocation","page":"Home","title":"Direct Collocation","text":"QuantumCollocation uses direct collocation - discretizing continuous-time dynamics into constraints at discrete time points (knot points). For example, a smooth pulse problem for a unitary gate:\n\nbeginaligned\n    arg min_mathbfZquad  1 - mathcalF(U_N U_textgoal)  \n    textstqquad  U_k+1 = exp- i H(u_k) Delta t_k  U_k quad forall k \n     u_k+1 = u_k + dotu_k Delta t_k \n     dotu_k+1 = dotu_k + ddotu_k Delta t_k \n     u_k le u_textmax quad ddotu_k le ddotu_textmax\nendaligned\n\nThe dynamics between knot points (U_k u_k) and (U_k+1 u_k+1) become nonlinear equality constraints. States and controls are free variables optimized by the NLP solver.","category":"section"},{"location":"#Key-Features","page":"Home","title":"Key Features","text":"Efficient gradients - Sparse Jacobians and Hessians via automatic differentiation\nFlexible constraints - Add custom physics, leakage suppression, robustness\nMultiple integrators - Exponential, Pade, time-dependent dynamics\nExtensible - Easy to add new objectives, constraints, and problem templates","category":"section"},{"location":"#Next-Steps","page":"Home","title":"Next Steps","text":"📚 Problem Templates Overview - Choose the right template for your problem\n🎯 Working with Solutions - Extract results, evaluate fidelity, save data\n⚙️ PiccoloOptions Reference - Configure solver options and constraints\n💡 Two Qubit Gates, Single Qubit Gate - See complete examples from single qubits to multilevel systems (MOVING TO PICCOLO DOCS)","category":"section"},{"location":"#Related-Packages","page":"Home","title":"Related Packages","text":"QuantumCollocation.jl is part of the Piccolo ecosystem:\n\nNamedTrajectories.jl - Trajectory data structures\nDirectTrajOpt.jl - Direct trajectory optimization framework\nPiccoloQuantumObjects.jl - Quantum operators and systems\nPiccoloPlots.jl - Visualization tools\n\nProblem templates give the user the ability to add other constraints and objective functions to this problem and solve it efficiently using Ipopt.jl and MathOptInterface.jl under the hood (support for additional backends coming soon!).","category":"section"}]
}
