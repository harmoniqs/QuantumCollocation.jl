var documenterSearchIndex = {"docs":
[{"location":"release_notes/#Release-Notes","page":"Release Notes","title":"Release Notes","text":"","category":"section"},{"location":"release_notes/","page":"Release Notes","title":"Release Notes","text":"The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.","category":"page"},{"location":"release_notes/#[v0.3.1]-2024-10-17","page":"Release Notes","title":"[v0.3.1] - 2024-10-17","text":"","category":"section"},{"location":"release_notes/#Fixed","page":"Release Notes","title":"Fixed","text":"","category":"section"},{"location":"release_notes/","page":"Release Notes","title":"Release Notes","text":"Fixed and added tests to RydbergChainSystem","category":"page"},{"location":"release_notes/#[v0.3.0]-2024-10-10","page":"Release Notes","title":"[v0.3.0] - 2024-10-10","text":"","category":"section"},{"location":"release_notes/#Added","page":"Release Notes","title":"Added","text":"","category":"section"},{"location":"release_notes/","page":"Release Notes","title":"Release Notes","text":"PiccoloOptions to handle custome problem settings.","category":"page"},{"location":"release_notes/#Changed","page":"Release Notes","title":"Changed","text":"","category":"section"},{"location":"release_notes/","page":"Release Notes","title":"Release Notes","text":"Refactored trajectory initialization functions\nImproved documentation\nTypo fixes","category":"page"},{"location":"release_notes/#[v0.2.0]-2024-02-22","page":"Release Notes","title":"[v0.2.0] - 2024-02-22","text":"","category":"section"},{"location":"release_notes/#Added-2","page":"Release Notes","title":"Added","text":"","category":"section"},{"location":"release_notes/","page":"Release Notes","title":"Release Notes","text":"EmbeddedOperator to handle subspace gate optimization and leakage suppression\nPlotting methods for unitary populations","category":"page"},{"location":"release_notes/#Changed-2","page":"Release Notes","title":"Changed","text":"","category":"section"},{"location":"release_notes/","page":"Release Notes","title":"Release Notes","text":"New quantum systems interface\nTransmon system template\nRestructured the code base for easier quantum system and problem template development","category":"page"},{"location":"release_notes/#Removed","page":"Release Notes","title":"Removed","text":"","category":"section"},{"location":"release_notes/","page":"Release Notes","title":"Release Notes","text":"Stale examples ","category":"page"},{"location":"release_notes/#Fixed-2","page":"Release Notes","title":"Fixed","text":"","category":"section"},{"location":"release_notes/","page":"Release Notes","title":"Release Notes","text":"Robustness improvements objective test fixes ","category":"page"},{"location":"contribution_guide/#Contribution-Guide","page":"Contribution Guide","title":"Contribution Guide","text":"","category":"section"},{"location":"contribution_guide/#Introduction","page":"Contribution Guide","title":"Introduction","text":"","category":"section"},{"location":"contribution_guide/","page":"Contribution Guide","title":"Contribution Guide","text":"We welcome contributiuons to QuantumCollocation.jl! This document outlines the guidelines for contributing to the project. If you know what you want to see, but are unsure of the best way to achieve it, add an issue and start a discussion with the community! ","category":"page"},{"location":"contribution_guide/","page":"Contribution Guide","title":"Contribution Guide","text":"Let us know how you are using Piccolo! We enjoy hearing about the problems our users are solving.","category":"page"},{"location":"contribution_guide/#Developing","page":"Contribution Guide","title":"Developing","text":"","category":"section"},{"location":"contribution_guide/","page":"Contribution Guide","title":"Contribution Guide","text":"We recommend creating a fresh environment, and using the dev command to install QuantumCollocation.jl from source. Adding Revise.jl to this environment allows us to make changes to QuantumCollocation.jl during development, without restarting Julia or notebooks in VSCode.","category":"page"},{"location":"contribution_guide/","page":"Contribution Guide","title":"Contribution Guide","text":"Here are a few places to think about participating!","category":"page"},{"location":"contribution_guide/","page":"Contribution Guide","title":"Contribution Guide","text":"Documentation:","category":"page"},{"location":"contribution_guide/","page":"Contribution Guide","title":"Contribution Guide","text":"[ ] cross-referencing to library\n[ ] adding docstrings, examples, and tests of utilities\n[ ] examples\n[ ] two-qubit\n[ ] cat qubit \n[ ] three-qubit \n[ ] qubit-cavity\n[ ] qubit-cavity-qubit\n[ ] document type requirements for Constraints, Losses, and Objectives ","category":"page"},{"location":"contribution_guide/","page":"Contribution Guide","title":"Contribution Guide","text":"Functionality:","category":"page"},{"location":"contribution_guide/","page":"Contribution Guide","title":"Contribution Guide","text":"[ ] custom QuantumTrajectory types (repr. of isomorphic states)\n[ ] better quantum system constructors (e.g. storing composite system info) \n[ ] refactor Objectives and distinguish from Losses","category":"page"},{"location":"contribution_guide/#Documentation","page":"Contribution Guide","title":"Documentation","text":"","category":"section"},{"location":"contribution_guide/","page":"Contribution Guide","title":"Contribution Guide","text":"Documentation is built using Documenter.jl and uses Literate.jl to generate markdown files from scripts stored in docs/literate. To build the documentation locally, start julia with the docs environment:","category":"page"},{"location":"contribution_guide/","page":"Contribution Guide","title":"Contribution Guide","text":"julia --project=docs","category":"page"},{"location":"contribution_guide/","page":"Contribution Guide","title":"Contribution Guide","text":"Then (for ease of development) load the following packages:","category":"page"},{"location":"contribution_guide/","page":"Contribution Guide","title":"Contribution Guide","text":"using Revise, LiveServer, QuantumCollocation","category":"page"},{"location":"contribution_guide/","page":"Contribution Guide","title":"Contribution Guide","text":"To live-serve the docs, run","category":"page"},{"location":"contribution_guide/","page":"Contribution Guide","title":"Contribution Guide","text":"servedocs(literate_dir=\"docs/literate\", skip_dir=\"docs/src/generated\")","category":"page"},{"location":"contribution_guide/","page":"Contribution Guide","title":"Contribution Guide","text":"Changes made to files in the docs directory should be automatically reflected in the live server. To reflect changes in the source code (e.g. doc strings), since we are using Revise, simply kill the live server running in the REPL (with, e.g., Ctrl-C) and restart it with the above command. ","category":"page"},{"location":"contribution_guide/#Writing-tests","page":"Contribution Guide","title":"Writing tests","text":"","category":"section"},{"location":"contribution_guide/","page":"Contribution Guide","title":"Contribution Guide","text":"Tests are implemented using the TestItemRunner.jl package. ","category":"page"},{"location":"contribution_guide/","page":"Contribution Guide","title":"Contribution Guide","text":"@testitem \"Hadamard gate\" begin\n    H_drift, H_drives = GATES[:Z], [GATES[:X], GATES[:Y]]\n    U_goal = GATES[:H]\n    T = 51\n    Δt = 0.2\n\n    prob = UnitarySmoothPulseProblem(\n        H_drift, H_drives, U_goal, T, Δt,\n        ipopt_options=IpoptOptions(print_level=1)\n    )\n\n    solve!(prob, max_iter=100)\n    @test unitary_fidelity(prob) > 0.99\nend","category":"page"},{"location":"contribution_guide/","page":"Contribution Guide","title":"Contribution Guide","text":"Individual tests will populate in the Testing panel in VSCode. All tests are integrated into the base test system for CI, which occurs at each PR submission.","category":"page"},{"location":"contribution_guide/","page":"Contribution Guide","title":"Contribution Guide","text":"We organize our tests in two ways:","category":"page"},{"location":"contribution_guide/","page":"Contribution Guide","title":"Contribution Guide","text":"Modules in single files (e.g. quantum_utils.jl, direct_sums.jl) should have a single test file in the test/ directory.\nModule directories containing templates (e.g. quantum_system_templates/, problem_templates/) should include tests in the same file that the template is defined, so problem_templates/unitary_smooth_pulse_problem.jl includes the test items for UnitarySmoothPulseProblem.","category":"page"},{"location":"contribution_guide/#Reporting-Issues","page":"Contribution Guide","title":"Reporting Issues","text":"","category":"section"},{"location":"contribution_guide/","page":"Contribution Guide","title":"Contribution Guide","text":"Issue templates are available on GitHub. We are happy to take feature requests!","category":"page"},{"location":"lib/#Library","page":"Library","title":"Library","text":"","category":"section"},{"location":"lib/#Problem-Templates","page":"Library","title":"Problem Templates","text":"","category":"section"},{"location":"lib/","page":"Library","title":"Library","text":"Modules = [QuantumCollocation.ProblemTemplates]","category":"page"},{"location":"lib/#QuantumCollocation.ProblemTemplates.QuantumStateMinimumTimeProblem","page":"Library","title":"QuantumCollocation.ProblemTemplates.QuantumStateMinimumTimeProblem","text":"QuantumStateMinimumTimeProblem(traj, sys, obj, integrators, constraints; kwargs...)\nQuantumStateMinimumTimeProblem(prob; kwargs...)\n\nConstruct a QuantumControlProblem for the minimum time problem of reaching a target state.\n\nArguments\n\ntraj::NamedTrajectory: The initial trajectory.\nsys::QuantumSystem: The quantum system.\nobj::Objective: The objective function.\nintegrators::Vector{<:AbstractIntegrator}: The integrators.\nconstraints::Vector{<:AbstractConstraint}: The constraints.\n\nor\n\nprob::QuantumControlProblem: The quantum control problem.\n\nKeyword Arguments\n\nstate_name::Symbol=:ψ̃: The symbol for the state variables.\nfinal_fidelity::Union{Real, Nothing}=nothing: The final fidelity.\nD=1.0: The cost weight on the time.\nipopt_options::IpoptOptions=IpoptOptions(): The Ipopt options.\npiccolo_options::PiccoloOptions=PiccoloOptions(): The Piccolo options.\nkwargs...: Additional keyword arguments, passed to QuantumControlProblem.\n\n\n\n\n\n","category":"function"},{"location":"lib/#QuantumCollocation.ProblemTemplates.QuantumStateSmoothPulseProblem","page":"Library","title":"QuantumCollocation.ProblemTemplates.QuantumStateSmoothPulseProblem","text":"QuantumStateSmoothPulseProblem(system, ψ_inits, ψ_goals, T, Δt; kwargs...)\nQuantumStateSmoothPulseProblem(system, ψ_init, ψ_goal, T, Δt; kwargs...)\nQuantumStateSmoothPulseProblem(H_drift, H_drives, args...; kwargs...)\n\nCreate a quantum state smooth pulse problem. The goal is to find a control pulse a(t) that drives all of the initial states ψ_inits to the corresponding target states ψ_goals using T timesteps of size Δt. This problem also controls the first and second derivatives of the control pulse, da(t) and dda(t), to ensure smoothness.\n\nArguments\n\nsystem::AbstractQuantumSystem: The quantum system.\n\nor\n\nH_drift::AbstractMatrix{<:Number}: The drift Hamiltonian.\nH_drives::Vector{<:AbstractMatrix{<:Number}}: The control Hamiltonians.\n\nwith\n\nψ_inits::Vector{<:AbstractVector{<:ComplexF64}}: The initial states.\nψ_goals::Vector{<:AbstractVector{<:ComplexF64}}: The target states.\n\nor\n\nψ_init::AbstractVector{<:ComplexF64}: The initial state.\nψ_goal::AbstractVector{<:ComplexF64}: The target state.\n\nwith\n\nT::Int: The number of timesteps.\nΔt::Float64: The timestep size.\n\nKeyword Arguments\n\nipopt_options::IpoptOptions=IpoptOptions(): The IPOPT options.\npiccolo_options::PiccoloOptions=PiccoloOptions(): The Piccolo options.\nstate_name::Symbol=:ψ̃: The name of the state variable.\ncontrol_name::Symbol=:a: The name of the control variable.\ntimestep_name::Symbol=:Δt: The name of the timestep variable.\ninit_trajectory::Union{NamedTrajectory, Nothing}=nothing: The initial trajectory.\na_bound::Float64=1.0: The bound on the control pulse.\na_bounds::Vector{Float64}=fill(a_bound, length(system.G_drives)): The bounds on the control pulse.\na_guess::Union{Matrix{Float64}, Nothing}=nothing: The initial guess for the control pulse.\nda_bound::Float64=Inf: The bound on the first derivative of the control pulse.\nda_bounds::Vector{Float64}=fill(da_bound, length(system.G_drives)): The bounds on the first derivative of the control pulse.\nzero_initial_and_final_derivative::Bool=false: Whether to enforce zero initial and final derivative.\ndda_bound::Float64=1.0: The bound on the second derivative of the control pulse.\ndda_bounds::Vector{Float64}=fill(dda_bound, length(system.G_drives)): The bounds on the second derivative of the control pulse.\nΔt_min::Float64=0.5 * Δt: The minimum timestep size.\nΔt_max::Float64=1.5 * Δt: The maximum timestep size.\ndrive_derivative_σ::Float64=0.01: The standard deviation of the drive derivative random initialization.\nQ::Float64=100.0: The weight on the state objective.\nR=1e-2: The weight on the control pulse and its derivatives.\nR_a::Union{Float64, Vector{Float64}}=R: The weight on the control pulse.\nR_da::Union{Float64, Vector{Float64}}=R: The weight on the first derivative of the control pulse.\nR_dda::Union{Float64, Vector{Float64}}=R: The weight on the second derivative of the control pulse.\nleakage_operator::Union{Nothing, EmbeddedOperator}=nothing: The leakage operator, if leakage suppression is desired.\nconstraints::Vector{<:AbstractConstraint}=AbstractConstraint[]: The constraints.\n\n\n\n\n\n","category":"function"},{"location":"lib/#QuantumCollocation.ProblemTemplates.UnitaryBangBangProblem","page":"Library","title":"QuantumCollocation.ProblemTemplates.UnitaryBangBangProblem","text":"UnitaryBangBangProblem(system::QuantumSystem, operator, T, Δt; kwargs...)\nUnitaryBangBangProblem(H_drift, H_drives, operator, T, Δt; kwargs...)\n\nConstruct a QuantumControlProblem for a free-time unitary gate problem with bang-bang control pulses.\n\nbeginaligned\nundersetvectildeU a dota Delta ttextminimize  quad\nQ cdot ellqty(vectildeU_T vectildeU_textgoal) + R_textbang-bang cdot sum_t dota_t \ntext subject to   quad vbP^(n)qty(vectildeU_t+1 vectildeU_t a_t Delta t_t) = 0 \n quad a_t+1 - a_t - dota_t Delta t_t = 0 \n quad a_t leq a_textbound \n quad dota_t leq da_textbound \n quad Delta t_textmin leq Delta t_t leq Delta t_textmax \nendaligned\n\nwhere, for U in SU(N),\n\nellqty(vectildeU_T vectildeU_textgoal) =\nabs1 - frac1N abs tr qty(U_textgoal U_T) \n\nis the infidelity objective function, Q is a weight, R_a, and R_dota are weights on the regularization terms, and vbP^(n) is the nth-order Pade integrator.\n\nTODO: Document bang-bang modification.\n\nArguments\n\nH_drift::AbstractMatrix{<:Number}: the drift hamiltonian\nH_drives::Vector{<:AbstractMatrix{<:Number}}: the control hamiltonians\n\nor\n\nsystem::QuantumSystem: the system to be controlled\n\nwith\n\noperator::AbstractPiccoloOperator: the target unitary, either in the form of an EmbeddedOperator or a `Matrix{ComplexF64}\nT::Int: the number of timesteps\nΔt::Float64: the (initial) time step size\n\nKeyword Arguments\n\nipopt_options::IpoptOptions=IpoptOptions(): the options for the Ipopt solver\npiccolo_options::PiccoloOptions=PiccoloOptions(): the options for the Piccolo solver\nstate_name::Symbol = :Ũ⃗: the name of the state variable\ncontrol_name::Symbol = :a: the name of the control variable\ntimestep_name::Symbol = :Δt: the name of the timestep variable\ninit_trajectory::Union{NamedTrajectory, Nothing}=nothing: an initial trajectory to use\na_bound::Float64=1.0: the bound on the control pulse\na_bounds=fill(a_bound, length(system.G_drives)): the bounds on the control pulses, one for each drive\na_guess::Union{Matrix{Float64}, Nothing}=nothing: an initial guess for the control pulses\nda_bound::Float64=1.0: the bound on the control pulse derivative\nda_bounds=fill(da_bound, length(system.G_drives)): the bounds on the control pulse derivatives, one for each drive\nΔt_min::Float64=Δt isa Float64 ? 0.5 * Δt : 0.5 * mean(Δt): the minimum time step size\nΔt_max::Float64=Δt isa Float64 ? 1.5 * Δt : 1.5 * mean(Δt): the maximum time step size\ndrive_derivative_σ::Float64=0.01: the standard deviation of the initial guess for the control pulse derivatives\nQ::Float64=100.0: the weight on the infidelity objective\nR=1e-2: the weight on the regularization terms\nquadratic_control_regularization=false: whether or not to use quadratic regularization for the control pulses\nR_a::Union{Float64, Vector{Float64}}=R: the weight on the regularization term for the control pulses\nR_da::Union{Float64, Vector{Float64}}=R: the weight on the regularization term for the control pulse derivatives\nR_bang_bang::Union{Float64, Vector{Float64}}=1e-1: the weight on the bang-bang regularization term\nphase_operators::Union{AbstractVector{<:AbstractMatrix}, Nothing}=nothing: the phase operators for free phase corrections\nconstraints::Vector{<:AbstractConstraint}=AbstractConstraint[]: the constraints to enforce\n\n\n\n\n\n","category":"function"},{"location":"lib/#QuantumCollocation.ProblemTemplates.UnitaryDirectSumProblem-Tuple{AbstractVector{<:QuantumControlProblem}, Real}","page":"Library","title":"QuantumCollocation.ProblemTemplates.UnitaryDirectSumProblem","text":"UnitaryDirectSumProblem(probs, final_fidelity; kwargs...)\n\nConstruct a QuantumControlProblem as a direct sum of unitary gate problems. The purpose is to find solutions that are as close as possible with respect to one of their components. In particular, this is useful for finding interpolatable control solutions.\n\nA graph of edges (specified by problem labels) will enforce a PairwiseQuadraticRegularizer between the component trajectories of the problem in probs corresponding to the names of the edge in edges with corresponding edge weight Q.\n\nBoundary values can be included to enforce a QuadraticRegularizer on edges where one of the nodes is not optimized. The boundary values are specified as a dictionary with keys corresponding to the edge labels and values corresponding to the boundary values.\n\nThe default behavior is to use a 1D chain for the graph, i.e., enforce a PairwiseQuadraticRegularizer between each neighbor of the provided probs.\n\nArguments\n\nprobs::AbstractVector{<:QuantumControlProblem}: the problems to combine\nfinal_fidelity::Real: the fidelity to enforce between the component final unitaries and the component goal unitaries\n\nKeyword Arguments\n\nprob_labels::AbstractVector{<:String}}: the labels for the problems\ngraph::Union{Nothing, AbstractVector{<:Tuple{String, String}}, AbstractVector{<:Tuple{Symbol, Symbol}}}`: the graph of edges to enforce\nboundary_values::Union{Nothing, AbstractDict{<:String, <:AbstractArray}, AbstractDict{<:Symbol, <:AbstractVector}}=nothing: the boundary values for the problems\nQ::Union{Float64, Vector{Float64}}=100.0: the weights on the pairwise regularizers\nQ_symb::Symbol=:Ũ⃗: the symbol to use for the regularizer\nR::Float64=1e-2: the shared weight on all control terms (:a, :da, :dda is assumed)\nR_a::Union{Float64, Vector{Float64}}=R: the weight on the regularization term for the control pulses\nR_da::Union{Float64, Vector{Float64}}=R: the weight on the regularization term for the control pulse derivatives\nR_dda::Union{Float64, Vector{Float64}}=R: the weight on the regularization term for the control pulse second derivatives\nR_b::Union{Float64, Vector{Float64}}=R: the weight on the regularization term for the boundary values\ndrive_derivative_σ::Float64=0.01: the standard deviation of the initial guess for the control pulse derivatives\ndrive_reset_ratio::Float64=0.1: amount of random noise to add to the control data (can help avoid hitting restoration if provided problems are converged)\nfidelity_cost::Bool=false: whether or not to include a fidelity cost in the objective\nsubspace::Union{AbstractVector{<:Integer}, Nothing}=nothing: the subspace to use for the fidelity of each problem\nipopt_options::IpoptOptions=IpoptOptions(): the options for the Ipopt solver\npiccolo_options::PiccoloOptions=PiccoloOptions(): the options for the Piccolo solver\n\n\n\n\n\n","category":"method"},{"location":"lib/#QuantumCollocation.ProblemTemplates.UnitaryRobustnessProblem","page":"Library","title":"QuantumCollocation.ProblemTemplates.UnitaryRobustnessProblem","text":"UnitaryRobustnessProblem(\n    H_error,\n    trajectory,\n    system,\n    objective,\n    integrators,\n    constraints;\n    kwargs...\n)\n\nUnitaryRobustnessProblem(Hₑ, prob::QuantumControlProblem; kwargs...)\n\nCreate a quantum control problem for robustness optimization of a unitary trajectory.\n\nKeyword Arguments\n\nunitary_name::Symbol=:Ũ⃗: The symbol for the unitary trajectory in trajectory.\nfinal_fidelity::Union{Real, Nothing}=nothing: The target fidelity for the final unitary.\nipopt_options::IpoptOptions=IpoptOptions(): Options for the Ipopt solver.\npiccolo_options::PiccoloOptions=PiccoloOptions(): Options for the Piccolo solver.\nkwargs...: Additional keyword arguments passed to QuantumControlProblem.\n\n\n\n\n\n","category":"function"},{"location":"lib/#QuantumCollocation.ProblemTemplates.UnitarySamplingProblem-Tuple{AbstractVector{<:AbstractQuantumSystem}, AbstractVector{<:AbstractPiccoloOperator}, Int64, Union{Float64, Vector{Float64}}}","page":"Library","title":"QuantumCollocation.ProblemTemplates.UnitarySamplingProblem","text":"UnitarySamplingProblem(systemns, operator, T, Δt; kwargs...)\n\nA UnitarySamplingProblem is a quantum control problem where the goal is to find a control pulse that generates a target unitary operator for a set of quantum systems. The controls are shared among all systems, and the optimization seeks to find the control pulse that achieves the operator for each system. The idea is to enforce a robust solution by including multiple systems reflecting the problem uncertainty.\n\nArguments\n\nsystems::AbstractVector{<:AbstractQuantumSystem}: A vector of quantum systems.\noperator::AbstractPiccoloOperator: The target unitary operator.\nT::Int: The number of time steps.\nΔt::Union{Float64, Vector{Float64}}: The time step value or vector of time steps.\n\nKeyword Arguments\n\nsystem_labels::Vector{String} = string.(1:length(systems)): The labels for each system.\nsystem_weights::Vector{Float64} = fill(1.0, length(systems)): The weights for each system.\ninit_trajectory::Union{NamedTrajectory, Nothing} = nothing: The initial trajectory.\nipopt_options::IpoptOptions = IpoptOptions(): The IPOPT options.\npiccolo_options::PiccoloOptions = PiccoloOptions(): The Piccolo options.\nstate_name::Symbol = :Ũ⃗: The name of the state variable.\ncontrol_name::Symbol = :a: The name of the control variable.\ntimestep_name::Symbol = :Δt: The name of the timestep variable.\nconstraints::Vector{<:AbstractConstraint} = AbstractConstraint[]: The constraints.\na_bound::Float64 = 1.0: The bound for the control amplitudes.\na_bounds::Vector{Float64} = fill(a_bound, length(systems[1].G_drives)): The bounds for the control amplitudes.\na_guess::Union{Matrix{Float64}, Nothing} = nothing: The initial guess for the control amplitudes.\nda_bound::Float64 = Inf: The bound for the control first derivatives.\nda_bounds::Vector{Float64} = fill(da_bound, length(systems[1].G_drives)): The bounds for the control first derivatives.\ndda_bound::Float64 = 1.0: The bound for the control second derivatives.\ndda_bounds::Vector{Float64} = fill(dda_bound, length(systems[1].G_drives)): The bounds for the control second derivatives.\nΔt_min::Float64 = 0.5 * Δt: The minimum time step size.\nΔt_max::Float64 = 1.5 * Δt: The maximum time step size.\nQ::Float64 = 100.0: The fidelity weight.\nR::Float64 = 1e-2: The regularization weight.\nR_a::Union{Float64, Vector{Float64}} = R: The regularization weight for the control amplitudes.\nR_da::Union{Float64, Vector{Float64}} = R: The regularization weight for the control first derivatives.\nR_dda::Union{Float64, Vector{Float64}} = R: The regularization weight for the control second derivatives.\nkwargs...: Additional keyword arguments.\n\n\n\n\n\n","category":"method"},{"location":"lib/#QuantumCollocation.ProblemTemplates.UnitarySmoothPulseProblem-Tuple{AbstractQuantumSystem, AbstractPiccoloOperator, Int64, Union{Float64, AbstractVector{Float64}}}","page":"Library","title":"QuantumCollocation.ProblemTemplates.UnitarySmoothPulseProblem","text":"UnitarySmoothPulseProblem(system::AbstractQuantumSystem, operator, T, Δt; kwargs...)\nUnitarySmoothPulseProblem(H_drift, H_drives, operator, T, Δt; kwargs...)\n\nConstruct a QuantumControlProblem for a free-time unitary gate problem with smooth control pulses enforced by constraining the second derivative of the pulse trajectory, i.e.,\n\nbeginaligned\nundersetvectildeU a dota ddota Delta ttextminimize  quad\nQ cdot ellqty(vectildeU_T vectildeU_textgoal) + frac12 sum_t qty(R_a a_t^2 + R_dota dota_t^2 + R_ddota ddota_t^2) \ntext subject to   quad vbP^(n)qty(vectildeU_t+1 vectildeU_t a_t Delta t_t) = 0 \n quad a_t+1 - a_t - dota_t Delta t_t = 0 \n quad dota_t+1 - dota_t - ddota_t Delta t_t = 0 \n quad a_t leq a_textbound \n quad ddota_t leq ddota_textbound \n quad Delta t_textmin leq Delta t_t leq Delta t_textmax \nendaligned\n\nwhere, for U in SU(N),\n\nellqty(vectildeU_T vectildeU_textgoal) =\nabs1 - frac1N abs tr qty(U_textgoal U_T) \n\nis the infidelity objective function, Q is a weight, R_a, R_dota, and R_ddota are weights on the regularization terms, and vbP^(n) is the nth-order Pade integrator.\n\nArguments\n\nsystem::AbstractQuantumSystem: the system to be controlled\n\nor\n\nH_drift::AbstractMatrix{<:Number}: the drift hamiltonian\nH_drives::Vector{<:AbstractMatrix{<:Number}}: the control hamiltonians\n\nwith\n\noperator::AbstractPiccoloOperator: the target unitary, either in the form of an EmbeddedOperator or a `Matrix{ComplexF64}\nT::Int: the number of timesteps\nΔt::Float64: the (initial) time step size\n\nKeyword Arguments\n\nipopt_options::IpoptOptions=IpoptOptions(): the options for the Ipopt solver\npiccolo_options::PiccoloOptions=PiccoloOptions(): the options for the Piccolo solver\nstate_name::Symbol = :Ũ⃗: the name of the state\ncontrol_name::Symbol = :a: the name of the control\ntimestep_name::Symbol = :Δt: the name of the timestep\ninit_trajectory::Union{NamedTrajectory, Nothing}=nothing: an initial trajectory to use\na_bound::Float64=1.0: the bound on the control pulse\na_bounds::Vector{Float64}=fill(a_bound, length(system.G_drives)): the bounds on the control pulses, one for each drive\na_guess::Union{Matrix{Float64}, Nothing}=nothing: an initial guess for the control pulses\nda_bound::Float64=Inf: the bound on the control pulse derivative\nda_bounds::Vector{Float64}=fill(da_bound, length(system.G_drives)): the bounds on the control pulse derivatives, one for each drive\nzero_initial_and_final_derivative::Bool=false: whether to enforce zero initial and final control pulse derivatives\ndda_bound::Float64=1.0: the bound on the control pulse second derivative\ndda_bounds::Vector{Float64}=fill(dda_bound, length(system.G_drives)): the bounds on the control pulse second derivatives, one for each drive\nΔt_min::Float64=Δt isa Float64 ? 0.5 * Δt : 0.5 * mean(Δt): the minimum time step size\nΔt_max::Float64=Δt isa Float64 ? 1.5 * Δt : 1.5 * mean(Δt): the maximum time step size\nQ::Float64=100.0: the weight on the infidelity objective\nR=1e-2: the weight on the regularization terms\nR_a::Union{Float64, Vector{Float64}}=R: the weight on the regularization term for the control pulses\nR_da::Union{Float64, Vector{Float64}}=R: the weight on the regularization term for the control pulse derivatives\nR_dda::Union{Float64, Vector{Float64}}=R: the weight on the regularization term for the control pulse second derivatives\nphase_name::Symbol=:ϕ: the name of the phase\nphase_operators::Union{AbstractVector{<:AbstractMatrix}, Nothing}=nothing: the phase operators for free phase corrections\nconstraints::Vector{<:AbstractConstraint}=AbstractConstraint[]: the constraints to enforce\n\n\n\n\n\n","category":"method"},{"location":"lib/#Direct-Sums","page":"Library","title":"Direct Sums","text":"","category":"section"},{"location":"lib/","page":"Library","title":"Library","text":"Modules = [QuantumCollocation.DirectSums]","category":"page"},{"location":"lib/#QuantumCollocation.DirectSums.direct_sum-Tuple{AbstractMatrix, AbstractMatrix}","page":"Library","title":"QuantumCollocation.DirectSums.direct_sum","text":"direct_sum(A::AbstractMatrix, B::AbstractMatrix)\n\nReturns the direct sum of two matrices.\n\n\n\n\n\n","category":"method"},{"location":"lib/#QuantumCollocation.DirectSums.direct_sum-Tuple{AbstractVector, AbstractVector}","page":"Library","title":"QuantumCollocation.DirectSums.direct_sum","text":"direct_sum(Ã⃗::AbstractVector, B̃⃗::AbstractVector)\n\nReturns the direct sum of two iso_vec operators.\n\n\n\n\n\n","category":"method"},{"location":"lib/#QuantumCollocation.DirectSums.direct_sum-Tuple{QuantumSystem, QuantumSystem}","page":"Library","title":"QuantumCollocation.DirectSums.direct_sum","text":"direct_sum(sys1::QuantumSystem, sys2::QuantumSystem)\n\nReturns the direct sum of two QuantumSystem objects.\n\n\n\n\n\n","category":"method"},{"location":"lib/#QuantumCollocation.DirectSums.direct_sum-Tuple{SparseArrays.SparseMatrixCSC, SparseArrays.SparseMatrixCSC}","page":"Library","title":"QuantumCollocation.DirectSums.direct_sum","text":"direct_sum(A::SparseMatrixCSC, B::SparseMatrixCSC)\n\nReturns the direct sum of two sparse matrices.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Options","page":"Library","title":"Options","text":"","category":"section"},{"location":"lib/","page":"Library","title":"Library","text":"Modules = [QuantumCollocation.Options]","category":"page"},{"location":"lib/#QuantumCollocationCore.Options.IpoptOptions","page":"Library","title":"QuantumCollocationCore.Options.IpoptOptions","text":"Solver options for Ipopt\n\nhttps://coin-or.github.io/Ipopt/OPTIONS.html#OPT_print_options_documentation\n\n\n\n\n\n","category":"type"},{"location":"lib/#QuantumCollocationCore.Options.PiccoloOptions","page":"Library","title":"QuantumCollocationCore.Options.PiccoloOptions","text":"PiccoloOptions\n\nOptions for the Piccolo quantum optimal control library.\n\nFields\n\nverbose::Bool = true: Print verbose output\nverbose_evaluator::Bool = false: Print verbose output from the evaluator\nfree_time::Bool = true: Allow free time optimization\ntimesteps_all_equal::Bool = true: Use equal timesteps\nintegrator::Symbol = :pade: Integrator to use\npade_order::Int = 4: Order of the Pade approximation\nrollout_integrator::Function = expv: Integrator to use for rollout\njacobian_structure::Bool = integrator == :pade: Use the integrator's Jacobian structure\neval_hessian::Bool = false: Evaluate the Hessian\ngeodesic = true: Use the geodesic to initialize the optimization.\nblas_multithreading::Bool = true: Use BLAS multithreading.\nbuild_trajectory_constraints::Bool = true: Build trajectory constraints.\ncomplex_control_norm_constraint_name::Union{Nothing, Symbol} = nothing: Name of the complex control norm constraint.\ncomplex_control_norm_constraint_radius::Float64 = 1.0: Radius of the complex control norm constraint.\nbound_state::Bool = false: Bound the state.\nleakage_suppression::Bool = false: Suppress leakage.\nR_leakage::Float64 = 1.0: Leakage suppression parameter.\nfree_phase_infidelity::Bool = false: Free phase infidelity.\nphase_operators::Union{Nothing, AbstractVector{<:AbstractMatrix{<:Complex}}} = nothing: Phase operators.\nphase_name::Symbol = :ϕ: Name of the phase.\n\n\n\n\n\n","category":"type"},{"location":"lib/#Plotting","page":"Library","title":"Plotting","text":"","category":"section"},{"location":"lib/","page":"Library","title":"Library","text":"Modules = [QuantumCollocation.Plotting]","category":"page"},{"location":"lib/#Problem-Solvers","page":"Library","title":"Problem Solvers","text":"","category":"section"},{"location":"lib/","page":"Library","title":"Library","text":"Modules = [QuantumCollocation.ProblemSolvers]","category":"page"},{"location":"lib/#QuantumCollocationCore.ProblemSolvers.solve!-Tuple{QuantumControlProblem}","page":"Library","title":"QuantumCollocationCore.ProblemSolvers.solve!","text":"solve!(prob::QuantumControlProblem;         inittraj=nothing,         savepath=nothing,         maxiter=prob.ipoptoptions.maxiter,         linearsolver=prob.ipoptoptions.linearsolver,         printlevel=prob.ipoptoptions.printlevel,         removeslackvariables=false,         callback=nothing         # statetype=:unitary,         # print_fidelity=false,     )\n\nCall optimization solver to solve the quantum control problem with parameters and callbacks.\n\nArguments\n\nprob::QuantumControlProblem: The quantum control problem to solve.\ninit_traj::NamedTrajectory: Initial guess for the control trajectory. If not provided, a random guess will be generated.\nsave_path::String: Path to save the problem after optimization.\nmax_iter::Int: Maximum number of iterations for the optimization solver.\nlinear_solver::String: Linear solver to use for the optimization solver (e.g., \"mumps\", \"paradiso\", etc).\nprint_level::Int: Verbosity level for the solver.\nremove_slack_variables::Bool: Remove slack variables from the trajectory after optimization.\ncallback::Function: Callback function to call during optimization steps.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Rollouts","page":"Library","title":"Rollouts","text":"","category":"section"},{"location":"lib/","page":"Library","title":"Library","text":"Modules = [QuantumCollocation.Rollouts]","category":"page"},{"location":"lib/#QuantumCollocation.Rollouts.infer_is_evp-Tuple{Function}","page":"Library","title":"QuantumCollocation.Rollouts.infer_is_evp","text":"infer_is_evp(integrator::Function)\n\nInfer whether the integrator is a exponential-vector product (EVP) function.\n\nIf true, the integrator is expected to have a signature like the exponential action, expv. Otherwise, it is expected to have a signature like exp.\n\n\n\n\n\n","category":"method"},{"location":"lib/#QuantumCollocation.Rollouts.lab_frame_unitary_rollout-Tuple{AbstractQuantumSystem, AbstractMatrix{Float64}}","page":"Library","title":"QuantumCollocation.Rollouts.lab_frame_unitary_rollout","text":"lab_frame_unitary_rollout(\n    sys::AbstractQuantumSystem,\n    controls::AbstractMatrix{Float64};\n    duration=nothing,\n    timestep=nothing,\n    ω=nothing,\n    timestep_nyquist=1 / (50 * ω)\n)\n\n\n\n\n\n","category":"method"},{"location":"lib/#QuantumCollocation.Rollouts.rollout-Tuple{AbstractVector{<:Real}, AbstractMatrix, AbstractVector, AbstractQuantumSystem}","page":"Library","title":"QuantumCollocation.Rollouts.rollout","text":"rollout(\n    ψ̃_init::AbstractVector{<:Float64},\n    controls::AbstractMatrix,\n    Δt::AbstractVector,\n    system::AbstractQuantumSystem\n)\n\nRollout a quantum state ψ̃_init under the control controls for a time Δt using the system system.\n\nIf exp_vector_product is true, the integrator is expected to have a signature like the exponential action, expv. Otherwise, it is expected to have a signature like exp.\n\nTypes should allow for autodifferentiable controls and times.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Saving-and-Loading","page":"Library","title":"Saving and Loading","text":"","category":"section"},{"location":"lib/","page":"Library","title":"Library","text":"Modules = [QuantumCollocation.SaveLoadUtils]","category":"page"},{"location":"lib/#Trajectory-Initialization","page":"Library","title":"Trajectory Initialization","text":"","category":"section"},{"location":"lib/","page":"Library","title":"Library","text":"Modules = [QuantumCollocation.TrajectoryInitialization]","category":"page"},{"location":"lib/#QuantumCollocation.TrajectoryInitialization.initialize_trajectory-Tuple{AbstractPiccoloOperator, Int64, Union{Real, AbstractVecOrMat{<:Real}}, Vararg{Any}}","page":"Library","title":"QuantumCollocation.TrajectoryInitialization.initialize_trajectory","text":"initialize_trajectory\n\nTrajectory initialization of unitaries.\n\n\n\n\n\n","category":"method"},{"location":"lib/#QuantumCollocation.TrajectoryInitialization.initialize_trajectory-Tuple{AbstractVector{<:AbstractVector{ComplexF64}}, AbstractVector{<:AbstractVector{ComplexF64}}, Int64, Union{Real, AbstractVector{<:Real}}, Vararg{Any}}","page":"Library","title":"QuantumCollocation.TrajectoryInitialization.initialize_trajectory","text":"initialize_trajectory\n\nTrajectory initialization of quantum states.\n\n\n\n\n\n","category":"method"},{"location":"lib/#QuantumCollocation.TrajectoryInitialization.initialize_trajectory-Tuple{Vector{<:AbstractMatrix{Float64}}, Vector{<:AbstractVector{Float64}}, Vector{<:AbstractVector{Float64}}, AbstractVector{Symbol}, Int64, Union{Float64, AbstractVecOrMat{<:Float64}}, Int64, Tuple{Vararg{Union{Tuple{AbstractVector{R}, AbstractVector{R}}, AbstractVector{R}} where R<:Real}}}","page":"Library","title":"QuantumCollocation.TrajectoryInitialization.initialize_trajectory","text":"initialize_trajectory\n\nInitialize a trajectory for a control problem. The trajectory is initialized with data that should be consistently the same type (in this case, Float64).\n\n\n\n\n\n","category":"method"},{"location":"lib/#QuantumCollocation.TrajectoryInitialization.unitary_geodesic","page":"Library","title":"QuantumCollocation.TrajectoryInitialization.unitary_geodesic","text":"unitary_geodesic(\n    operator::EmbeddedOperator,\n    samples::Int;\n    kwargs...\n)\n\nunitary_geodesic(\n    U_goal::AbstractMatrix{<:Number},\n    samples::Int;\n    kwargs...\n)\n\nunitary_geodesic(\n    U₀::AbstractMatrix{<:Number},\n    U₁::AbstractMatrix{<:Number},\n    samples::Number;\n    kwargs...\n)\n\nunitary_geodesic(\n    U₀::AbstractMatrix{<:Number},\n    U₁::AbstractMatrix{<:Number},\n    timesteps::AbstractVector{<:Number};\n    return_generator=false\n)\n\nCompute a geodesic connecting two unitary operators.\n\n\n\n\n\n","category":"function"},{"location":"lib/#QuantumCollocation.TrajectoryInitialization.unitary_geodesic-Tuple{AbstractMatrix{<:Number}, AbstractMatrix{<:Number}, AbstractVector{<:Number}}","page":"Library","title":"QuantumCollocation.TrajectoryInitialization.unitary_geodesic","text":"unitary_geodesic(U_init, U_goal, times; kwargs...)\n\nCompute the geodesic connecting Uinit and Ugoal at the specified times. Allows for the possibility of unequal times and ranges outside [0,1].\n\nArguments\n\nU_init::AbstractMatrix{<:Number}: The initial unitary operator.\nU_goal::AbstractMatrix{<:Number}: The goal unitary operator.\ntimes::AbstractVector{<:Number}: The times at which to evaluate the geodesic.\n\nKeyword Arguments\n\nreturn_unitary_isos::Bool=true: If true returns a matrix where each column is a unitary isovec, i.e. vec(vcat(real(U), imag(U))). If false, returns a vector of unitary matrices.\nreturn_generator::Bool=false: If true, returns the effective Hamiltonian generating the geodesic.\n\n\n\n\n\n","category":"method"},{"location":"lib/#QuantumCollocation.TrajectoryInitialization.unitary_linear_interpolation-Tuple{AbstractMatrix{<:Number}, AbstractMatrix{<:Number}, Int64}","page":"Library","title":"QuantumCollocation.TrajectoryInitialization.unitary_linear_interpolation","text":"unitary_linear_interpolation(\n    U_init::AbstractMatrix,\n    U_goal::AbstractMatrix,\n    samples::Int\n)\n\nCompute a linear interpolation of unitary operators with samples samples.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Trajectory-Interpolations","page":"Library","title":"Trajectory Interpolations","text":"","category":"section"},{"location":"lib/","page":"Library","title":"Library","text":"Modules = [QuantumCollocation.TrajectoryInterpolations]","category":"page"},{"location":"generated/man/embedded_operators/","page":"Embedded Operators","title":"Embedded Operators","text":"EditURL = \"../../../literate/man/embedded_operators.jl\"","category":"page"},{"location":"generated/man/embedded_operators/","page":"Embedded Operators","title":"Embedded Operators","text":"CollapsedDocStrings = true","category":"page"},{"location":"generated/man/embedded_operators/#Embedded-Operators","page":"Embedded Operators","title":"Embedded Operators","text":"","category":"section"},{"location":"generated/man/embedded_operators/","page":"Embedded Operators","title":"Embedded Operators","text":"In this manual, we will discuss embedding operators in subspaces of larger quantum systems.","category":"page"},{"location":"generated/man/embedded_operators/#The-embed-and-unembed-functions","page":"Embedded Operators","title":"The embed and unembed functions","text":"","category":"section"},{"location":"generated/man/embedded_operators/","page":"Embedded Operators","title":"Embedded Operators","text":"A frequent situation in quantum optimal control is the need to embed a quantum operator in a larger Hilbert space. This is often necessary when the control Hamiltonian acts on a subspace of the full Hilbert space.","category":"page"},{"location":"generated/man/embedded_operators/","page":"Embedded Operators","title":"Embedded Operators","text":"The embed function allows to embed a quantum operator in a larger Hilbert space.","category":"page"},{"location":"generated/man/embedded_operators/","page":"Embedded Operators","title":"Embedded Operators","text":"embed","category":"page"},{"location":"generated/man/embedded_operators/","page":"Embedded Operators","title":"Embedded Operators","text":"The unembed function allows to unembed a quantum operator from a larger Hilbert space.","category":"page"},{"location":"generated/man/embedded_operators/","page":"Embedded Operators","title":"Embedded Operators","text":"unembed","category":"page"},{"location":"generated/man/embedded_operators/","page":"Embedded Operators","title":"Embedded Operators","text":"For example, for a single qubit X gate embedded in a multilevel system:","category":"page"},{"location":"generated/man/embedded_operators/","page":"Embedded Operators","title":"Embedded Operators","text":"using QuantumCollocation\nusing SparseArrays # for visualization\n\n# define levels of full system\nlevels = 3\n\n# get a 2-level X gate\nX = GATES[:X]\n\n# define subspace indices as lowest two levels\nsubspace_indices = 1:2\n\n# embed the X gate in the full system\nX_embedded = embed(X, subspace_indices, levels)","category":"page"},{"location":"generated/man/embedded_operators/","page":"Embedded Operators","title":"Embedded Operators","text":"We can retrieve the original operator:","category":"page"},{"location":"generated/man/embedded_operators/","page":"Embedded Operators","title":"Embedded Operators","text":"X_unembedded = unembed(X_embedded, subspace_indices)","category":"page"},{"location":"generated/man/embedded_operators/#The-EmbeddedOperator-type","page":"Embedded Operators","title":"The EmbeddedOperator type","text":"","category":"section"},{"location":"generated/man/embedded_operators/","page":"Embedded Operators","title":"Embedded Operators","text":"The EmbeddedOperator type is a convenient way to define an operator embedded in a subspace of a larger quantum system.","category":"page"},{"location":"generated/man/embedded_operators/","page":"Embedded Operators","title":"Embedded Operators","text":"The EmbeddedOperator type is defined as follows:","category":"page"},{"location":"generated/man/embedded_operators/","page":"Embedded Operators","title":"Embedded Operators","text":"EmbeddedOperator","category":"page"},{"location":"generated/man/embedded_operators/","page":"Embedded Operators","title":"Embedded Operators","text":"And can be constructed using the following method:","category":"page"},{"location":"generated/man/embedded_operators/","page":"Embedded Operators","title":"Embedded Operators","text":"EmbeddedOperator(op::Matrix{<:Number}, subspace_indices::AbstractVector{Int}, subsystem_levels::AbstractVector{Int})","category":"page"},{"location":"generated/man/embedded_operators/","page":"Embedded Operators","title":"Embedded Operators","text":"For example, for an X gate on the first qubit of two qubit, 3-level system:","category":"page"},{"location":"generated/man/embedded_operators/","page":"Embedded Operators","title":"Embedded Operators","text":"# define the target operator X ⊗ I\ngate = GATES[:X] ⊗ GATES[:I]\n\n# define the subsystem levels\nsubsystem_levels = [3, 3]\n\n# define the subspace indices\nsubspace_indices = get_subspace_indices([1:2, 1:2], subsystem_levels)\n\n# create the embedded operator\nop = EmbeddedOperator(gate, subspace_indices, subsystem_levels)\n\n# show the full operator\nop.operator .|> abs |> sparse","category":"page"},{"location":"generated/man/embedded_operators/","page":"Embedded Operators","title":"Embedded Operators","text":"We can get the original operator back:","category":"page"},{"location":"generated/man/embedded_operators/","page":"Embedded Operators","title":"Embedded Operators","text":"gate_unembeded = unembed(op)\n\ngate_unembeded .|> abs |> sparse","category":"page"},{"location":"generated/man/embedded_operators/#The-get_subspace_indices-function","page":"Embedded Operators","title":"The get_subspace_indices function","text":"","category":"section"},{"location":"generated/man/embedded_operators/","page":"Embedded Operators","title":"Embedded Operators","text":"The get_subspace_indices function is a convenient way to get the indices of a subspace in a larger quantum system.","category":"page"},{"location":"generated/man/embedded_operators/#Simple-quantum-systems","page":"Embedded Operators","title":"Simple quantum systems","text":"","category":"section"},{"location":"generated/man/embedded_operators/","page":"Embedded Operators","title":"Embedded Operators","text":"For simple (non-composite) quantum systems, such as a single multilevel qubit, we provode the following method:","category":"page"},{"location":"generated/man/embedded_operators/","page":"Embedded Operators","title":"Embedded Operators","text":"get_subspace_indices(subspace::AbstractVector{Int}, levels::Int)","category":"page"},{"location":"generated/man/embedded_operators/","page":"Embedded Operators","title":"Embedded Operators","text":"# get the indices of the lowest two levels of a 3-level system\nsubspace_indices = get_subspace_indices(1:2, 3)","category":"page"},{"location":"generated/man/embedded_operators/#Comosite-quantum-systems","page":"Embedded Operators","title":"Comosite quantum systems","text":"","category":"section"},{"location":"generated/man/embedded_operators/","page":"Embedded Operators","title":"Embedded Operators","text":"For composite quantum systems, such as a two qubit system, we provide the following methods.","category":"page"},{"location":"generated/man/embedded_operators/","page":"Embedded Operators","title":"Embedded Operators","text":"Targeting subspaces in a composite quantum system, with general subsystem levels:","category":"page"},{"location":"generated/man/embedded_operators/","page":"Embedded Operators","title":"Embedded Operators","text":"get_subspace_indices(subspaces::Vector{<:AbstractVector{Int}}, subsystem_levels::AbstractVector{Int})","category":"page"},{"location":"generated/man/embedded_operators/","page":"Embedded Operators","title":"Embedded Operators","text":"# get the subspace indices for a three level qubit coupled to a 9-level cavity\nget_subspace_indices([1:2, 1:2], [3, 9])","category":"page"},{"location":"generated/man/embedded_operators/","page":"Embedded Operators","title":"Embedded Operators","text":"Targeting subspaces in a composite quantum system, with all subsystems having the same number of levels:","category":"page"},{"location":"generated/man/embedded_operators/","page":"Embedded Operators","title":"Embedded Operators","text":"get_subspace_indices(levels::AbstractVector{Int}; subspace=1:2, kwargs...)","category":"page"},{"location":"generated/man/embedded_operators/","page":"Embedded Operators","title":"Embedded Operators","text":"# get the subspace indices for a two qubit system with 3 levels each\nget_subspace_indices([3, 3])","category":"page"},{"location":"generated/man/embedded_operators/","page":"Embedded Operators","title":"Embedded Operators","text":"","category":"page"},{"location":"generated/man/embedded_operators/","page":"Embedded Operators","title":"Embedded Operators","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/examples/two_qubit_gates/","page":"Two Qubit Gates","title":"Two Qubit Gates","text":"EditURL = \"../../../literate/examples/two_qubit_gates.jl\"","category":"page"},{"location":"generated/examples/two_qubit_gates/#Two-Qubit-Gates","page":"Two Qubit Gates","title":"Two Qubit Gates","text":"","category":"section"},{"location":"generated/examples/two_qubit_gates/","page":"Two Qubit Gates","title":"Two Qubit Gates","text":"In this example we will solve for a selection of two-qubit gates using a simple two-qubit system. We will use the UnitarySmoothPulseProblem template to solve for the optimal control fields.","category":"page"},{"location":"generated/examples/two_qubit_gates/#Defining-our-Hamiltonian","page":"Two Qubit Gates","title":"Defining our Hamiltonian","text":"","category":"section"},{"location":"generated/examples/two_qubit_gates/","page":"Two Qubit Gates","title":"Two Qubit Gates","text":"In quantum optimal control we work with Hamiltonians of the form","category":"page"},{"location":"generated/examples/two_qubit_gates/","page":"Two Qubit Gates","title":"Two Qubit Gates","text":"H(t) = H_textdrift + sum_j u^j(t) H_textdrive^j","category":"page"},{"location":"generated/examples/two_qubit_gates/","page":"Two Qubit Gates","title":"Two Qubit Gates","text":"Specifically, for a simple two-qubit system in a rotating frame, we have","category":"page"},{"location":"generated/examples/two_qubit_gates/","page":"Two Qubit Gates","title":"Two Qubit Gates","text":"H = J_12 sigma_1^x sigma_2^x + sum_i in 12 a_i^R(t) sigma^x_i over 2 + a_i^I(t) sigma^y_i over 2","category":"page"},{"location":"generated/examples/two_qubit_gates/","page":"Two Qubit Gates","title":"Two Qubit Gates","text":"where","category":"page"},{"location":"generated/examples/two_qubit_gates/","page":"Two Qubit Gates","title":"Two Qubit Gates","text":"beginalign*\nJ_12 = 0001 text GHz \na_i^R(t) leq 01 text GHz \nendalign*","category":"page"},{"location":"generated/examples/two_qubit_gates/","page":"Two Qubit Gates","title":"Two Qubit Gates","text":"And the duration of the gate will be capped at 400  mu s.","category":"page"},{"location":"generated/examples/two_qubit_gates/","page":"Two Qubit Gates","title":"Two Qubit Gates","text":"Let's now set this up using some of the convenience functions available in QuantumCollocation.jl.","category":"page"},{"location":"generated/examples/two_qubit_gates/","page":"Two Qubit Gates","title":"Two Qubit Gates","text":"using QuantumCollocation\nusing NamedTrajectories\nusing LinearAlgebra\n\n# Define our operators\nσx = GATES[:X]\nσy = GATES[:Y]\nId = GATES[:I]\n\n# Lift the operators to the two-qubit Hilbert space\nσx_1 = σx ⊗ Id\nσx_2 = Id ⊗ σx\n\nσy_1 = σy ⊗ Id\nσy_2 = Id ⊗ σy\n\n# Define the parameters of the Hamiltonian\nJ_12 = 0.001 # GHz\na_bound = 0.100 # GHz\n\n# Define the drift (coupling) Hamiltonian\nH_drift = J_12 * (σx ⊗ σx)\n\n# Define the control Hamiltonians\nH_drives = [σx_1 / 2, σy_1 / 2, σx_2 / 2, σy_2 / 2]\n\n# Define control (and higher derivative) bounds\na_bound = 0.1\nda_bound = 0.0005\ndda_bound = 0.0025\n\n# Scale the Hamiltonians by 2π\nH_drift *= 2π\nH_drives .*= 2π\n\n# Define the time parameters\nT = 100 # timesteps\nduration = 100 # μs\nΔt = duration / T\nΔt_max = 400 / T\n\n# Define the system\nsys = QuantumSystem(H_drift, H_drives)\n\n# Look at max eigenvalue of the generator (for deciding if Pade integrators are viable)\nmaximum(abs.(eigvals(Δt_max * (H_drift + sum(a_bound .* H_drives)))))","category":"page"},{"location":"generated/examples/two_qubit_gates/","page":"Two Qubit Gates","title":"Two Qubit Gates","text":"That this value above is greater than one means that we must use an exponential integrator for these problems. We can set the kwarg integrator=:exponential in the PiccoloOptions struct as follows.","category":"page"},{"location":"generated/examples/two_qubit_gates/","page":"Two Qubit Gates","title":"Two Qubit Gates","text":"piccolo_options = PiccoloOptions(\n    integrator=:exponential,\n)","category":"page"},{"location":"generated/examples/two_qubit_gates/#SWAP-gate","page":"Two Qubit Gates","title":"SWAP gate","text":"","category":"section"},{"location":"generated/examples/two_qubit_gates/","page":"Two Qubit Gates","title":"Two Qubit Gates","text":"# Define the goal operation\nU_goal = [\n    1 0 0 0;\n    0 0 1 0;\n    0 1 0 0;\n    0 0 0 1\n] |> Matrix{ComplexF64}\n\n# Set up and solve the problem\n\nprob = UnitarySmoothPulseProblem(\n    sys,\n    U_goal,\n    T,\n    Δt;\n    a_bound=a_bound,\n    da_bound=da_bound,\n    dda_bound=dda_bound,\n    R_da=0.01,\n    R_dda=0.01,\n    Δt_max=Δt_max,\n    piccolo_options=piccolo_options\n)\n\nsolve!(prob; max_iter=100)\n\n# Let's take a look at the final fidelity\nunitary_rollout_fidelity(prob)","category":"page"},{"location":"generated/examples/two_qubit_gates/","page":"Two Qubit Gates","title":"Two Qubit Gates","text":"Looks good!","category":"page"},{"location":"generated/examples/two_qubit_gates/","page":"Two Qubit Gates","title":"Two Qubit Gates","text":"Now let's plot the pulse and the population trajectories for the first two columns of the unitary, i.e. initial state of ket00 and ket01. For this we provide the function plot_unitary_populations.","category":"page"},{"location":"generated/examples/two_qubit_gates/","page":"Two Qubit Gates","title":"Two Qubit Gates","text":"plot_unitary_populations(prob)","category":"page"},{"location":"generated/examples/two_qubit_gates/","page":"Two Qubit Gates","title":"Two Qubit Gates","text":"For fun, let's look at a minimum time pulse for this problem","category":"page"},{"location":"generated/examples/two_qubit_gates/","page":"Two Qubit Gates","title":"Two Qubit Gates","text":"min_time_prob = UnitaryMinimumTimeProblem(prob; final_fidelity=.99)\n\nsolve!(min_time_prob; max_iter=300)\n\nunitary_rollout_fidelity(min_time_prob)","category":"page"},{"location":"generated/examples/two_qubit_gates/","page":"Two Qubit Gates","title":"Two Qubit Gates","text":"And let's plot this solution","category":"page"},{"location":"generated/examples/two_qubit_gates/","page":"Two Qubit Gates","title":"Two Qubit Gates","text":"plot_unitary_populations(min_time_prob)","category":"page"},{"location":"generated/examples/two_qubit_gates/","page":"Two Qubit Gates","title":"Two Qubit Gates","text":"It looks like our pulse derivative bounds are holding back the solution, but regardless, the duration has decreased:","category":"page"},{"location":"generated/examples/two_qubit_gates/","page":"Two Qubit Gates","title":"Two Qubit Gates","text":"get_duration(prob.trajectory) - get_duration(min_time_prob.trajectory)","category":"page"},{"location":"generated/examples/two_qubit_gates/#Mølmer–Sørensen-gate","page":"Two Qubit Gates","title":"Mølmer–Sørensen gate","text":"","category":"section"},{"location":"generated/examples/two_qubit_gates/","page":"Two Qubit Gates","title":"Two Qubit Gates","text":"Here we will solve for a Mølmer–Sørensen gate between two. The gate is generally described, for N qubits, by the unitary matrix","category":"page"},{"location":"generated/examples/two_qubit_gates/","page":"Two Qubit Gates","title":"Two Qubit Gates","text":"U_textMS(vectheta) = expleft(isum_j=1^N-1sum_k=j+1^Ntheta_jksigma_j^xsigma_k^xright)","category":"page"},{"location":"generated/examples/two_qubit_gates/","page":"Two Qubit Gates","title":"Two Qubit Gates","text":"where sigma_j^x is the Pauli-X operator acting on the j-th qubit, and vectheta is a vector of real parameters. The Mølmer–Sørensen gate is a two-qubit gate that is particularly well-suited for trapped-ion qubits, where the interaction between qubits is mediated.","category":"page"},{"location":"generated/examples/two_qubit_gates/","page":"Two Qubit Gates","title":"Two Qubit Gates","text":"Here we will focus on the simplest case of a Mølmer–Sørensen gate between two qubits. The gate is described by the unitary matrix","category":"page"},{"location":"generated/examples/two_qubit_gates/","page":"Two Qubit Gates","title":"Two Qubit Gates","text":"U_textMSleft(pi over 4right) = expleft(ifracpi4sigma_1^xsigma_2^xright)","category":"page"},{"location":"generated/examples/two_qubit_gates/","page":"Two Qubit Gates","title":"Two Qubit Gates","text":"Let's set up the problem.","category":"page"},{"location":"generated/examples/two_qubit_gates/","page":"Two Qubit Gates","title":"Two Qubit Gates","text":"# Define the goal operation\nU_goal = exp(im * π/4 * σx_1 * σx_2)\n\n# Set up and solve the problem\n\nprob = UnitarySmoothPulseProblem(\n    sys,\n    U_goal,\n    T,\n    Δt;\n    a_bound=a_bound,\n    da_bound=da_bound,\n    dda_bound=dda_bound,\n    R_da=0.01,\n    R_dda=0.01,\n    Δt_max=Δt_max,\n    piccolo_options=piccolo_options\n)\n\nsolve!(prob; max_iter=1_000)\n\n# Let's take a look at the final fidelity\nunitary_rollout_fidelity(prob)","category":"page"},{"location":"generated/examples/two_qubit_gates/","page":"Two Qubit Gates","title":"Two Qubit Gates","text":"Again, looks good!","category":"page"},{"location":"generated/examples/two_qubit_gates/","page":"Two Qubit Gates","title":"Two Qubit Gates","text":"Now let's plot the pulse and the population trajectories for the first two columns of the unitary, i.e. initial state of ket00 and ket01.","category":"page"},{"location":"generated/examples/two_qubit_gates/","page":"Two Qubit Gates","title":"Two Qubit Gates","text":"plot_unitary_populations(prob)","category":"page"},{"location":"generated/examples/two_qubit_gates/","page":"Two Qubit Gates","title":"Two Qubit Gates","text":"For fun, let's look at a minimum time pulse for this problem","category":"page"},{"location":"generated/examples/two_qubit_gates/","page":"Two Qubit Gates","title":"Two Qubit Gates","text":"min_time_prob = UnitaryMinimumTimeProblem(prob; final_fidelity=.999)\n\nsolve!(min_time_prob; max_iter=300)\n\nunitary_rollout_fidelity(min_time_prob)","category":"page"},{"location":"generated/examples/two_qubit_gates/","page":"Two Qubit Gates","title":"Two Qubit Gates","text":"And let's plot this solution","category":"page"},{"location":"generated/examples/two_qubit_gates/","page":"Two Qubit Gates","title":"Two Qubit Gates","text":"plot_unitary_populations(min_time_prob)","category":"page"},{"location":"generated/examples/two_qubit_gates/","page":"Two Qubit Gates","title":"Two Qubit Gates","text":"It looks like our pulse derivative bounds are holding back the solution, but regardless, the duration has decreased:","category":"page"},{"location":"generated/examples/two_qubit_gates/","page":"Two Qubit Gates","title":"Two Qubit Gates","text":"get_duration(prob.trajectory) - get_duration(min_time_prob.trajectory)","category":"page"},{"location":"generated/examples/two_qubit_gates/","page":"Two Qubit Gates","title":"Two Qubit Gates","text":"","category":"page"},{"location":"generated/examples/two_qubit_gates/","page":"Two Qubit Gates","title":"Two Qubit Gates","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/examples/multilevel_transmon/","page":"Multilevel Transmon","title":"Multilevel Transmon","text":"EditURL = \"../../../literate/examples/multilevel_transmon.jl\"","category":"page"},{"location":"generated/examples/multilevel_transmon/#Multilevel-Transmon","page":"Multilevel Transmon","title":"Multilevel Transmon","text":"","category":"section"},{"location":"generated/examples/multilevel_transmon/","page":"Multilevel Transmon","title":"Multilevel Transmon","text":"In this example we will look at a multilevel transmon qubit with a Hamiltonian given by","category":"page"},{"location":"generated/examples/multilevel_transmon/","page":"Multilevel Transmon","title":"Multilevel Transmon","text":"hatH(t) = -fracdelta2 hatn(hatn - 1) + u_1(t) (hata + hata^dagger) + u_2(t) i (hata - hata^dagger)","category":"page"},{"location":"generated/examples/multilevel_transmon/","page":"Multilevel Transmon","title":"Multilevel Transmon","text":"where hatn = hata^dagger hata is the number operator, hata is the annihilation operator, delta is the anharmonicity, and u_1(t) and u_2(t) are control fields.","category":"page"},{"location":"generated/examples/multilevel_transmon/","page":"Multilevel Transmon","title":"Multilevel Transmon","text":"We will use the following parameter values:","category":"page"},{"location":"generated/examples/multilevel_transmon/","page":"Multilevel Transmon","title":"Multilevel Transmon","text":"beginaligned\ndelta = 02 text GHz\nabsu_i(t) leq 02 text GHz\nT_0 = 10 text ns\nendaligned","category":"page"},{"location":"generated/examples/multilevel_transmon/","page":"Multilevel Transmon","title":"Multilevel Transmon","text":"For convenience, we have defined the TransmonSystem function in the QuantumSystemTemplates module, which returns a QuantumSystem object for a transmon qubit. We will use this function to define the system.","category":"page"},{"location":"generated/examples/multilevel_transmon/#Setting-up-the-problem","page":"Multilevel Transmon","title":"Setting up the problem","text":"","category":"section"},{"location":"generated/examples/multilevel_transmon/","page":"Multilevel Transmon","title":"Multilevel Transmon","text":"To begin, let's load the necessary packages, define the system parameters, and create a a QuantumSystem object using the TransmonSystem function.","category":"page"},{"location":"generated/examples/multilevel_transmon/","page":"Multilevel Transmon","title":"Multilevel Transmon","text":"using QuantumCollocation\nusing NamedTrajectories\nusing LinearAlgebra\nusing SparseArrays\nusing Random; Random.seed!(123)\n\n# define the time parameters\n\nT₀ = 10     # total time in ns\nT = 50      # number of time steps\nΔt = T₀ / T # time step\n\n# define the system parameters\nlevels = 5\nδ = 0.2\n\n# add a bound to the controls\na_bound = 0.2\n\n# create the system\nsys = TransmonSystem(levels=levels, δ=δ)\n\n# let's look at the parameters of the system\nsys.params","category":"page"},{"location":"generated/examples/multilevel_transmon/","page":"Multilevel Transmon","title":"Multilevel Transmon","text":"Since this is a multilevel transmon and we want to implement an, let's say, X gate on the qubit subspace, i.e., the first two levels we can utilize the EmbeddedOperator type to define the target operator.","category":"page"},{"location":"generated/examples/multilevel_transmon/","page":"Multilevel Transmon","title":"Multilevel Transmon","text":"# define the target operator\nop = EmbeddedOperator(:X, sys)\n\n# show the full operator\nop.operator |> sparse","category":"page"},{"location":"generated/examples/multilevel_transmon/","page":"Multilevel Transmon","title":"Multilevel Transmon","text":"In this formulation, we also use a subspace identity as the initial state, which looks like","category":"page"},{"location":"generated/examples/multilevel_transmon/","page":"Multilevel Transmon","title":"Multilevel Transmon","text":"get_subspace_identity(op) |> sparse","category":"page"},{"location":"generated/examples/multilevel_transmon/","page":"Multilevel Transmon","title":"Multilevel Transmon","text":"We can then pass this embedded operator to the UnitarySmoothPulseProblem template to create","category":"page"},{"location":"generated/examples/multilevel_transmon/","page":"Multilevel Transmon","title":"Multilevel Transmon","text":"# create the problem\nprob = UnitarySmoothPulseProblem(sys, op, T, Δt; a_bound=a_bound)\n\n# solve the problem\nsolve!(prob; max_iter=50)","category":"page"},{"location":"generated/examples/multilevel_transmon/","page":"Multilevel Transmon","title":"Multilevel Transmon","text":"Let's look at the fidelity in the subspace","category":"page"},{"location":"generated/examples/multilevel_transmon/","page":"Multilevel Transmon","title":"Multilevel Transmon","text":"println(\"Fidelity: \", unitary_rollout_fidelity(prob; subspace=op.subspace_indices))","category":"page"},{"location":"generated/examples/multilevel_transmon/","page":"Multilevel Transmon","title":"Multilevel Transmon","text":"and plot the result using the plot_unitary_populations function.","category":"page"},{"location":"generated/examples/multilevel_transmon/","page":"Multilevel Transmon","title":"Multilevel Transmon","text":"plot_unitary_populations(prob; fig_size=(900, 700))","category":"page"},{"location":"generated/examples/multilevel_transmon/#Leakage-suppresion","page":"Multilevel Transmon","title":"Leakage suppresion","text":"","category":"section"},{"location":"generated/examples/multilevel_transmon/","page":"Multilevel Transmon","title":"Multilevel Transmon","text":"As can be seen from the above plot, there is a substantial amount of leakage into the higher levels during the evolution. To mitigate this, we have implemented the ability to add a cost to populating the leakage levels, in particular this is an L_1 norm cost, which is implemented via slack variables and should ideally drive those leakage populations down to zero. To implement this, pass leakage_suppresion=true and R_leakage={value} to the UnitarySmoothPulseProblem template.","category":"page"},{"location":"generated/examples/multilevel_transmon/","page":"Multilevel Transmon","title":"Multilevel Transmon","text":"# create the a leakage suppression problem, initializing with the previous solution\n\nprob_leakage = UnitarySmoothPulseProblem(sys, op, T, Δt;\n    a_bound=a_bound,\n    leakage_suppression=true,\n    R_leakage=1e-1,\n    a_guess=prob.trajectory.a\n)\n\n# solve the problem\n\nsolve!(prob_leakage; max_iter=50)","category":"page"},{"location":"generated/examples/multilevel_transmon/","page":"Multilevel Transmon","title":"Multilevel Transmon","text":"Let's look at the fidelity in the subspace","category":"page"},{"location":"generated/examples/multilevel_transmon/","page":"Multilevel Transmon","title":"Multilevel Transmon","text":"println(\"Fidelity: \", unitary_rollout_fidelity(prob_leakage; subspace=op.subspace_indices))","category":"page"},{"location":"generated/examples/multilevel_transmon/","page":"Multilevel Transmon","title":"Multilevel Transmon","text":"and plot the result using the plot_unitary_populations function.","category":"page"},{"location":"generated/examples/multilevel_transmon/","page":"Multilevel Transmon","title":"Multilevel Transmon","text":"plot_unitary_populations(prob_leakage; fig_size=(900, 700))","category":"page"},{"location":"generated/examples/multilevel_transmon/","page":"Multilevel Transmon","title":"Multilevel Transmon","text":"Here we can see that the leakage populations have been driven substantially down.","category":"page"},{"location":"generated/examples/multilevel_transmon/","page":"Multilevel Transmon","title":"Multilevel Transmon","text":"","category":"page"},{"location":"generated/examples/multilevel_transmon/","page":"Multilevel Transmon","title":"Multilevel Transmon","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"EditURL = \"../../literate/quickstart.jl\"","category":"page"},{"location":"generated/quickstart/#Quickstart-Guide","page":"Quickstart Guide","title":"Quickstart Guide","text":"","category":"section"},{"location":"generated/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"To set up and solve a quantum optimal control problems we provide high level problem templates to quickly get started. For unitary gate problems, where we want to realize a gate U_textgoal, with a system Hamiltonian of the form,","category":"page"},{"location":"generated/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"H(t) = H_0 + sum_i a^i(t) H_i","category":"page"},{"location":"generated/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"there is the UnitarySmoothPulseProblem constructor which only requires","category":"page"},{"location":"generated/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"the drift Hamiltonian, H_0\nthe drive Hamiltonians, qtyH_i\nthe target unitary, U_textgoal\nthe number of timesteps, T\nthe (initial) time step size, Delta t","category":"page"},{"location":"generated/quickstart/#Basic-Usage","page":"Quickstart Guide","title":"Basic Usage","text":"","category":"section"},{"location":"generated/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"For example, to create a problem for a single qubit X gate (with a bound on the drive of a^i  a_textbound), i.e., with system hamiltonian","category":"page"},{"location":"generated/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"H(t) = fracomega2 sigma_z + a^1(t) sigma_x + a^2(t) sigma_y","category":"page"},{"location":"generated/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"we can do the following:","category":"page"},{"location":"generated/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"using NamedTrajectories\nusing QuantumCollocation\n\n# set time parameters\nT = 100\nΔt = 0.1\n\n# use the exported gate dictionary to get the gates we need\nσx = GATES[:X]\nσy = GATES[:Y]\nσz = GATES[:Z]\n\n# define drift and drive Hamiltonians\nH_drift = 0.5 * σz\nH_drives = [σx, σy]\n\n# define target unitary\nU_goal = σx\n\n# set bound on the drive\na_bound = 1.0\n\n# build the problem\nprob = UnitarySmoothPulseProblem(\n    H_drift,\n    H_drives,\n    U_goal,\n    T,\n    Δt;\n    a_bound=a_bound,\n)\n\n# solve the problem\nsolve!(prob; max_iter=30)","category":"page"},{"location":"generated/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"The above output comes from the Ipopt.jl solver. To see the final fidelity we can use the unitary_fidelity function exported by QuantumCollocation.jl.","category":"page"},{"location":"generated/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"println(\"Final fidelity: \", unitary_rollout_fidelity(prob))","category":"page"},{"location":"generated/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"We can also easily plot the solutions using the plot function exported by NamedTrajectories.jl.","category":"page"},{"location":"generated/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"plot(prob.trajectory, [:Ũ⃗, :a])","category":"page"},{"location":"generated/quickstart/#Minimum-Time-Problems","page":"Quickstart Guide","title":"Minimum Time Problems","text":"","category":"section"},{"location":"generated/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"We can also easily set up and solve a minimum time problem, where we enforce a constraint on the final fidelity:","category":"page"},{"location":"generated/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"mathcalF(U_T U_textgoal) geq mathcalF_textmin","category":"page"},{"location":"generated/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"Using the problem we just solved we can do the following:","category":"page"},{"location":"generated/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"# final fidelity constraint\nfinal_fidelity = 0.99\n\n# weight on the minimum time objective\nD = 10.0\n\nprob_min_time = UnitaryMinimumTimeProblem(\n    prob;\n    final_fidelity=final_fidelity,\n    D=D\n)\n\nsolve!(prob_min_time; max_iter=30)","category":"page"},{"location":"generated/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"We can see that the final fidelity is indeed greater than the minimum fidelity we set.","category":"page"},{"location":"generated/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"println(\"Final fidelity:    \", unitary_rollout_fidelity(prob_min_time))","category":"page"},{"location":"generated/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"and that the duration of the pulse has decreased.","category":"page"},{"location":"generated/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"initial_dur = get_times(prob.trajectory)[end]\nmin_time_dur = get_times(prob_min_time.trajectory)[end]\n\nprintln(\"Initial duration:  \", initial_dur)\nprintln(\"Minimum duration:  \", min_time_dur)\nprintln(\"Duration decrease: \", initial_dur - min_time_dur)","category":"page"},{"location":"generated/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"We can also plot the solutions for the minimum time problem.","category":"page"},{"location":"generated/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"plot(prob_min_time.trajectory, [:Ũ⃗, :a])","category":"page"},{"location":"generated/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"","category":"page"},{"location":"generated/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"This page was generated using Literate.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = QuantumCollocation","category":"page"},{"location":"#QuantumCollocation.jl","page":"Home","title":"QuantumCollocation.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Direct Collocation for Quantum Optimal Control (arXiv)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Check out our JuliaCon 2023 talk:","category":"page"},{"location":"","page":"Home","title":"Home","text":"<center>\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/NBdck6UX0Tc?si=YE4iK0mO4GlWnbaW\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" referrerpolicy=\"strict-origin-when-cross-origin\" allowfullscreen></iframe>\n</center>","category":"page"},{"location":"","page":"Home","title":"Home","text":"Also check out the sequel, from JuliaCon 2024.","category":"page"},{"location":"#Example","page":"Home","title":"Example","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using QuantumCollocation\n\nT = 50\nΔt = 0.2\nsystem = QuantumSystem([PAULIS[:X], PAULIS[:Y]])\n\n# Hadamard Gate\nprob = UnitarySmoothPulseProblem(system, GATES[:H], T, Δt)\nsolve!(prob, max_iter=100)\n\nplot_unitary_populations(prob)","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: Single Qubit X-Gate)","category":"page"},{"location":"#Motivation","page":"Home","title":"Motivation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"In quantum optimal control, we are interested in finding a pulse sequence a_1T-1 to drive a quantum system and realize a target gate U_textgoal. We formulate this problem as a nonlinear program (NLP) of the form","category":"page"},{"location":"","page":"Home","title":"Home","text":"beginaligned\nundersetU_1T a_1T-1 Delta t_1T-1textminimize  quad ell(U_T U_textgoal)\ntext subject to   quad f(U_t+1 U_t a_t Delta t_t) = 0 \nendaligned","category":"page"},{"location":"","page":"Home","title":"Home","text":"where f defines the dynamics, implicitly, as constraints on the states and controls, U_1T and a_1T-1, which are both free variables in the solver. This optimization framework is called direct collocation.  For technical details of our implementation please see our paper Direct Collocation for Quantum Optimal Control.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The gist of the method is that the dynamics are given by the solution to the Schrodinger equation, which results in unitary evolution given by exp(-i Delta t H(a_t)), where H(a_t) is the Hamiltonian of the system and Delta t is the timestep.  We can approximate this evolution using Pade approximants:","category":"page"},{"location":"","page":"Home","title":"Home","text":"beginaligned\nf(U_t+1 U_t a_t Delta t_t) = U_t+1 - exp(-i Delta t_t H(a_t)) U_t \napprox U_t+1 - B^-1(a_t Delta t_t) F(a_t Delta t_t) U_t \n= B(a_t Delta t_t) U_t+1 - F(a_t Delta t_t) U_t \nendaligned","category":"page"},{"location":"","page":"Home","title":"Home","text":"where B(a_t) and F(a_t) are the backward and forward Pade operators and are just polynomials in H(a_t). ","category":"page"},{"location":"","page":"Home","title":"Home","text":"This implementation is possible because direct collocation allows for the dynamics to be implicit. Since numerically calculating matrix exponentials inherently requires an approximation – the Padé approximant is commonly used – utilizing this formulation significantly improves performance, as, at least here, no matrix inversion is required.","category":"page"},{"location":"#Index","page":"Home","title":"Index","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"generated/man/ipopt_callbacks/","page":"Callbacks","title":"Callbacks","text":"EditURL = \"../../../literate/man/ipopt_callbacks.jl\"","category":"page"},{"location":"generated/man/ipopt_callbacks/","page":"Callbacks","title":"Callbacks","text":"CollapsedDocStrings = true","category":"page"},{"location":"generated/man/ipopt_callbacks/#IpOpt-Callbacks","page":"Callbacks","title":"IpOpt Callbacks","text":"","category":"section"},{"location":"generated/man/ipopt_callbacks/","page":"Callbacks","title":"Callbacks","text":"This page describes the callback functions that can be used with the IpOpt solver (in the future, may describe more general callback behavior).","category":"page"},{"location":"generated/man/ipopt_callbacks/#Callbacks","page":"Callbacks","title":"Callbacks","text":"","category":"section"},{"location":"generated/man/ipopt_callbacks/","page":"Callbacks","title":"Callbacks","text":"using QuantumCollocation\nusing NamedTrajectories\n\nimport ..QuantumStateSmoothPulseProblem\nimport ..Callbacks","category":"page"},{"location":"generated/man/ipopt_callbacks/","page":"Callbacks","title":"Callbacks","text":"By default, IpOpt callbacks are called at each optimization step with the following signature:","category":"page"},{"location":"generated/man/ipopt_callbacks/","page":"Callbacks","title":"Callbacks","text":"function full_argument_list_callback(\n    alg_mod::Cint,\n    iter_count::Cint,\n    obj_value::Float64,\n    inf_pr::Float64,\n    inf_du::Float64,\n    mu::Float64,\n    d_norm::Float64,\n    regularization_size::Float64,\n    alpha_du::Float64,\n    alpha_pr::Float64,\n    ls_trials::Cint,\n)\n    return true\nend","category":"page"},{"location":"generated/man/ipopt_callbacks/","page":"Callbacks","title":"Callbacks","text":"This gives the user access to some of the optimization state internals at each iteration. A callback function with any subset of these arguments can be passed into the solve! function via the callback keyword argument see below.","category":"page"},{"location":"generated/man/ipopt_callbacks/","page":"Callbacks","title":"Callbacks","text":"The callback function can be used to stop the optimization early by returning false. The following callback when passed to solve! will stop the optimization after the first iteration:","category":"page"},{"location":"generated/man/ipopt_callbacks/","page":"Callbacks","title":"Callbacks","text":"my_callback = (kwargs...) -> false","category":"page"},{"location":"generated/man/ipopt_callbacks/#Single-initial-and-target-states","page":"Callbacks","title":"Single initial and target states","text":"","category":"section"},{"location":"generated/man/ipopt_callbacks/","page":"Callbacks","title":"Callbacks","text":"T = 50\nΔt = 0.2\nsys = QuantumSystem(0.1 * GATES[:Z], [GATES[:X], GATES[:Y]])\nψ_init =  Vector{ComplexF64}([1.0, 0.0])\nψ_target =  Vector{ComplexF64}([0.0, 1.0])\n\nprob = QuantumStateSmoothPulseProblem(\n    sys, ψ_init, ψ_target, T, Δt;\n    ipopt_options=IpoptOptions(print_level=1),\n    piccolo_options=PiccoloOptions(verbose=false)\n)","category":"page"},{"location":"generated/man/ipopt_callbacks/","page":"Callbacks","title":"Callbacks","text":"The callback function can be used to monitor the optimization progress, save intermediate results, or modify the optimization process. For example, the following callback function saves the optimization trajectory at each iteration - this can be useful for debugging or plotting the optimization progress. trajectory_history_callback from the Callbacks module","category":"page"},{"location":"generated/man/ipopt_callbacks/","page":"Callbacks","title":"Callbacks","text":"callback, trajectory_history = QuantumCollocation.Callbacks.trajectory_history_callback(prob)\nsolve!(prob, max_iter=20, callback=callback)","category":"page"},{"location":"generated/man/ipopt_callbacks/","page":"Callbacks","title":"Callbacks","text":"Save trajectory images into files which can be used to create a gif like the following:","category":"page"},{"location":"generated/man/ipopt_callbacks/","page":"Callbacks","title":"Callbacks","text":"for (iter, traj) in enumerate(trajectory_history)\n    str_index = lpad(iter, length(string(length(trajectory_history))), \"0\")\n    plot(\"./iteration-$str_index-trajectory.png\", traj, [:ψ̃, :a], xlims=(-Δt, (T+5)*Δt), ylims=(ψ̃1 = (-2, 2), a = (-1.1, 1.1)))\nend","category":"page"},{"location":"generated/man/ipopt_callbacks/","page":"Callbacks","title":"Callbacks","text":"(Image: pulse optimization animation)","category":"page"},{"location":"generated/man/ipopt_callbacks/","page":"Callbacks","title":"Callbacks","text":"Using a callback to get the best trajectory from all the optimization iterations","category":"page"},{"location":"generated/man/ipopt_callbacks/","page":"Callbacks","title":"Callbacks","text":"sys2 = QuantumSystem(0.15 * GATES[:Z], [GATES[:X], GATES[:Y]])\nψ_init2 =  Vector{ComplexF64}([0.0, 1.0])\nψ_target2 =  Vector{ComplexF64}([1.0, 0.0])","category":"page"},{"location":"generated/man/ipopt_callbacks/#Using-other-callbacks-from-the-callback-library","page":"Callbacks","title":"Using other callbacks from the callback library","text":"","category":"section"},{"location":"generated/man/ipopt_callbacks/","page":"Callbacks","title":"Callbacks","text":"Callback used here is best_rollout_fidelity_callback which appends the best trajectories based on monotonically increasing fidelity of the rollout","category":"page"},{"location":"generated/man/ipopt_callbacks/","page":"Callbacks","title":"Callbacks","text":"prob2 = QuantumStateSmoothPulseProblem(\n    sys2, ψ_init2, ψ_target2, T, Δt;\n    ipopt_options=IpoptOptions(print_level=1),\n    piccolo_options=PiccoloOptions(verbose=false)\n)\n\nbest_trajectory_callback, best_trajectory_list = best_rollout_fidelity_callback(prob2)\nsolve!(prob2, max_iter=20, callback=best_trajectory_callback)","category":"page"},{"location":"generated/man/ipopt_callbacks/","page":"Callbacks","title":"Callbacks","text":"fidelity of the last iterate","category":"page"},{"location":"generated/man/ipopt_callbacks/","page":"Callbacks","title":"Callbacks","text":"@show Losses.fidelity(prob2)","category":"page"},{"location":"generated/man/ipopt_callbacks/","page":"Callbacks","title":"Callbacks","text":"fidelity of the best iterate","category":"page"},{"location":"generated/man/ipopt_callbacks/","page":"Callbacks","title":"Callbacks","text":"@show QuantumCollocation.fidelity(best_trajectory_list[end], prob2.system)","category":"page"},{"location":"generated/man/ipopt_callbacks/","page":"Callbacks","title":"Callbacks","text":"","category":"page"},{"location":"generated/man/ipopt_callbacks/","page":"Callbacks","title":"Callbacks","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/man/problem_templates/","page":"Problem Templates","title":"Problem Templates","text":"EditURL = \"../../../literate/man/problem_templates.jl\"","category":"page"},{"location":"generated/man/problem_templates/#Problem-Templates","page":"Problem Templates","title":"Problem Templates","text":"","category":"section"},{"location":"generated/man/problem_templates/","page":"Problem Templates","title":"Problem Templates","text":"We provide a number of problem templates for making it simple and easy to set up and solve certain types of quantum optimal control problems. These templates all construct a QuantumControlProblem object.  The problem templates are:","category":"page"},{"location":"generated/man/problem_templates/#Unitary-Smooth-Pulse-Problem","page":"Problem Templates","title":"Unitary Smooth Pulse Problem","text":"","category":"section"},{"location":"generated/man/problem_templates/","page":"Problem Templates","title":"Problem Templates","text":"UnitarySmoothPulseProblem","category":"page"},{"location":"generated/man/problem_templates/#QuantumCollocation.ProblemTemplates.UnitarySmoothPulseProblem","page":"Problem Templates","title":"QuantumCollocation.ProblemTemplates.UnitarySmoothPulseProblem","text":"UnitarySmoothPulseProblem(system::AbstractQuantumSystem, operator, T, Δt; kwargs...)\nUnitarySmoothPulseProblem(H_drift, H_drives, operator, T, Δt; kwargs...)\n\nConstruct a QuantumControlProblem for a free-time unitary gate problem with smooth control pulses enforced by constraining the second derivative of the pulse trajectory, i.e.,\n\nbeginaligned\nundersetvectildeU a dota ddota Delta ttextminimize  quad\nQ cdot ellqty(vectildeU_T vectildeU_textgoal) + frac12 sum_t qty(R_a a_t^2 + R_dota dota_t^2 + R_ddota ddota_t^2) \ntext subject to   quad vbP^(n)qty(vectildeU_t+1 vectildeU_t a_t Delta t_t) = 0 \n quad a_t+1 - a_t - dota_t Delta t_t = 0 \n quad dota_t+1 - dota_t - ddota_t Delta t_t = 0 \n quad a_t leq a_textbound \n quad ddota_t leq ddota_textbound \n quad Delta t_textmin leq Delta t_t leq Delta t_textmax \nendaligned\n\nwhere, for U in SU(N),\n\nellqty(vectildeU_T vectildeU_textgoal) =\nabs1 - frac1N abs tr qty(U_textgoal U_T) \n\nis the infidelity objective function, Q is a weight, R_a, R_dota, and R_ddota are weights on the regularization terms, and vbP^(n) is the nth-order Pade integrator.\n\nArguments\n\nsystem::AbstractQuantumSystem: the system to be controlled\n\nor\n\nH_drift::AbstractMatrix{<:Number}: the drift hamiltonian\nH_drives::Vector{<:AbstractMatrix{<:Number}}: the control hamiltonians\n\nwith\n\noperator::AbstractPiccoloOperator: the target unitary, either in the form of an EmbeddedOperator or a `Matrix{ComplexF64}\nT::Int: the number of timesteps\nΔt::Float64: the (initial) time step size\n\nKeyword Arguments\n\nipopt_options::IpoptOptions=IpoptOptions(): the options for the Ipopt solver\npiccolo_options::PiccoloOptions=PiccoloOptions(): the options for the Piccolo solver\nstate_name::Symbol = :Ũ⃗: the name of the state\ncontrol_name::Symbol = :a: the name of the control\ntimestep_name::Symbol = :Δt: the name of the timestep\ninit_trajectory::Union{NamedTrajectory, Nothing}=nothing: an initial trajectory to use\na_bound::Float64=1.0: the bound on the control pulse\na_bounds::Vector{Float64}=fill(a_bound, length(system.G_drives)): the bounds on the control pulses, one for each drive\na_guess::Union{Matrix{Float64}, Nothing}=nothing: an initial guess for the control pulses\nda_bound::Float64=Inf: the bound on the control pulse derivative\nda_bounds::Vector{Float64}=fill(da_bound, length(system.G_drives)): the bounds on the control pulse derivatives, one for each drive\nzero_initial_and_final_derivative::Bool=false: whether to enforce zero initial and final control pulse derivatives\ndda_bound::Float64=1.0: the bound on the control pulse second derivative\ndda_bounds::Vector{Float64}=fill(dda_bound, length(system.G_drives)): the bounds on the control pulse second derivatives, one for each drive\nΔt_min::Float64=Δt isa Float64 ? 0.5 * Δt : 0.5 * mean(Δt): the minimum time step size\nΔt_max::Float64=Δt isa Float64 ? 1.5 * Δt : 1.5 * mean(Δt): the maximum time step size\nQ::Float64=100.0: the weight on the infidelity objective\nR=1e-2: the weight on the regularization terms\nR_a::Union{Float64, Vector{Float64}}=R: the weight on the regularization term for the control pulses\nR_da::Union{Float64, Vector{Float64}}=R: the weight on the regularization term for the control pulse derivatives\nR_dda::Union{Float64, Vector{Float64}}=R: the weight on the regularization term for the control pulse second derivatives\nphase_name::Symbol=:ϕ: the name of the phase\nphase_operators::Union{AbstractVector{<:AbstractMatrix}, Nothing}=nothing: the phase operators for free phase corrections\nconstraints::Vector{<:AbstractConstraint}=AbstractConstraint[]: the constraints to enforce\n\n\n\n\n\n","category":"function"},{"location":"generated/man/problem_templates/#Unitary-Minimum-Time-Problem","page":"Problem Templates","title":"Unitary Minimum Time Problem","text":"","category":"section"},{"location":"generated/man/problem_templates/","page":"Problem Templates","title":"Problem Templates","text":"UnitaryMinimumTimeProblem","category":"page"},{"location":"generated/man/problem_templates/#QuantumCollocation.ProblemTemplates.UnitaryMinimumTimeProblem","page":"Problem Templates","title":"QuantumCollocation.ProblemTemplates.UnitaryMinimumTimeProblem","text":"UnitaryMinimumTimeProblem(\n    trajectory::NamedTrajectory,\n    system::AbstractQuantumSystem,\n    objective::Objective,\n    integrators::Vector{<:AbstractIntegrator},\n    constraints::Vector{<:AbstractConstraint};\n    kwargs...\n)\n\nUnitaryMinimumTimeProblem(\n    prob::QuantumControlProblem;\n    kwargs...\n)\n\nCreate a minimum-time problem for unitary control.\n\nbeginaligned\nundersetvectildeU a dota ddota Delta ttextminimize  quad\nJ(vectildeU a dota ddota) + D sum_t Delta t_t \ntext subject to   quad vbP^(n)qty(vectildeU_t+1 vectildeU_t a_t Delta t_t) = 0 \n c(vectildeU a dota ddota) = 0 \n quad Delta t_textmin leq Delta t_t leq Delta t_textmax \nendaligned\n\nArguments\n\ntrajectory::NamedTrajectory: The initial trajectory.\nsystem::AbstractQuantumSystem: The quantum system.\nobjective::Objective: The objective function (additional to the minimum-time objective).\nintegrators::Vector{<:AbstractIntegrator}: The integrators.\nconstraints::Vector{<:AbstractConstraint}: The constraints.\n\nKeyword Arguments\n\nunitary_name::Symbol=:Ũ⃗: The symbol for the unitary control.\nfinal_fidelity::Float64=0.99: The final fidelity.\nD=1.0: The weight for the minimum-time objective.\nipopt_options::IpoptOptions=IpoptOptions(): The options for the Ipopt solver.\npiccolo_options::PiccoloOptions=PiccoloOptions(): The options for the Piccolo solver.\nkwargs...: Additional keyword arguments to pass to QuantumControlProblem.\n\n\n\n\n\n","category":"function"},{"location":"generated/man/problem_templates/","page":"Problem Templates","title":"Problem Templates","text":"","category":"page"},{"location":"generated/man/problem_templates/","page":"Problem Templates","title":"Problem Templates","text":"This page was generated using Literate.jl.","category":"page"}]
}
